@model GoogleRuta.ViewModels.Dise침oViewModel
@using System.Text.Json

@{
    ViewData["Title"] = "Dise침ar Proyecto";
    Layout = "~/Views/Shared/_Layout.cshtml";

    //var initialLat = ViewData["InitialLat"] as double?;
    //var initialLng = ViewData["InitialLng"] as double?;


    var processedCoordsJson = TempData["ProcessedCoordinatess"] as string ?? "[]";
    var projectId = TempData["ProjectId"] as int?;
    var nameTemp = TempData["Name"] as string;

    //color desde el backend
    //tomo cada objeto de la lista , extraigo solo el codigo del color
    //creo un list de string osea un array de string para pasarlo a javascrip
    var colorList = (Model.ColorTraces != null && Model.ColorTraces.Any())
    ? Model.ColorTraces.Select(c => c.Color).ToList()
    : new List<string> { "#FF0000", "#00FF00", "#0000FF" };
}


@* Este es el contenido de tu vista que se renderizar치 dentro de _Layout.cshtml *@

<div class="container-fluid" style="height: calc(100vh - 100px);"> @* Ajusta la altura del contenedor principal de tu vista *@
    <h2 class="mt-3">Dashboard</h2>

    <div id="map" style="height: 100%; width: 100%;"></div>
    <button id="saveCoordsBtn" class="btn btn-primary mt-3">Guardar</button>

</div>

<div class="modal fade" id="elementModal" tabindex="-1" aria-labelledby="elementModalLabel" aria-hidden="true">
    <!-- 1. Modal extra grande con la clase "modal-xl" -->
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="elementModalLabel">Lienzo de Dise침o Profesional</h5>

                <!-- Controles de dibujo se mantienen en la cabecera -->
                <div class="ms-auto d-flex align-items-center">
                    <label for="colorPicker" class="form-label mb-0 me-2 small">Color:</label>
                    <input type="color" class="form-control form-control-sm me-3" id="colorPicker" value="#000000"
                        style="width: 50px;">

                    <label for="brushSize" class="form-label mb-0 me-2 small">Grosor:</label>
                    <input type="range" class="form-range me-3" id="brushSize" min="1" max="10" value="2"
                        style="width: 100px;">

                    <button id="clearCanvasBtn" class="btn btn-sm btn-outline-danger">Limpiar Todo</button>
                </div>

                <!-- 4. Bot칩n de cierre est치ndar en la cabecera -->
                <button type="button" class="btn-close ms-3" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>

            <!-- 3. Cuerpo del modal con fondo gris claro para resaltar el lienzo -->
            <div class="modal-body p-2" style="background-color: #f8f9fa; text-align: center;">

                <!-- Barra de herramientas (sin cambios) -->
                <div id="toolbar"
                    class="mb-2 p-2 rounded d-flex justify-content-center align-items-center bg-light border-bottom">
                    <div class="me-3 border-end pe-3">
                        <span class="me-2 small">MODO:</span>
                        <button id="selectModeBtn" class="btn btn-sm btn-primary"
                            title="Modo Selecci칩n (Mover, Seleccionar, Borrar)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                                class="bi bi-cursor-fill" viewBox="0 0 16 16">
                                <path
                                    d="M14.082 2.182a.5.5 0 0 1 .103.557L8.528 15.467a.5.5 0 0 1-.917-.007L5.57 10.694.803 8.652a.5.5 0 0 1-.006-.916l12.728-5.657a.5.5 0 0 1 .556.103z" />
                            </svg>
                        </button>
                        <button id="drawModeBtn" class="btn btn-sm btn-outline-secondary"
                            title="Modo Conector (Dibujar L칤neas)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                                class="bi bi-slash-lg" viewBox="0 0 16 16">
                                <path fill-rule="evenodd"
                                    d="M13.854 2.146a.5.5 0 0 1 0 .708l-11 11a.5.5 0 0 1-.708-.708l11-11a.5.5 0 0 1 .708 0z" />
                            </svg>
                        </button>
                    </div>
                    <div id="componentGeneratorControls" class="d-flex align-items-center">
                        <div class="me-3"><span class="me-2 small">CABLE:</span>
                            <button class="btn btn-sm btn-outline-primary" data-strands="5">1x5</button>
                            <button class="btn btn-sm btn-outline-primary" data-strands="8">1x8</button>
                            <button class="btn btn-sm btn-outline-primary" data-strands="12">1x12</button>
                        </div>
                        <div><span class="me-2 small">SPLITTER:</span>
                            <button class="btn btn-sm btn-outline-success" data-splitter-out="4">1x4</button>
                            <button class="btn btn-sm btn-outline-success" data-splitter-out="8">1x8</button>
                            <button class="btn btn-sm btn-outline-success" data-splitter-out="16">1x16</button>
                        </div>
                    </div>
                </div>

                <!-- 2. Contenedor del lienzo con fondo de cuadr칤cula -->
                <div id="konva-container" style="
                    border: 1px solid #ccc;
                    display: inline-block;
                    background-color: #ffffff;
                    background-image:
                        linear-gradient(#e0e0e0 1px, transparent 1px),
                        linear-gradient(90deg, #e0e0e0 1px, transparent 1px);
                    background-size: 20px 20px;">
                </div>

            </div>
            <div class="modal-footer">
                <!-- Se puede simplificar, ya que el cierre principal est치 en la cabecera -->
                <button type="button" id="saveCanvasBtn" class="btn btn-primary">Guardar Dise침o</button>
            </div>
        </div>
    </div>
</div>


<script src="https://unpkg.com/konva@9.3.0/konva.min.js"></script>


@section Scripts {
    <style>
        /* Estilos para el bot칩n activo. Da feedback visual al usuario. */
        .custom-element-button.active {
            background-color: #e0e0e0 !important;
            border: 1px solid #3385ff !important;
        }

        /* NUEVOS ESTILOS PARA LOS BOTONES DE COLORES */
        .custom-color-button.active {
            border: 2px solid #3385ff !important;
            box-shadow: 0 0 3px rgba(51, 133, 255, 0.5) !important;
        }

        .custom-color-button:hover {
            transform: scale(1.1);
            transition: transform 0.1s ease;
        }

        .canvas-color-btn.active-canvas-color {
            border: 2px solid #007bff !important;
            box-shadow: 0 0 3px rgba(0, 123, 255, 0.5) !important;
        }

        .canvas-color-btn:hover {
            transform: scale(1.05);
            transition: transform 0.1s ease;
        }
    </style>

    <script>
        //variable para rastrear la polil칤nea seleccionada
        let selectedPolyline = null;

        var nameJs = '@(nameTemp ?? "")';
        console.log("ver name ", nameJs);

        const currentProjectId = @(projectId.HasValue? projectId.Value.ToString() : "null");
        console.log("ID del proyecto disponible en JS:", currentProjectId);

        @{
                // Usamos LINQ para crear una nueva lista de objetos an칩nimos.
                // Para cada elemento, copiamos sus propiedades y transformamos 'iconUrl'
                // usando Url.Content() para generar una ruta v치lida para el navegador.
                var elementTypesForJs = Model.ElementTypes.Select(e => new
                {
                    id = e.Id,
                                                                                                                                                       name = e.Name,
                                                                                                                                                       iconUrl = Url.Content(e.IconoUrl) // <-- 춰Esta es la correcci칩n!
                });
            }

                                                     // Ahora serializamos la nueva lista con las URLs corregidas.
                                                     const elementTypes = @Html.Raw(Json.Serialize(elementTypesForJs));
        console.log("Tipos de Elementos (con URLs corregidas):", elementTypes);

        //traer la lista de colores desde el contrrolador
        const availableColors =@Html.Raw(JsonSerializer.Serialize(colorList));
        console.log("游꿛 Colores disponibles:", availableColors);
        const availableColorsComplete = @Html.Raw(JsonSerializer.Serialize(Model.ColorTraces ?? new List<ColorTraces>()));
        console.log("游꿛 Colores disponibles:", availableColorsComplete);

        // El problema: existingElements es un STRING, no un Array.
        // La Soluci칩n: Convertimos (parseamos) el string a un Array de JavaScript real.
        // ======================================================================
        const existingElements = @Html.Raw(TempData["ExistingPlacedElements"] as string ?? "[]");
        console.log("ver elementos llegando a la vista dise침o (YA PARSEADO):", existingElements);
                                                                                                                                                                                                                                                                            @*const existingElementsJson = '@Html.Raw(TempData["ExistingPlacedElements"] as string ?? "[]")';
        const existingElements = JSON.parse(existingElementsJson);
        console.log("ver elementos llegando a la vista dise침o (YA PARSEADO):", existingElements); *@

            let currentPolygon = null;
        let currentPolyLine = null;
        let currentPolygonCoords = [];
        let currentPolylineCoords = [];

        // Aqu칤 guardaremos todos los elementos (postes, cajas, etc.) que el usuario coloque.
        let placedElements = [];
        //Variable para gestionar el listener del mapa ---
        let mapClickListener = null;
        // Agregamos una variable para guardar el tipo de elemento activo
        let activeElementType = null;
        //tomo los datos del elemento para enviarlo al controlador dibujo
        let selectedMapElementData = null;

        function initMap() {
            let center;
            // Procesar coordenadas de la base de datos con validaci칩n
            const rawCoords = JSON.parse(@Html.Raw(JsonSerializer.Serialize(processedCoordsJson)));
            const processedCoords = rawCoords.map(coord => ({
                lat: parseFloat(coord.lat || coord.Lat || 0),
                lng: parseFloat(coord.lng || coord.Lng || 0)
            })).filter(coord =>
                !isNaN(coord.lat) && !isNaN(coord.lng) &&
                isFinite(coord.lat) && isFinite(coord.lng)
            );

            console.log("coordenadas procesadas", processedCoords)
            console.log("ver lista pintar", processedCoords)

            const mapCenterLat = parseFloat('@(Model.InitialLat.HasValue? Model.InitialLat.Value.ToString(System.Globalization.CultureInfo.InvariantCulture) : "-13.44255087")');
            const mapCenterLng = parseFloat('@(Model.InitialLng.HasValue? Model.InitialLng.Value.ToString(System.Globalization.CultureInfo.InvariantCulture) : "-76.1470107")');

            if (processedCoords.length > 0) {
                center = { lat: processedCoords[0].lat, lng: processedCoords[0].lng };

            }
            else {
                center = { lat: mapCenterLat, lng: mapCenterLng };
            }

            const map = new google.maps.Map(document.getElementById("map"), {
                zoom: 12,
                center: center,
                mapTypeId: "terrain",
                mapTypeControl: true,
                streetViewControl: true,
                fullscreenControl: true
            });

            if (processedCoords.length > 0) {
                const path = processedCoords.map(p => ({ lat: p.lat, lng: p.lng }));

                const polyline = new google.maps.Polyline({
                    path: path,
                    map: map,
                    strokeColor: '#0000FF',
                    strokeOpacity: 0.8,
                    strokeWeight: 3,
                    clickable: true,
                    editable: true,
                    zIndex: 1,
                });

                currentPolyLine = polyline;
                setPolylineListeners(currentPolyLine);
                selectedPolyline = currentPolyLine;
                currentPolyLine.setOptions({
                    strokeWeight: 5,
                    strokeOpacity: 1.0
                });
                console.log('L칤nea inicial auto-seleccionada');
                updatePolylineCoords(currentPolyLine);
            } else {
                new google.maps.Marker({
                    position: center,
                    map: map,
                    title: "Ubicaci칩n inicial"
                });
            }


            //Dibujar los elementos(cajas,postes etc al cargar)
            if (existingElements.length > 0) {
                console.log(`Cargando ${existingElements.length} elementos existentes.`);

                existingElements.forEach(element => {
                    // Buscamos el tipo de elemento completo para obtener su URL de icono
                    const elementType = elementTypes.find(t => t.id === element.ElementTypeId);
                    if (elementType) {
                        const location = { lat: element.Lat, lng: element.Lng };
                        console.log("Encontrado tipo de elemento, dibujando marcador en:", location);
                        // Reutilizamos la funci칩n que ya tienes para colocar marcadores
                        placeMarker(location, elementType, map, element);
                    }
                });

            }

            // --- FUNCI칍N DE LISTENERS MEJORADA CON BORRADO MANUAL ---
            function setPolylineListeners(polyline) {
                // Listeners para arrastrar y a침adir puntos (estos suelen funcionar bien)
                google.maps.event.addListener(polyline.getPath(), 'set_at', () => updatePolylineCoords(polyline));
                google.maps.event.addListener(polyline.getPath(), 'insert_at', () => updatePolylineCoords(polyline));

                // Listener para el evento de borrado que ya ten칤as (lo dejamos como respaldo)
                google.maps.event.addListener(polyline.getPath(), 'remove_at', () => updatePolylineCoords(polyline));

                // *** LISTENER CLAVE PARA EL BORRADO MANUAL POR CLIC DERECHO ***
                google.maps.event.addListener(polyline, 'rightclick', function (event) {
                    // El evento 'rightclick' nos da informaci칩n sobre d칩nde se hizo clic.
                    // 'event.vertex' nos dir치 el 칤ndice del v칠rtice si se hizo clic en uno.
                    if (event.vertex !== undefined && event.vertex !== null) {
                        console.log(`Clic derecho detectado en el v칠rtice: ${event.vertex}`);

                        // Obtenemos el path (la ruta) de la polil칤nea.
                        const path = polyline.getPath();

                        // Eliminamos el v칠rtice en ese 칤ndice.
                        path.removeAt(event.vertex);

                        // Nota: No es necesario llamar a updatePolylineCoords aqu칤, porque
                        // removeAt dispara autom치ticamente el evento 'remove_at' que ya estamos escuchando.
                    }
                });

                // NUEVO: Listener para seleccionar la polil칤nea con clic izquierdo
                google.maps.event.addListener(polyline, 'click', function () {
                    // Resetear el estilo de la polil칤nea anteriormente seleccionada
                    if (selectedPolyline && selectedPolyline !== polyline) {
                        selectedPolyline.setOptions({
                            strokeWeight: 3,
                            strokeOpacity: 0.8
                        });
                    }

                    // Marcar esta polil칤nea como seleccionada
                    selectedPolyline = polyline;

                    // Cambiar el estilo para indicar que est치 seleccionada
                    polyline.setOptions({
                        strokeWeight: 5,  // M치s gruesa
                        strokeOpacity: 1.0 // M치s opaca
                    });

                    console.log('Polil칤nea seleccionada');
                });

            }

            function setPolygonListeners(polygon) {
                google.maps.event.addListener(polygon.getPath(), 'set_at', () => updatePolygonCoords(polygon));
                google.maps.event.addListener(polygon.getPath(), 'insert_at', () => updatePolygonCoords(polygon));
                google.maps.event.addListener(polygon.getPath(), 'remove_at', () => updatePolygonCoords(polygon));
            }

            const drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: google.maps.drawing.OverlayType.POLYLINE,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.POLYLINE,
                        google.maps.drawing.OverlayType.MARKER
                    ],
                },
                polygonOptions: {
                    fillColor: '#AA0000', fillOpacity: 0.3, strokeWeight: 2,
                    strokeColor: '#FF0000', clickable: true, editable: true, zIndex: 1,
                },
                polylineOptions: {
                    strokeColor: '#0000FF', strokeOpacity: 0.8, strokeWeight: 3,
                    clickable: true, editable: true, zIndex: 1,
                }
            });

            drawingManager.setMap(map);

            google.maps.event.addListener(drawingManager, 'overlaycomplete', function (event) {
                // Si se completa un dibujo de Google, nos aseguramos de que ninguno de nuestros botones est칠 activo.
                deactivateCustomButtons();
                if (event.type == google.maps.drawing.OverlayType.POLYGON) {
                    if (currentPolyLine) {
                        google.maps.event.clearInstanceListeners(currentPolyLine.getPath());
                        google.maps.event.clearInstanceListeners(currentPolyLine);
                        currentPolyLine.setMap(null);
                        currentPolyLine = null;
                        currentPolylineCoords = [];
                    }
                    if (currentPolygon) {
                        google.maps.event.clearInstanceListeners(currentPolygon.getPath());
                        google.maps.event.clearInstanceListeners(currentPolygon);
                        currentPolygon.setMap(null);
                    }
                    currentPolygon = event.overlay;
                    setPolygonListeners(currentPolygon);
                    updatePolygonCoords(currentPolygon);
                    drawingManager.setDrawingMode(null);

                } else if (event.type == google.maps.drawing.OverlayType.POLYLINE) {

                    if (currentPolygon) {
                        google.maps.event.clearInstanceListeners(currentPolygon.getPath());
                        google.maps.event.clearInstanceListeners(currentPolygon);
                        currentPolygon.setMap(null);
                        currentPolygon = null;
                        currentPolygonCoords = [];
                    }

                    const newPolylineSegment = event.overlay;
                    let combinedPath = [];

                    if (currentPolyLine) {
                        google.maps.event.clearInstanceListeners(currentPolyLine.getPath());
                        google.maps.event.clearInstanceListeners(currentPolyLine);
                        combinedPath = currentPolyLine.getPath().getArray();
                        currentPolyLine.setMap(null);
                    }

                    combinedPath = combinedPath.concat(newPolylineSegment.getPath().getArray());
                    newPolylineSegment.setMap(null);

                    const newCombinedPolyline = new google.maps.Polyline({
                        path: combinedPath, map: map,
                        strokeColor: '#0000FF', strokeOpacity: 0.8, strokeWeight: 3,
                        clickable: true, editable: true, zIndex: 1,
                    });

                    currentPolyLine = newCombinedPolyline;
                    setPolylineListeners(currentPolyLine);
                    updatePolylineCoords(currentPolyLine);
                    // 
                    selectedPolyline = newCombinedPolyline;
                    newCombinedPolyline.setOptions({
                        strokeWeight: 5,
                        strokeOpacity: 1.0
                    });
                    console.log('Nueva l칤nea combinada auto-seleccionada');
                    drawingManager.setDrawingMode(null);
                }
            });

            function updatePolygonCoords(polygon) {
                const path = polygon.getPath();
                currentPolygonCoords = [];
                path.getArray().forEach(function (latLng) {
                    currentPolygonCoords.push({ lat: latLng.lat(), lng: latLng.lng() });
                });
                console.log("Coordenadas del pol칤gono actualizadas:", currentPolygonCoords);
            }

            function updatePolylineCoords(polyline) {
                const path = polyline.getPath();
                currentPolylineCoords = [];
                path.getArray().forEach(function (latLng) {
                    currentPolylineCoords.push({ lat: latLng.lat(), lng: latLng.lng() });
                });
                console.log("Coordenadas de la polil칤nea actualizadas:", currentPolylineCoords);
            }

            //NUEVO C칍DIGO: A칌ADIR CONTROLES PERSONALIZADOS PARA ELEMENTOS ---
            // Le pasamos el 'drawingManager' para poder controlarlo
            createCustomElementControls(map, drawingManager);
            createCustomColorControls(map, drawingManager);

        }

        //variable selectedColor asignado a null
        let selectedColor = null;


        function createCustomColorControls(map, drawingManager) {
            // 1. Crea un contenedor para los botones de colores
            const colorToolbar = document.createElement('div');

            colorToolbar.style.margin = '8px';
            colorToolbar.style.display = 'flex';
            colorToolbar.style.gap = '2px';
            colorToolbar.style.backgroundColor = 'white';
            colorToolbar.style.padding = '3px';
            colorToolbar.style.borderRadius = '2px';
            colorToolbar.style.boxShadow = 'rgba(0, 0, 0, 0.3) 0px 1px 4px -1px';
            colorToolbar.id = 'customColorToolbar';

            // 2. Itera sobre los colores disponibles para crear un bot칩n para cada uno
            availableColorsComplete.forEach(colorObject => {
                const button = document.createElement('button');
                button.className = 'custom-color-button'; // Clase para aplicar estilos

                button.style.backgroundColor = colorObject.Color; // El color de fondo es el color real
                button.style.border = '2px solid #ccc';
                button.style.width = '24px';
                button.style.height = '24px';
                button.style.borderRadius = '4px';
                button.style.cursor = 'pointer';
                button.style.margin = '1px';
                button.title = `Nombre: ${colorObject.name} - Color: ${colorObject.Color}`; // Mostramos m치s informaci칩n en el tooltip (t칤tulo)

                // Efecto hover
                button.addEventListener('mouseenter', () => {
                    if (!button.classList.contains('active')) {
                        button.style.border = '2px solid #666';
                    }
                });

                button.addEventListener('mouseleave', () => {
                    if (!button.classList.contains('active')) {
                        button.style.border = '2px solid #ccc';
                    }
                });

                // Evento de clic para seleccionar el color
                button.addEventListener('click', () => {
                    // Verificar si hay una polil칤nea seleccionada
                    if (!selectedPolyline) {
                        alert('Por favor, selecciona una l칤nea primero haciendo clic en ella');
                        return;
                    }
                    // 1. Desactivamos todos los otros botones de color
                    deactivateColorButtons();

                    // 2. Activamos ESTE bot칩n
                    button.classList.add('active');
                    button.style.border = '2px solid #3385ff';
                    button.style.boxShadow = '0 0 3px rgba(51, 133, 255, 0.5)';

                    // 3. Guardamos el OBJETO COMPLETO del color seleccionado
                    selectedColor = colorObject;

                    console.log("游꿛 Color seleccionado:", selectedColor);
                    //Solo cambiar el color de la polil칤nea SELECCIONADA
                    selectedPolyline.setOptions({ strokeColor: selectedColor.Color });

                    // 4. Aqu칤 puedes agregar l칩gica adicional, como cambiar el color de las l칤neas futuras
                    // Por ejemplo, si tienes un drawingManager:
                    // drawingManager.setOptions({
                    //     polylineOptions: {
                    //         ...drawingManager.get('polylineOptions'),
                    //         strokeColor: color
                    //     }
                    // });
                    //NUEVA FUNCIONALIDAD: Cambiamos el color de las futuras polil칤neas
                    drawingManager.setOptions({
                        polylineOptions: {
                            strokeColor: selectedColor.Color // Usamos la propiedad .Color
                        }
                    });

                });

                colorToolbar.appendChild(button);
            });

            // 3. A침ade la barra de colores al mapa (puedes cambiar la posici칩n seg칰n prefieras)
            map.controls[google.maps.ControlPosition.TOP_RIGHT].push(colorToolbar);
        }
        // Funci칩n para desactivar todos los botones de color
        function deactivateColorButtons() {
            document.querySelectorAll('#customColorToolbar .custom-color-button').forEach(button => {
                button.classList.remove('active');
                button.style.border = '2px solid #ccc';
                button.style.boxShadow = 'none';
            });
        }

        // Funci칩n mejorada para obtener el color seleccionado (ahora devuelve solo el string del color)
        function getSelectedColor() {
            // Si un objeto de color est치 seleccionado, devuelve su propiedad .Color.
            // Si no, devuelve el primer color del array de strings como predeterminado.
            return selectedColor ? selectedColor.Color : availableColors[0];
        }



        //FUNCI칍N ACTUALIZADA: Crea los botones y gestiona el estado activo.

        function createCustomElementControls(map, drawingManager) {
            // 1. Crea un contenedor para nuestros botones.
            const toolbar = document.createElement('div');

            toolbar.style.margin = '8px'; // Espacio respecto a los controles de Google
            toolbar.style.display = 'flex';
            toolbar.style.gap = '2px';
            toolbar.style.backgroundColor = 'white';
            toolbar.style.padding = '3px';
            toolbar.style.borderRadius = '2px';
            toolbar.style.boxShadow = 'rgba(0, 0, 0, 0.3) 0px 1px 4px -1px';
            toolbar.id = 'customToolbar'; // Le damos un ID para encontrarlo despu칠s

            // 2. Itera sobre tus tipos de elementos para crear un bot칩n para cada uno.
            elementTypes.forEach(elementType => {
                const button = document.createElement('button');
                button.className = 'custom-element-button'; // Clase para aplicar estilos

                button.style.backgroundColor = 'white';
                button.style.border = 'none';
                button.style.padding = '5px';
                button.style.cursor = 'pointer';
                button.title = elementType.name;
                button.innerHTML = `<img src="${elementType.iconUrl}" style="width:18px; height:18px;">`;

                button.addEventListener('click', () => {
                    // 1. Desactivamos cualquier herramienta de Google y otros botones personalizados
                    deactivateCustomButtons();
                    drawingManager.setDrawingMode(null);

                    // 2. Activamos ESTE bot칩n
                    button.classList.add('active');
                    map.setOptions({ draggableCursor: 'crosshair' });

                    // 3. Establecemos el tipo de elemento activo
                    activeElementType = elementType;

                    // 4. Agregamos el listener de clic en el mapa para colocar elementos,
                    // pero esta vez es un addListener normal, no once.
                    // 춰Esto nos permite colocar m칰ltiples elementos!
                    if (mapClickListener) {
                        google.maps.event.removeListener(mapClickListener);
                    }
                    mapClickListener = google.maps.event.addListener(map, 'click', (event) => {
                        placeMarker(event.latLng, activeElementType, map);
                    });

                    console.log(`Modo de colocaci칩n activado para: ${elementType.name}`);
                });

                toolbar.appendChild(button);
            });

            map.controls[google.maps.ControlPosition.TOP_CENTER].push(toolbar);
        }

        function deactivateCustomButtons() {
            document.querySelectorAll('#customToolbar .custom-element-button').forEach(b => {
                b.classList.remove('active');
            });
            if (mapClickListener) {
                google.maps.event.removeListener(mapClickListener);
                mapClickListener = null;
            }
            // Asumiendo que 'map' es accesible globalmente o pasado como par치metro
            const map = document.getElementById('map').__gmap_instance__;
            if (map) map.setOptions({ draggableCursor: '' });
        }

        function placeMarker(location, elementType, map, element) {
            // 1. Extrae las coordenadas de forma segura (esto ya lo ten칤as bien)
            const latitude = typeof location.lat === 'function' ? location.lat() : location.lat;
            const longitude = typeof location.lng === 'function' ? location.lng() : location.lng;

            // 2. Crea el objeto de datos CON un ID 칰nico para la sesi칩n.
            // Usamos Date.now() y un n칰mero aleatorio para asegurar que sea 칰nico.
            const elementData = {
                databaseId: element ? element.Id : null,
                DrawingId: element ? element.DrawingId : null,
                internalId: Date.now() + Math.random(), // ID 칰nico para vincular marcador y datos
                lat: latitude,
                lng: longitude,
                elementTypeId: elementType.id
            };

            // 3. Crea el marcador visual
            const marker = new google.maps.Marker({
                position: { lat: latitude, lng: longitude }, // Es mejor usar el objeto lat/lng aqu칤
                map: map,
                icon: {
                    url: elementType.iconUrl,
                    scaledSize: new google.maps.Size(32, 32),
                    origin: new google.maps.Point(0, 0),
                    anchor: new google.maps.Point(16, 16)
                }
            });

            // 4. Vincula el marcador con los datos guardando el ID 칰nico en el propio marcador.
            marker.internalId = elementData.internalId;

            // 5. 춰LA CLAVE! A침ade el listener de click derecho para la eliminaci칩n.
            google.maps.event.addListener(marker, 'rightclick', function () {
                // 'this' dentro de este listener se refiere al marcador que fue clickeado.

                // a) Elimina el marcador visual del mapa.
                this.setMap(null);

                // b) Encuentra y elimina el objeto de datos del array 'placedElements'.
                // Usamos .filter() para crear un nuevo array que excluya el elemento con nuestro ID.
                placedElements = placedElements.filter(el => el.internalId !== this.internalId);

                console.log(`Elemento con ID ${this.internalId} eliminado.`);
                console.log("Estado actual de 'placedElements':", placedElements);
            });


            google.maps.event.addListener(marker, 'click', function () {
                // 1. Obtenemos los datos del elemento seleccionado
                selectedMapElementData = placedElements.find(el => el.internalId === this.internalId);
                console.log("Elemento seleccionado:", selectedMapElementData);

                // 2. Antes de mostrar el modal, limpiamos el lienzo anterior.
                // Esta funci칩n la crearemos en el script de dibujo.
                //limpiarLienzoKonva();
                window.limpiarLienzoKonvaGlobal();

                // 3. Verificamos si este elemento tiene un dibujo guardado
                // Nota: El 'drawingId' debe llegar desde tu 'PlacedElements' en el ViewModel
                if (selectedMapElementData && selectedMapElementData.DrawingId) {
                    console.log(`Este elemento tiene un dibujo asociado. ID: ${selectedMapElementData.DrawingId}. Pidiendo datos...`);

                    // 4. Hacemos la llamada AJAX para obtener los datos del dibujo
                    $.ajax({
                        url: `/Project/GetDrawing/${selectedMapElementData.DrawingId}`, // Usamos la nueva ruta
                        type: 'GET',
                        success: function (drawingData) {
                            console.log("Datos del dibujo recibidos:", drawingData);
                            // Llamamos a la funci칩n que dibujar치 todo en el lienzo.
                            // Esta funci칩n la crearemos en el script de dibujo.
                            //dibujarDesdeDatos(drawingData);
                            window.dibujarDesdeDatosGlobal(drawingData);
                        },
                        error: function (xhr) {
                            console.error("Error al cargar los datos del dibujo:", xhr.responseText);
                            alert("No se pudieron cargar los datos del dibujo guardado.");
                        }
                    });
                }

                // 5. Guardamos los datos en el modal y lo mostramos (esto no cambia)
                const elementModal = document.getElementById('elementModal');
                if (selectedMapElementData) {
                    elementModal.dataset.elementProjectId = selectedMapElementData.databaseId;
                    // ... guardar los otros datos
                }
                var myModal = new bootstrap.Modal(elementModal);
                myModal.show();
            });


            // 6. A침ade el elemento con su nuevo ID al array que se enviar치 al guardar.
            placedElements.push(elementData);

            console.log("Elemento colocado/cargado:", elementData);
            console.log("Todos los elementos:", placedElements);

            @* // 1. Dibuja el marcador visual en el mapa (esta parte est치 bien)
            // Google Maps es inteligente y la propiedad "position" acepta ambos tipos de objeto.
            const marker = new google.maps.Marker({
                position: location,
                map: map,
                icon: {
                    url: elementType.iconUrl, // La URL de la imagen
                    scaledSize: new google.maps.Size(32, 32), // 춰La clave! El nuevo tama침o en p칤xeles (ancho, alto)
                    origin: new google.maps.Point(0, 0),      // Punto de origen de la imagen
                    anchor: new google.maps.Point(16, 16)     // D칩nde se ancla el icono (el centro en este caso)
                }
                //icon: elementType.iconUrl
            });

            // 2. Extrae las coordenadas de forma segura, sin importar el tipo de objeto 'location'
             const latitude = typeof location.lat === 'function' ? location.lat() : location.lat;
             const longitude = typeof location.lng === 'function' ? location.lng() : location.lng;

            // 3. Crea el objeto de datos con las coordenadas num칠ricas correctas
            const elementData = {
                lat: latitude,
                lng: longitude,
                elementTypeId: elementType.id
            };

            // 4. A침ade el elemento al array que se enviar치 al guardar
            placedElements.push(elementData);

            console.log("Elemento colocado:", elementData);
            console.log("Todos los elementos:", placedElements);*@
                                                                                                                                                                                                                                                                            }

        document.getElementById('saveCoordsBtn').addEventListener('click', function () {
            let dataToSend = null; // Inicializamos a null

            // Verificamos cu치l arreglo de coordenadas tiene datos
            if (currentPolygonCoords.length > 0) {
                dataToSend = {
                    Name: nameJs,
                    Id: currentProjectId,
                    Type: 'polygon', // A칰n enviamos el tipo para que el controlador sepa c칩mo procesarlo
                    Coordinates: currentPolygonCoords.map(c => [c.lat, c.lng]),
                    PlacedElements: placedElements
                };
                console.log("Enviando coordenadas de pol칤gono:", dataToSend);
            } else if (currentPolylineCoords.length > 0) {
                dataToSend = {
                    Name: nameJs,
                    Id: currentProjectId,
                    Type: 'polyline', // A칰n enviamos el tipo
                    Coordinates: currentPolylineCoords.map(c => [c.lat, c.lng]),
                    PlacedElements: placedElements
                };
                console.log("Enviando coordenadas de polil칤nea:", dataToSend);
            } else {
                alert("Por favor, dibuja un pol칤gono o una polil칤nea antes de guardar.");
                return; // Detiene la funci칩n si no hay nada dibujado
            }

            // Si dataToSend sigue siendo null, significa que no se dibuj칩 nada v치lido.
            if (dataToSend === null) {
                alert("No hay una forma v치lida dibujada para guardar.");
                return;
            }

            console.log("游닋 Datos que se van a enviar:", dataToSend);
            console.log("游닋 JSON a enviar:", JSON.stringify(dataToSend));

            // Env칤a los datos usando la API Fetch
            fetch('/Project/Coordinate', { // 춰Importante! Reemplaza con tu controlador y acci칩n reales.
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    // 'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value // Si lo usas
                },
                body: JSON.stringify(dataToSend)
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Error HTTP! estado: ${response.status}`);
                    }
                    return response.json(); // Esperamos el JSON { redirectToUrl: '...' }
                })
                .then(data => {
                    // 춰칄XITO! Ahora redirigimos el navegador a la URL que nos dio el servidor.
                    console.log('Datos guardados. Redirigiendo a:', data.redirectToUrl);
                    window.location.href = data.redirectToUrl;
                })
                .catch((error) => {
                    console.error('Error:', error);
                    alert('Hubo un error al guardar las coordenadas: ' + error.message);
                });

        });




        // Esta l칤nea es crucial para que Google Maps sepa qu칠 funci칩n llamar una vez que el API est칠 cargada
        window.initMap = initMap;



        // Paletas de colores para los cables. Definidas aqu칤 para mayor claridad y facilidad de modificaci칩n.
        const CABLE_COLOR_PALETTES = {
            // Colores espec칤ficos para el cable de 5 hilos, como solicitaste.
            5: ['#FFEB3B', '#2196F3', '#000000', '#F44336', '#4CAF50'], // Amarillo, Azul, Negro, Rojo, Verde

            // C칩digo de colores est치ndar TIA-598-C para 12 fibras. Se usar치 para cables de 8, 12 y otros tama침os.
            default: [
                '#007bff', // 1. Azul
                '#fd7e14', // 2. Naranja
                '#28a745', // 3. Verde
                '#a0522d', // 4. Marr칩n
                '#6c757d', // 5. Gris (Slate)
                '#ffffff', // 6. Blanco
                '#dc3545', // 7. Rojo
                '#000000', // 8. Negro
                '#ffc107', // 9. Amarillo
                '#8a2be2', // 10. Violeta
                '#e83e8c', // 11. Rosa
                '#17a2b8'  // 12. Aguamarina
            ]
        };

        // =================================================================================
        // =========== INICIO DE LA L칍GICA DE KONVA.JS (CON CONECTORES ORTOGONALES) =========
        // =================================================================================
        let mainLayer;
        document.addEventListener('DOMContentLoaded', function () {

            // === MODELO DE DATOS: Tu "fuente de verdad" ===
            // Estos arrays guardar치n la informaci칩n de tus nodos y conexiones
            // y se actualizar치n a medida que el usuario dibuja.
            const state = {
                nodos: [],
                conexiones: [],
            };

            // --- 1. CONFIGURACI칍N INICIAL ---
            const stage = new Konva.Stage({ container: 'konva-container', width: 750, height: 500 });
            mainLayer = new Konva.Layer();
            //const mainLayer = new Konva.Layer();
            stage.add(mainLayer);

            const colorPicker = document.getElementById('colorPicker');
            const brushSize = document.getElementById('brushSize');
            const clearCanvasBtn = document.getElementById('clearCanvasBtn');
            const saveCanvasBtn = document.getElementById('saveCanvasBtn');
            const componentControls = document.getElementById('componentGeneratorControls');
            const selectModeBtn = document.getElementById('selectModeBtn');
            const drawModeBtn = document.getElementById('drawModeBtn');

            let currentMode = 'select';
            let templateCableGroup = null;

            let selectedCanvasColor = '#000000'; // Color por defecto para las l칤neas

            const transformer = new Konva.Transformer({
                borderStroke: 'blue', borderDash: [6, 2], rotateEnabled: true, anchorSize: 8, name: 'tool_transformer'
            });
            mainLayer.add(transformer);

            const snapIndicator = new Konva.Circle({
                radius: 7, stroke: 'red', strokeWidth: 2, visible: false, name: 'tool_snap_indicator'
            });
            mainLayer.add(snapIndicator);

            // --- 2. GESTI칍N DE MODOS DE TRABAJO ---
            function setMode(newMode) {
                currentMode = newMode;
                if (newMode === 'select') {
                    selectModeBtn.classList.add('btn-primary');
                    selectModeBtn.classList.remove('btn-outline-secondary');
                    drawModeBtn.classList.add('btn-outline-secondary');
                    drawModeBtn.classList.remove('btn-primary');
                    stage.container().style.cursor = 'default';
                    abortLineDrawing();
                } else { // 'draw'
                    drawModeBtn.classList.add('btn-primary');
                    drawModeBtn.classList.remove('btn-outline-secondary');
                    selectModeBtn.classList.add('btn-outline-secondary');
                    selectModeBtn.classList.remove('btn-primary');
                    stage.container().style.cursor = 'crosshair';
                    transformer.nodes([]);
                }
            }

            //createCanvasColorPalette

            function createCanvasColorPalette() {
                const toolbar = document.getElementById('toolbar');

                // Crear contenedor para la paleta de colores
                const colorSection = document.createElement('div');
                colorSection.className = 'me-3 border-end pe-3';
                colorSection.innerHTML = '<span class="me-2 small">COLOR L칈NEA:</span>';

                // Simulaci칩n de los colores que podr칤as tener
                const availableColorsComplete = [
                    { name: 'Negro', Color: '#000000' },
                    { name: 'Rojo', Color: '#FF0000' },
                    { name: 'Azul', Color: '#0000FF' },
                    { name: 'Verde', Color: '#008000' }
                ];

                // Agregar botones de color usando los mismos colores del mapa
                availableColorsComplete.forEach((colorObject, index) => {
                    const colorBtn = document.createElement('button');
                    colorBtn.className = 'btn btn-sm me-1 canvas-color-btn';
                    colorBtn.style.backgroundColor = colorObject.Color;
                    colorBtn.style.width = '25px';
                    colorBtn.style.height = '25px';
                    colorBtn.style.border = '2px solid #ccc';
                    colorBtn.style.borderRadius = '4px';
                    colorBtn.title = `${colorObject.name} - ${colorObject.Color}`;
                    colorBtn.dataset.color = colorObject.Color;

                    // Marcar el primer color como activo por defecto
                    if (index === 0) {
                        colorBtn.classList.add('active-canvas-color');
                        colorBtn.style.border = '2px solid #007bff';
                        selectedCanvasColor = colorObject.Color;
                    }

                    colorBtn.addEventListener('click', () => {
                        // Desactivar todos los botones
                        document.querySelectorAll('.canvas-color-btn').forEach(btn => {
                            btn.classList.remove('active-canvas-color');
                            btn.style.border = '2px solid #ccc';
                        });

                        // Activar el bot칩n seleccionado
                        colorBtn.classList.add('active-canvas-color');
                        colorBtn.style.border = '2px solid #007bff';
                        selectedCanvasColor = colorObject.Color;

                        // Tambi칠n actualizar el color picker tradicional para consistencia
                        colorPicker.value = colorObject.Color;

                        console.log(`游꿛 Color seleccionado para l칤neas: ${colorObject.Color}`);
                    });

                    colorSection.appendChild(colorBtn);
                });

                // Insertar la secci칩n de colores despu칠s de la secci칩n de modos
                const modeSection = toolbar.querySelector('.border-end');
                modeSection.parentNode.insertBefore(colorSection, modeSection.nextSibling);
            }

            if (document.getElementById('toolbar')) {
                createCanvasColorPalette();
            }


            selectModeBtn.addEventListener('click', () => setMode('select'));
            drawModeBtn.addEventListener('click', () => setMode('draw'));

            // --- 3. GESTI칍N DE EVENTOS DE RAT칍N (CON L칍GICA ORTOGONAL) ---
            let isDrawingLine = false, lineStartPoint = null, previewLine = null;
            let startElement = null, endElement = null; // Para trackear las conexiones

            stage.on('click tap', (e) => {
                if (currentMode === 'select') {
                    handleSelection(e);
                } else {
                    handleLineDrawing(e);
                }
            });

            function handleSelection(e) {
                if (e.target === stage) {
                    transformer.nodes([]);
                    return;
                }
                const group = e.target.getParent();
                if (group && (group.hasName('cable') || group.hasName('splitter'))) {
                    transformer.nodes([group]);
                } else {
                    if (e.target.name() === 'connector') {
                        transformer.nodes([e.target]);
                    } else {
                        transformer.nodes([]);
                    }
                }
            }

            function calculateOrthogonalPoints(startPos, endPos) {
                const midX = startPos.x + (endPos.x - startPos.x) / 2;
                return [startPos.x, startPos.y, midX, startPos.y, midX, endPos.y, endPos.x, endPos.y];
            }

            function findElementAtPosition(pos) {
                let foundElement = null;
                let foundPoint = null;

                mainLayer.find('.cable, .splitter').forEach(group => {
                    (group.attrs.connectionPoints || []).forEach((point, index) => {
                        const transform = group.getAbsoluteTransform();
                        const worldPoint = transform.point(point);
                        const distance = Math.sqrt(Math.pow(worldPoint.x - pos.x, 2) + Math.pow(worldPoint.y - pos.y, 2));
                        if (distance < 15) {
                            foundElement = group;
                            foundPoint = { point: point, index: index, worldPos: worldPoint };
                        }
                    });
                });

                return foundElement ? { element: foundElement, connectionPoint: foundPoint } : null;
            }

            function handleLineDrawing(e) {
                let pos = stage.getPointerPosition();
                let snappedPos = getSnapPoint(pos) || pos;

                if (!isDrawingLine) {
                    isDrawingLine = true;
                    lineStartPoint = snappedPos;
                    startElement = findElementAtPosition(pos);

                    previewLine = new Konva.Line({
                        points: calculateOrthogonalPoints(snappedPos, snappedPos),
                        stroke: selectedCanvasColor,
                        strokeWidth: parseInt(brushSize.value),
                        dash: [8, 4],
                        name: 'connector_preview'
                    });
                    mainLayer.add(previewLine);
                } else {
                    endElement = findElementAtPosition(pos);

                    const finalLine = new Konva.Line({
                        points: calculateOrthogonalPoints(lineStartPoint, snappedPos),
                        stroke: selectedCanvasColor,
                        strokeWidth: parseInt(brushSize.value),
                        name: 'connector',
                        hitStrokeWidth: 20
                    });

                    finalLine.attrs.startConnection = startElement;
                    finalLine.attrs.endConnection = endElement;

                    mainLayer.add(finalLine);
                    console.log('游댋 L칤nea creada con conexiones:', { start: startElement, end: endElement });

                    abortLineDrawing();
                }
            }

            function calculateAdaptiveLine(startPos, endPos) {
                const dx = endPos.x - startPos.x;
                const dy = endPos.y - startPos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 80) {
                    return [startPos.x, startPos.y, endPos.x, endPos.y];
                }

                const controlDistance = Math.min(distance * 0.4, 100);

                if (Math.abs(dx) > Math.abs(dy)) {
                    const midX1 = startPos.x + (dx > 0 ? controlDistance : -controlDistance);
                    const midX2 = endPos.x - (dx > 0 ? controlDistance : -controlDistance);
                    return [startPos.x, startPos.y, midX1, startPos.y, midX2, endPos.y, endPos.x, endPos.y];
                } else {
                    const midY1 = startPos.y + (dy > 0 ? controlDistance : -controlDistance);
                    const midY2 = endPos.y - (dy > 0 ? controlDistance : -controlDistance);
                    return [startPos.x, startPos.y, startPos.x, midY1, endPos.x, midY2, endPos.x, endPos.y];
                }
            }

            function updateConnectedLines(movedElement) {
                mainLayer.find('.connector').forEach(line => {
                    let startPos, endPos, needsUpdate = false;

                    if (line.attrs.startConnection && line.attrs.startConnection.element === movedElement) {
                        const transform = movedElement.getAbsoluteTransform();
                        startPos = transform.point(line.attrs.startConnection.connectionPoint.point);
                        needsUpdate = true;
                    } else if (line.attrs.startConnection) {
                        const transform = line.attrs.startConnection.element.getAbsoluteTransform();
                        startPos = transform.point(line.attrs.startConnection.connectionPoint.point);
                    }

                    if (line.attrs.endConnection && line.attrs.endConnection.element === movedElement) {
                        const transform = movedElement.getAbsoluteTransform();
                        endPos = transform.point(line.attrs.endConnection.connectionPoint.point);
                        needsUpdate = true;
                    } else if (line.attrs.endConnection) {
                        const transform = line.attrs.endConnection.element.getAbsoluteTransform();
                        endPos = transform.point(line.attrs.endConnection.connectionPoint.point);
                    }

                    if (needsUpdate && startPos && endPos) {
                        const distance = Math.sqrt(Math.pow(endPos.x - startPos.x, 2) + Math.pow(endPos.y - startPos.y, 2));
                        if (distance > 100) {
                            line.points(calculateAdaptiveLine(startPos, endPos));
                            line.tension(0.2);
                        } else {
                            line.points([startPos.x, startPos.y, endPos.x, endPos.y]);
                            line.tension(0);
                        }
                    }
                });
                mainLayer.draw();
            }

            function restoreOriginalShape() {
                mainLayer.find('.connector').forEach(line => {
                    if (line.attrs.startConnection && line.attrs.endConnection) {
                        const startTransform = line.attrs.startConnection.element.getAbsoluteTransform();
                        const endTransform = line.attrs.endConnection.element.getAbsoluteTransform();
                        const startPos = startTransform.point(line.attrs.startConnection.connectionPoint.point);
                        const endPos = endTransform.point(line.attrs.endConnection.connectionPoint.point);
                        line.points(calculateOrthogonalPoints(startPos, endPos));
                        line.tension(0);
                    }
                });
                mainLayer.draw();
            }

            function abortLineDrawing() {
                isDrawingLine = false;
                if (previewLine) previewLine.destroy();
                previewLine = null;
                startElement = null;
                endElement = null;
                snapIndicator.hide();
                mainLayer.draw();
            }

            stage.on('mousemove', () => {
                if (currentMode !== 'draw' || !isDrawingLine) return;
                let pos = stage.getPointerPosition();
                let endPos = getSnapPoint(pos) || pos;
                if (getSnapPoint(pos)) {
                    snapIndicator.position(endPos).show();
                } else {
                    snapIndicator.hide();
                }
                previewLine.points(calculateOrthogonalPoints(lineStartPoint, endPos));
                mainLayer.draw();
            });

            function getSnapPoint(pos) {
                let closestPoint = null;
                let minDistance = 15;
                mainLayer.find('.cable, .splitter').forEach(group => {
                    (group.attrs.connectionPoints || []).forEach(point => {
                        const transform = group.getAbsoluteTransform();
                        const worldPoint = transform.point(point);
                        const distance = Math.sqrt(Math.pow(worldPoint.x - pos.x, 2) + Math.pow(worldPoint.y - pos.y, 2));
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestPoint = worldPoint;
                        }
                    });
                });
                return closestPoint;
            }

            // --- 5. FUNCIONES DE CREACI칍N DE COMPONENTES ---
            componentControls.addEventListener('click', (e) => {
                const target = e.target;
                if (target.tagName !== 'BUTTON') return;
                if (target.dataset.strands) {
                    const newCable = createCableGroup(parseInt(target.dataset.strands));
                    newCable.position({ x: 100, y: 250 });
                    mainLayer.add(newCable);
                    templateCableGroup = newCable;
                } else if (target.dataset.splitterOut) {
                    const splitterGroup = createSplitterGroup(1, parseInt(target.dataset.splitterOut));
                    splitterGroup.position({ x: 750 - 150, y: 250 });
                    mainLayer.add(splitterGroup);
                }
                mainLayer.draw();
            });

            @* function createCableGroup(numStrands) {
                const group = new Konva.Group({ draggable: true, name: 'cable', connectionPoints: [] });
                const lineThickness = 3, verticalSpacing = 15, cableWidth = 30, diagonalSlope = -25;
                const totalHeight = (numStrands - 1) * verticalSpacing;
                const startY = -totalHeight / 2;
                let firstDiagonalY, lastDiagonalY;

                for (let i = 0; i < numStrands; i++) {
                    const currentY = startY + (i * verticalSpacing);
                    const endY = currentY + diagonalSlope;
                    if (i === 0) firstDiagonalY = currentY;
                    if (i === numStrands - 1) lastDiagonalY = currentY;
                    group.add(new Konva.Line({ points: [0, currentY, cableWidth, endY], stroke: 'black', strokeWidth: lineThickness, lineCap: 'round', listening: false }));
                    group.attrs.connectionPoints.push({ x: cableWidth, y: endY });
                }

                group.add(new Konva.Line({ points: [0, firstDiagonalY, 0, lastDiagonalY], stroke: 'black', strokeWidth: lineThickness, lineCap: 'round', listening: false }));
                const hitbox = new Konva.Rect({ ...group.getClientRect({ relativeTo: group }), fill: 'transparent' });
                group.add(hitbox);
                hitbox.moveToBottom();

                group.on('dragmove', () => updateConnectedLines(group));
                group.on('transform', () => updateConnectedLines(group));
                group.on('dragend', () => restoreOriginalShape());

                return group;
            } *@


                function createCableGroup(numStrands) {
                    const group = new Konva.Group({ draggable: true, name: 'cable', connectionPoints: [] });
                    const lineThickness = 3, verticalSpacing = 15, cableWidth = 30, diagonalSlope = -25;
                    const totalHeight = (numStrands - 1) * verticalSpacing;
                    const startY = -totalHeight / 2;
                    let firstDiagonalY, lastDiagonalY;



                    // --- 춰AQU칈 EST츼 LA L칍GICA DE COLOR! ---
                    // 1. Seleccionamos la paleta de colores correcta.
                    // Si existe una paleta para el n칰mero exacto de hilos (como para 5), la usamos.
                    // Si no, usamos la paleta por defecto (la de 12 colores).
                    const colorsToUse = CABLE_COLOR_PALETTES[numStrands] || CABLE_COLOR_PALETTES.default;

                    // Guardamos los colores en un atributo personalizado para poder leerlos f치cilmente al guardar.
                    group.attrs.strandColors = [];

                    for (let i = 0; i < numStrands; i++) {
                        const currentY = startY + (i * verticalSpacing);
                        const endY = currentY + diagonalSlope;

                        // 2. Obtenemos el color para este hilo espec칤fico.
                        // El operador '%' (m칩dulo) hace que si hay m치s de 12 hilos, los colores se repitan c칤clicamente.
                        const strandColor = colorsToUse[i % colorsToUse.length];

                        // 춰IMPORTANTE! Guardamos el color que realmente se us칩 en nuestro atributo personalizado.
                        group.attrs.strandColors.push(strandColor);

                        if (i === 0) firstDiagonalY = currentY;
                        if (i === numStrands - 1) lastDiagonalY = currentY;

                        // 3. 춰MEJORA IMPORTANTE!
                        // El color blanco no se ve en el lienzo. Para solucionarlo, si el color es blanco,
                        // dibujamos primero un borde negro para que siempre sea visible.
                        if (strandColor === '#ffffff') {
                            // Dibujamos una l칤nea negra un poco m치s gruesa primero, que actuar치 como borde.
                            group.add(new Konva.Line({
                                points: [0, currentY, cableWidth, endY],
                                stroke: 'black',
                                strokeWidth: lineThickness, // Grosor total del borde
                                lineCap: 'round',
                                listening: false
                            }));
                            // Luego dibujamos la l칤nea blanca encima, un poco m치s fina.
                            group.add(new Konva.Line({
                                points: [0, currentY, cableWidth, endY],
                                stroke: strandColor,
                                strokeWidth: lineThickness - 1.5, // Grosor de la l칤nea interior blanca
                                lineCap: 'round',
                                listening: false
                            }));
                        } else {
                            // Para todos los dem치s colores, dibujamos una sola l칤nea de forma normal.
                            group.add(new Konva.Line({
                                points: [0, currentY, cableWidth, endY],
                                stroke: strandColor, // Usamos el color obtenido en lugar de 'black'
                                strokeWidth: lineThickness,
                                lineCap: 'round',
                                listening: false
                            }));
                        }

                        // El punto de conexi칩n se a침ade al final, sin cambios.
                        group.attrs.connectionPoints.push({ x: cableWidth, y: endY });
                    }

                    group.add(new Konva.Line({ points: [0, firstDiagonalY, 0, lastDiagonalY], stroke: 'black', strokeWidth: lineThickness, lineCap: 'round', listening: false }));
                    const hitbox = new Konva.Rect({ ...group.getClientRect({ relativeTo: group }), fill: 'transparent' });
                    group.add(hitbox);
                    hitbox.moveToBottom();

                    group.on('dragmove', () => updateConnectedLines(group));
                    group.on('transform', () => updateConnectedLines(group));
                    group.on('dragend', () => restoreOriginalShape());

                    return group;
                }


            function createSplitterGroup(numInputs, numOutputs) {
                const group = new Konva.Group({ draggable: true, name: 'splitter', connectionPoints: [] });
                const spacing = 20, width = 60, height = (numOutputs - 1) * spacing;
                group.attrs.connectionPoints.push({ x: 0, y: 0 });

                const hitbox = new Konva.Rect({ x: 0, y: -height / 2, width: width, height: height, fill: 'transparent' });
                group.add(hitbox);
                group.add(new Konva.Line({ points: [0, 0, width, -height / 2, width, height / 2], closed: true, fill: 'white', stroke: 'black', strokeWidth: 2, listening: false }));
                group.add(new Konva.Circle({ x: 0, y: 0, radius: 5, fill: 'black', listening: false }));

                for (let i = 0; i < numOutputs; i++) {
                    const y = -height / 2 + i * spacing;
                    group.attrs.connectionPoints.push({ x: width, y: y });
                    group.add(new Konva.Circle({ x: width, y: y, radius: 5, fill: 'black', listening: false }));
                }

                group.on('dragmove', () => updateConnectedLines(group));
                group.on('transform', () => updateConnectedLines(group));
                group.on('dragend', () => restoreOriginalShape());


                return group;
            }

            // =========================================================================
            // === NUEVA FUNCI칍N A칌ADIDA: RECOPILAR DATOS PARA ENVIAR ==================
            // =========================================================================
            /**
             * Esta funci칩n lee todos los elementos del lienzo y los prepara en un formato JSON
             * que tu controlador C# puede entender. No modifica el dibujo, solo lo lee.
             */
            function recopilarDatosDelDibujo() {
                const nodos = [];
                const conexiones = [];

                // ESTA ES LA VERSI칍N CORRECTA
                const asignarIdTemporal = (elemento) => {
                    if (!elemento.attrs.clienteId) {
                        // Creamos un ID 칰nico usando la fecha actual y un n칰mero aleatorio.
                        // Esto es un m칠todo est치ndar y muy seguro para este prop칩sito.
                        const idUnico = Date.now().toString(36) + Math.random().toString(36).substring(2);
                        elemento.attrs.clienteId = 'cliente_' + idUnico;
                    }
                    return elemento.attrs.clienteId;
                };

                // 1. Recorrer los Nodos (cables y splitters)
                mainLayer.find('.cable, .splitter').forEach(grupo => {

                    let size = 0;
                    let strandColorsJson = null;

                    if (grupo.name() === 'cable') {
                        size = grupo.attrs.connectionPoints.length;
                        // --- 춰AQU칈 LEEMOS LOS COLORES DEL ATRIBUTO PERSONALIZADO! ---
                        if (grupo.attrs.strandColors) {
                            strandColorsJson = JSON.stringify(grupo.attrs.strandColors);
                        }
                    } else if (grupo.name() === 'splitter') {
                        // Un splitter tiene un punto de entrada, as칤 que el n칰mero de salidas es el total de puntos - 1
                        size = grupo.attrs.connectionPoints.length - 1;
                    }
                    nodos.push({
                        ClienteId: asignarIdTemporal(grupo),
                        Type: grupo.name(),
                        CoordinateX: grupo.x(),
                        CoordinateY: grupo.y(),
                        Rotation: grupo.rotation(),
                        //a침adimos el tama침o calculado
                        Size: size,
                        TypeSplitter: grupo.name() === 'splitter' ? `1x${size}` : null,

                        // --- 춰Y AQU칈 LOS A칌ADIMOS AL OBJETO QUE SE ENVIAR츼! ---
                        StrandColorsJson: strandColorsJson
                    });
                });

                // 2. Recorrer las Conexiones (l칤neas)
                mainLayer.find('.connector').forEach(linea => {
                    if (linea.attrs.startConnection && linea.attrs.endConnection) {
                        conexiones.push({
                            Color: linea.stroke(),
                            Thickness: linea.strokeWidth(),
                            OrigenNodoClienteId: asignarIdTemporal(linea.attrs.startConnection.element),
                            DestinationNodoClienteId: asignarIdTemporal(linea.attrs.endConnection.element),

                            // --- 춰NUEVAS L칈NEAS! Guardamos el 칤ndice del punto de conexi칩n ---
                            OrigenPuntoIndex: linea.attrs.startConnection.connectionPoint.index,
                            DestinoPuntoIndex: linea.attrs.endConnection.connectionPoint.index,


                            JsonIntermediatePoints: JSON.stringify(linea.points())
                        });
                    }
                });

                return { Nodos: nodos, Connections: conexiones };
            }


            // --- 6. L칍GICA DE TECLAS Y BOTONES ---
            clearCanvasBtn.addEventListener('click', () => {
                const children = mainLayer.getChildren();


                for (let i = children.length - 1; i >= 0; i--) {
                    const child = children[i];
                    if (child.name() !== 'tool_transformer' && child.name() !== 'tool_snap_indicator') {
                        child.destroy();
                    }
                }
                transformer.nodes([]);
                templateCableGroup = null;
                mainLayer.draw();
            });

            // =========================================================================
            // === L칍GICA DEL BOT칍N GUARDAR REEMPLAZADA ================================
            // =========================================================================
            /**
             * En lugar de descargar una imagen, ahora recopila los datos y los env칤a
             * al controlador .NET Core mediante una llamada AJAX (fetch).
             */
            saveCanvasBtn.addEventListener('click', () => {
                transformer.nodes([]);
                snapIndicator.hide();
                mainLayer.draw();

                // 1. Llamar a la nueva funci칩n para obtener los datos del dibujo en formato JSON.
                const datosDelDibujo = recopilarDatosDelDibujo();

                if (datosDelDibujo.Nodos.length === 0 && datosDelDibujo.Connections.length === 0) {
                    alert("No hay nada en el lienzo para guardar.");
                    return;
                }

                if (!selectedMapElementData) {
                    alert("Error: No se ha seleccionado ning칰n elemento del mapa. Cierra esta ventana y haz clic en una caja en el mapa primero.");
                    return;
                }

                const payloadCompleto = {
                    // Datos que vienen del mapa y del proyecto
                    ElementProjectId: selectedMapElementData.databaseId,
                    ProjectId: currentProjectId,
                    Lat: selectedMapElementData.lat,
                    Lng: selectedMapElementData.lng,
                    ElementTypeId: selectedMapElementData.elementTypeId,

                    // Y aqu칤 anidamos los datos que vienen del lienzo de Konva
                    DrawingData: datosDelDibujo
                };

                console.log("Enviando estos datos al servidor:", JSON.stringify(payloadCompleto, null, 2));

                // Usamos jQuery AJAX para enviar los datos
                $.ajax({
                    url: '/Project/Save', // La direcci칩n del controlador
                    type: 'POST',             // M칠todo para crear nuevos datos
                    contentType: 'application/json; charset=utf-8', // Decirle al servidor que enviamos JSON
                    dataType: 'json',         // Decirle a jQuery que esperamos una respuesta JSON
                    data: JSON.stringify(payloadCompleto), // Los datos a enviar, convertidos a texto

                    success: function (data) {
                        // Esto se ejecuta si la llamada es exitosa
                        console.log('Respuesta exitosa:', data);
                        alert(`춰Dibujo guardado con 칠xito! ID del Dibujo: ${data.drawingId}`);
                    },
                    error: function (xhr, status, error) {
                        // Esto se ejecuta si hay un error
                        console.error('Error al guardar el dibujo:', { status: status, error: error, response: xhr.responseText });
                        alert(`Ocurri칩 un error al guardar: ${xhr.responseText || error}`);
                    }
                });
            });

            window.addEventListener('keydown', (e) => {
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    const selectedNodes = transformer.nodes();
                    if (selectedNodes.length > 0) {
                        transformer.nodes([]);
                        selectedNodes.forEach(node => {
                            node.destroy();
                        });
                        mainLayer.draw();
                    }
                }
                if (e.key.toLowerCase() === 'd' && templateCableGroup && currentMode === 'select') {
                    const newCable = templateCableGroup.clone();
                    const pos = templateCableGroup.position();
                    newCable.position({ x: pos.x + 20, y: pos.y + 20 });

                    newCable.on('dragmove', () => updateConnectedLines(newCable));
                    newCable.on('transform', () => updateConnectedLines(newCable));
                    newCable.on('dragend', () => restoreOriginalShape());

                    mainLayer.add(newCable);
                    mainLayer.draw();
                }
            });

            colorPicker.addEventListener('input', () => {
                const selectedNodes = transformer.nodes();
                if (selectedNodes.length > 0) {
                    selectedNodes.forEach(node => {
                        if (node.getClassName() === 'Line' && node.name() === 'connector') {
                            node.stroke(colorPicker.value);
                        }
                    });
                    mainLayer.draw();
                }
            });

            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('canvas-color-btn')) {
                    const newColor = e.target.dataset.color;
                    const selectedNodes = transformer.nodes();
                    if (selectedNodes.length > 0) {
                        selectedNodes.forEach(node => {
                            if (node.getClassName() === 'Line' && node.name() === 'connector') {
                                node.stroke(newColor);
                            }
                        });
                        mainLayer.draw();
                    }
                }
            });


            // Funci칩n para borrar todo el contenido del lienzo
            function limpiarLienzoKonva() {
                // Busca y destruye todos los nodos y conectores que no sean herramientas
                mainLayer.find('.cable, .splitter, .connector').forEach(shape => {
                    shape.destroy();
                });
                // Vuelve a dibujar el lienzo vac칤o
                mainLayer.draw();
                console.log("Lienzo de Konva limpiado.");
            }


            // Tu funci칩n, pero MEJORADA para manejar la rotaci칩n correctamente
            function dibujarDesdeDatos(drawingData) {
                if (!drawingData) return;
                if (!drawingData.nodos || !drawingData.connections) {
                    console.error("Los datos del dibujo no tienen el formato esperado.", drawingData);
                    return;
                }

                const nodosKonvaMap = new Map();

                // 1. DIBUJAR LOS NODOS (Tu c칩digo aqu칤 es perfecto)
                drawingData.nodos.forEach(nodoDto => {
                    let nuevoGrupo;
                    // El '|| 4' es un valor por defecto seguro por si cargas datos antiguos que no ten칤an tama침o.
                    const size = nodoDto.size || 4;

                    // --- 춰AQU칈 LEEMOS LOS COLORES RECIBIDOS DEL SERVIDOR! ---
                    let strandColors = null;
                    if (nodoDto.strandColorsJson) {
                        try {
                            strandColors = JSON.parse(nodoDto.strandColorsJson);
                        } catch (e) {
                            console.error("Error al parsear los colores del hilo:", e);
                        }
                    }

                    if (nodoDto.type === 'cable') {
                        // NOTA: Aqu칤 asumes que el cable es de 4 hilos. Si guardaras el n칰mero
                        // de hilos, podr칤as pasarlo aqu칤: createCableGroup(nodoDto.strands || 4)
                        nuevoGrupo = createCableGroup(size, strandColors);
                    } else if (nodoDto.type === 'splitter') {
                        nuevoGrupo = createSplitterGroup(1, size);
                    }

                    if (nuevoGrupo) {
                        nuevoGrupo.position({ x: nodoDto.coordinateX, y: nodoDto.coordinateY });
                        nuevoGrupo.rotation(nodoDto.rotation || 0); // Se aplica la rotaci칩n
                        nuevoGrupo.attrs.clienteId = nodoDto.clienteId;
                        mainLayer.add(nuevoGrupo);
                        nodosKonvaMap.set(nodoDto.clienteId, nuevoGrupo);
                    }
                });

                // 2. DIBUJAR LAS CONEXIONES (Aqu칤 aplicamos la mejora)
                drawingData.connections.forEach(connDto => {
                    const grupoOrigen = nodosKonvaMap.get(connDto.origenNodoClienteId);
                    const grupoDestino = nodosKonvaMap.get(connDto.destinationNodoClienteId);

                    if (grupoOrigen && grupoDestino) {
                        // --- INICIO DE LA MEJORA ---
                        // ANTES: Us치bamos los puntos guardados, que pod칤an no coincidir tras la rotaci칩n.
                        // const puntos = JSON.parse(connDto.jsonIntermediatePoints);

                        // AHORA: Recalculamos los puntos bas치ndonos en la posici칩n y rotaci칩n ACTUALES
                        // de los componentes. Esto es m치s seguro.

                        // Usamos el 칤ndice guardado. Si no existe (para datos antiguos), usamos 0 por seguridad.
                        const origenIndex = connDto.origenPuntoIndex || 0;
                        const destinoIndex = connDto.destinoPuntoIndex || 0;

                        // Advertencia: Para que esto sea 100% perfecto, necesitar칤amos saber a QU칄
                        // punto de conexi칩n espec칤fico (ej. el 3er hilo) se conect칩 la l칤nea.
                        // Como no guardamos ese dato, conectaremos al primer punto disponible como aproximaci칩n.
                        // 춰C칍DIGO CORRECTO!
                        const puntoOrigenRelativo = grupoOrigen.attrs.connectionPoints[origenIndex] || { x: 0, y: 0 };
                        const puntoDestinoRelativo = grupoDestino.attrs.connectionPoints[destinoIndex] || { x: 0, y: 0 };

                        const transformOrigen = grupoOrigen.getAbsoluteTransform();
                        const transformDestino = grupoDestino.getAbsoluteTransform();

                        const posAbsolutaOrigen = transformOrigen.point(puntoOrigenRelativo);
                        const posAbsolutaDestino = transformDestino.point(puntoDestinoRelativo);

                        const puntos = calculateOrthogonalPoints(posAbsolutaOrigen, posAbsolutaDestino);
                        // Usamos tu propia l칩gica para crear la l칤nea, asegurando consistencia.
                        //const puntos = calculateAdaptiveLine(posAbsolutaOrigen, posAbsolutaDestino);
                        // --- FIN DE LA MEJORA ---

                        const linea = new Konva.Line({
                            points: puntos, // Usamos los puntos reci칠n calculados
                            stroke: connDto.color,
                            strokeWidth: connDto.thickness,
                            name: 'connector',
                            hitStrokeWidth: 20
                        });

                        // =======================================================================
                        // === 춰Y AQU칈! Tambi칠n guardamos el 칤ndice para que el arrastre funcione. ===
                        // =======================================================================
                        linea.attrs.startConnection = { element: grupoOrigen, connectionPoint: { point: puntoOrigenRelativo, index: origenIndex } };
                        linea.attrs.endConnection = { element: grupoDestino, connectionPoint: { point: puntoDestinoRelativo, index: destinoIndex } };

                        mainLayer.add(linea);
                    }
                });

                mainLayer.draw();
                console.log("Dibujo cargado desde los datos del servidor (con recalculaci칩n de l칤neas).");
            }


            @* function dibujarDesdeDatos(drawingData) {
    console.log("=====================================");
    console.log("== INICIANDO DEPURACI칍N DE DIBUJADO ==");
    console.log("=====================================");

    // 1. Verificaciones de seguridad
    if (!drawingData) {
        console.error("ERROR FATAL: El objeto drawingData es nulo o indefinido.");
        return;
    }
    if (!drawingData.nodos || !drawingData.connections) {
        console.error("ERROR FATAL: Faltan las propiedades 'nodos' o 'connections'.", drawingData);
        return;
    }

    const nodosKonvaMap = new Map();

    // 2. DIBUJAR LOS COMPONENTES
    console.log(`---> Paso 1: Dibujando ${drawingData.nodos.length} nodos...`);
    drawingData.nodos.forEach((nodoDto, i) => {
        console.log(`   [Nodo ${i}] Datos recibidos:`, JSON.parse(JSON.stringify(nodoDto)));
        
        let nuevoGrupo;
        const size = nodoDto.size || 4; 

        if (nodoDto.type === 'cable') {
            nuevoGrupo = createCableGroup(size);
        } else if (nodoDto.type === 'splitter') {
            nuevoGrupo = createSplitterGroup(1, size);
        }

        if (nuevoGrupo) {
            nuevoGrupo.position({ x: nodoDto.coordinateX, y: nodoDto.coordinateY });
            nuevoGrupo.rotation(nodoDto.rotation || 0); 
            nuevoGrupo.attrs.clienteId = nodoDto.clienteId;
            mainLayer.add(nuevoGrupo);
            nodosKonvaMap.set(nodoDto.clienteId, nuevoGrupo);
            
            console.log(`   [Nodo ${i}] Creado y posicionado. ClienteId: ${nodoDto.clienteId}`);
            console.log(`   [Nodo ${i}] Puntos de conexi칩n disponibles:`, nuevoGrupo.attrs.connectionPoints);
        } else {
            console.error(`   [Nodo ${i}] No se pudo crear el grupo para el tipo: ${nodoDto.type}`);
        }
    });

    // 3. DIBUJAR LAS L칈NEAS
    console.log(`---> Paso 2: Dibujando ${drawingData.connections.length} conexiones...`);
    drawingData.connections.forEach((connDto, i) => {
        console.log(`   [Conexi칩n ${i}] Datos recibidos:`, JSON.parse(JSON.stringify(connDto)));

        const grupoOrigen = nodosKonvaMap.get(connDto.origenNodoClienteId);
        const grupoDestino = nodosKonvaMap.get(connDto.destinationNodoClienteId);

        if (grupoOrigen && grupoDestino) {
            console.log(`   [Conexi칩n ${i}] Nodos de origen y destino encontrados.`);

            const origenIndex = connDto.origenPuntoIndex;
            const destinoIndex = connDto.destinoPuntoIndex;
            console.log(`   [Conexi칩n ${i}] 칈ndice Origen: ${origenIndex}, 칈ndice Destino: ${destinoIndex}`);

            const puntosOrigen = grupoOrigen.attrs.connectionPoints;
            const puntosDestino = grupoDestino.attrs.connectionPoints;

            if (origenIndex >= 0 && origenIndex < puntosOrigen.length &&
                destinoIndex >= 0 && destinoIndex < puntosDestino.length) {
                
                const puntoOrigenRelativo = puntosOrigen[origenIndex];
                const puntoDestinoRelativo = puntosDestino[destinoIndex];
                console.log(`   [Conexi칩n ${i}] Punto Relativo Origen:`, puntoOrigenRelativo);
                console.log(`   [Conexi칩n ${i}] Punto Relativo Destino:`, puntoDestinoRelativo);

                const posAbsolutaOrigen = grupoOrigen.getAbsoluteTransform().point(puntoOrigenRelativo);
                const posAbsolutaDestino = grupoDestino.getAbsoluteTransform().point(puntoDestinoRelativo);
                console.log(`   [Conexi칩n ${i}] Posici칩n Absoluta Origen:`, posAbsolutaOrigen);
                console.log(`   [Conexi칩n ${i}] Posici칩n Absoluta Destino:`, posAbsolutaDestino);
                
                const puntosNuevos = calculateOrthogonalPoints(posAbsolutaOrigen, posAbsolutaDestino);
                console.log(`   [Conexi칩n ${i}] Puntos de l칤nea calculados:`, puntosNuevos);

                const linea = new Konva.Line({
                    points: puntosNuevos,
                    stroke: connDto.color,
                    strokeWidth: connDto.thickness,
                    name: 'connector',
                    hitStrokeWidth: 20
                });

                linea.attrs.startConnection = { element: grupoOrigen, connectionPoint: { point: puntoOrigenRelativo, index: origenIndex, worldPos: posAbsolutaOrigen } };
                linea.attrs.endConnection = { element: grupoDestino, connectionPoint: { point: puntoDestinoRelativo, index: destinoIndex, worldPos: posAbsolutaDestino } };
                mainLayer.add(linea);

            } else {
                console.error(`   [Conexi칩n ${i}] 춰ERROR! 칈ndices fuera de rango. 칈ndice Origen: ${origenIndex} (max: ${puntosOrigen.length-1}), 칈ndice Destino: ${destinoIndex} (max: ${puntosDestino.length-1})`);
            }
        } else {
            console.error(`   [Conexi칩n ${i}] 춰ERROR! No se encontr칩 el nodo de origen o destino. Origen: ${connDto.origenNodoClienteId}, Destino: ${connDto.destinationNodoClienteId}`);
        }
    });

    // 4. Renderizar
    mainLayer.draw();
    console.log("=====================================");
    console.log("== FIN DE DEPURACI칍N DE DIBUJADO ====");
    console.log("=====================================");
} *@


                window.dibujarDesdeDatosGlobal = dibujarDesdeDatos;
            window.limpiarLienzoKonvaGlobal = limpiarLienzoKonva;

        });




        @* // Funci칩n para borrar todo el contenido del lienzo
        function limpiarLienzoKonva() {
            // Busca y destruye todos los nodos y conectores que no sean herramientas
            mainLayer.find('.cable, .splitter, .connector').forEach(shape => {
                shape.destroy();
            });
            // Vuelve a dibujar el lienzo vac칤o
            mainLayer.draw();
            console.log("Lienzo de Konva limpiado.");
        } *@





    </script>

    @* Carga la API de Google Maps. 춰Aseg칰rate de que 'libraries=drawing' est칠 presente! *
   Reemplaza 'AIzaSyDp_qGGShO7CvdR5zFiH7KT4Mk3eGZO6VY' con tu CLAVE DE API real. *@
    <script async defer
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDp_qGGShO7CvdR5zFiH7KT4Mk3eGZO6VY&callback=initMap&v=weekly&solution_channel=GMP_CCS_simplepolygon_v2&libraries=drawing">
        </script>
}