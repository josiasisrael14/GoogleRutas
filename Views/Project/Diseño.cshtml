@model GoogleRuta.ViewModels.Dise√±oViewModel
@using System.Text.Json

@{
    ViewData["Title"] = "Dise√±ar Proyecto";
    Layout = "~/Views/Shared/_Layout.cshtml";

    //var initialLat = ViewData["InitialLat"] as double?;
    //var initialLng = ViewData["InitialLng"] as double?;


    //var processedCoordsJson = TempData["ExistingSegments"] as string ?? "[]";
    var projectId = TempData["ProjectId"] as int?;
    var nameTemp = TempData["Name"] as string;
    // Leemos los segmentos que guardamos en el controlador
    //var existingSegmentsJson = TempData["ExistingSegments"] as string ?? "[]";

    //color desde el backend
    //tomo cada objeto de la lista , extraigo solo el codigo del color
    //creo un list de string osea un array de string para pasarlo a javascrip
    var colorList = (Model.ColorTraces != null && Model.ColorTraces.Any())
    ? Model.ColorTraces.Select(c => c.Color).ToList()
    : new List<string> { "#FF0000", "#00FF00", "#0000FF" };
}

<style>
    /* 1. Define nuestra clase personalizada para el modal-dialog */
    .modal-dialog.modal-fullscreen-bs4 {
        width: 100%;
        max-width: none;
        /* Anula el max-width de Bootstrap 4 */
        height: 100%;
        margin: 0;
    }

    /* 2. Asegura que el contenido del modal llene el dialog */
    .modal-dialog.modal-fullscreen-bs4 .modal-content {
        height: 100%;
        border-radius: 0;
        /* Opcional: quita los bordes redondeados en pantalla completa */
        border: none;
        display: flex;
        /* ¬°Clave! Usa Flexbox para distribuir el espacio */
        flex-direction: column;
    }

    /* 3. ¬°LA MAGIA! Fuerza al modal-body a estirarse */
    .modal-dialog.modal-fullscreen-bs4 .modal-body {
        flex-grow: 1;
        /* Permite que el cuerpo crezca y ocupe el espacio sobrante */
        overflow-y: auto;
        /* A√±ade scroll si el contenido se desborda */
        display: flex;
        flex-direction: column;
    }

    /* 4. Y que el contenedor de Konva llene el modal-body */
    .modal-dialog.modal-fullscreen-bs4 #konva-container {
        flex-grow: 1;
        /* Ocupa todo el espacio disponible en el body */
    }

    #imageUploadInput {
            display: none;
        }
     
    
</style>

@* Este es el contenido de tu vista que se renderizar√° dentro de _Layout.cshtml *@

<div class="container-fluid" style="height: calc(100vh - 100px);"> @* Ajusta la altura del contenedor principal de tu vista *@
    <h2 class="mt-3">Dashboard</h2>

    <div id="map" style="height: 100%; width: 100%;"></div>
    <button id="saveCoordsBtn" class="btn btn-primary mt-3">Guardar</button>

</div>

<div class="modal fade" id="elementModal" tabindex="-1" aria-labelledby="elementModalLabel" aria-hidden="true">
    <!-- 1. Modal extra grande con la clase "modal-xl" -->
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="elementModalLabel">Lienzo de Dise√±o Profesional</h5>

                <!-- Controles de dibujo se mantienen en la cabecera -->
                <div class="ms-auto d-flex align-items-center">
                    <label for="colorPicker" class="form-label mb-0 me-2 small">Color:</label>
                    <input type="color" class="form-control form-control-sm me-3" id="colorPicker" value="#000000"
                        style="width: 50px;">

                    <label for="brushSize" class="form-label mb-0 me-2 small">Grosor:</label>
                    <input type="range" class="form-range me-3" id="brushSize" min="1" max="10" value="2"
                        style="width: 100px;">

                    <button id="clearCanvasBtn" class="btn btn-sm btn-outline-danger">Limpiar Todo</button>

                    <label for="imageUploadInput" class="btn btn-sm btn-outline-success ms-3">
                            <i class="fas fa-upload me-2"></i>Subir Imagen
                    </label>
                        <!-- ‚úÖ INPUT DE ARCHIVO OCULTO CON CSS -->
                    <input type="file" id="imageUploadInput" accept="image/*">

                    <!-- ‚úÖ NUEVO BOT√ìN PARA VER LA IMAGEN GUARDADA -->
                    <button type="button" id="viewSavedImageBtn" class="btn btn-sm btn-outline-info ms-2" title="Ver imagen guardada">
                       <i class="fas fa-eye"></i> <!-- √çcono de "ojo" para ver -->
                    </button>
                   

                    <!-- ‚úÖ Bot√≥n maximizar mejorado -->
                    <button type="button" class="btn btn-sm btn-outline-secondary me-2" id="toggleFullscreenBtn"
                        title="Maximizar pantalla completa">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                            class="bi bi-arrows-fullscreen" viewBox="0 0 16 16">
                            <path fill-rule="evenodd"
                                d="M5.828 10.172a.5.5 0 0 0-.707 0L2 13.293V11.5a.5.5 0 0 0-1 0v3a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 0-1H2.707l3.121-3.121a.5.5 0 0 0 0-.707zM10.172 5.828a.5.5 0 0 0 .707 0L14 2.707V4.5a.5.5 0 0 0 1 0v-3a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0 0 1h1.793L10.172 5.121a.5.5 0 0 0 0 .707z" />
                        </svg>
                    </button>


                </div>

                <!-- 4. Bot√≥n de cierre est√°ndar en la cabecera -->
                <button type="button" class="btn-close ms-3" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>

            <!-- 3. Cuerpo del modal con fondo gris claro para resaltar el lienzo -->
            <div class="modal-body p-2" style="background-color: #f8f9fa; text-align: center;">

                <!-- Barra de herramientas (sin cambios) -->
                <div id="toolbar"
                    class="mb-2 p-2 rounded d-flex justify-content-center align-items-center bg-light border-bottom">
                    <div class="me-3 border-end pe-3">
                        <span class="me-2 small">MODO:</span>
                        <button id="selectModeBtn" class="btn btn-sm btn-primary"
                            title="Modo Selecci√≥n (Mover, Seleccionar, Borrar)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                                class="bi bi-cursor-fill" viewBox="0 0 16 16">
                                <path
                                    d="M14.082 2.182a.5.5 0 0 1 .103.557L8.528 15.467a.5.5 0 0 1-.917-.007L5.57 10.694.803 8.652a.5.5 0 0 1-.006-.916l12.728-5.657a.5.5 0 0 1 .556.103z" />
                            </svg>
                        </button>
                        <button id="drawModeBtn" class="btn btn-sm btn-outline-secondary"
                            title="Modo Conector (Dibujar L√≠neas)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                                class="bi bi-slash-lg" viewBox="0 0 16 16">
                                <path fill-rule="evenodd"
                                    d="M13.854 2.146a.5.5 0 0 1 0 .708l-11 11a.5.5 0 0 1-.708-.708l11-11a.5.5 0 0 1 .708 0z" />
                            </svg>
                        </button>
                    </div>
                    <div id="componentGeneratorControls" class="d-flex align-items-center">
                        <div class="me-3"><span class="me-2 small">CABLE:</span>
                            <button class="btn btn-sm btn-outline-primary" data-strands="4">1x4</button>
                            <button class="btn btn-sm btn-outline-primary" data-strands="5">1x5</button>
                            <button class="btn btn-sm btn-outline-primary" data-strands="6">1x6</button>
                            <button class="btn btn-sm btn-outline-primary" data-strands="8">1x8</button>
                            <button class="btn btn-sm btn-outline-primary" data-strands="12">1x12</button>
                            <button class="btn btn-sm btn-outline-danger" data-multi-cable="12x4">1x48</button>
                            <button class="btn btn-sm btn-outline-danger" data-multi-cable="12x8">1x96</button>

                            <button id="autoConnectBtn" class="btn btn-sm btn-info ms-3" title="Busca los dos √∫ltimos cables individuales (uno izquierdo y otro derecho) y conecta sus hilos por color.">
                            <i class="fas fa-magic"></i> Conectar √öltimos 2
                            </button>
                            
                        </div>
                        <div><span class="me-2 small">SPLITTER:</span>
                            <button class="btn btn-sm btn-outline-success" data-splitter-out="4">1x4</button>
                            <button class="btn btn-sm btn-outline-success" data-splitter-out="8">1x8</button>
                            <button class="btn btn-sm btn-outline-success" data-splitter-out="16">1x16</button>
                        </div>

                        <button id="export-button">Exportar Diagrama (PNG)</button>
                    </div>
                </div>

                <!-- 2. Contenedor del lienzo con fondo de cuadr√≠cula  inline-block; -->
                <div id="konva-container" style="
                    border: 1px solid #ccc;
                    inline-block;
                    background-color: #ffffff;
                    background-image:
                        linear-gradient(#e0e0e0 1px, transparent 1px),
                        linear-gradient(90deg, #e0e0e0 1px, transparent 1px);
                    background-size: 20px 20px;">
                </div>

            </div>
            <div class="modal-footer">
                <!-- Se puede simplificar, ya que el cierre principal est√° en la cabecera -->
                <button type="button" id="saveCanvasBtn" class="btn btn-primary">Guardar Dise√±o</button>
            </div>
        </div>
    </div>
</div>


@* <script src="https://unpkg.com/konva@9.3.0/konva.min.js"></script> *@
<script src="https://cdn.jsdelivr.net/npm/konva@9/konva.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/konva-svg-export@1.0.0/konva-svg-export.min.js"></script>


@section Scripts {

    <style>
        /* Estilos para el bot√≥n activo. Da feedback visual al usuario. */
        .custom-element-button.active {
            background-color: #e0e0e0 !important;
            border: 1px solid #3385ff !important;
        }

        /* NUEVOS ESTILOS PARA LOS BOTONES DE COLORES */
        .custom-color-button.active {
            border: 2px solid #3385ff !important;
            box-shadow: 0 0 3px rgba(51, 133, 255, 0.5) !important;
        }

        .custom-color-button:hover {
            transform: scale(1.1);
            transition: transform 0.1s ease;
        }

        .canvas-color-btn.active-canvas-color {
            border: 2px solid #007bff !important;
            box-shadow: 0 0 3px rgba(0, 123, 255, 0.5) !important;
        }

        .canvas-color-btn:hover {
            transform: scale(1.05);
            transition: transform 0.1s ease;
        }
    </style>

    <script>

        // ‚úÖ NUEVO: Funciones para controlar el tama√±o del modal
        function maximizarModal() {
            const modalDialog = document.querySelector('#elementModal .modal-dialog');
            // Nos aseguramos de que est√© en modo maximizado
            if (!modalDialog.classList.contains('modal-fullscreen-bs4')) {
                modalDialog.classList.add('modal-fullscreen-bs4');
                modalDialog.classList.remove('modal-xl');
                // Esperamos la animaci√≥n CSS antes de redimensionar el lienzo
                setTimeout(() => {
                    if (window.resizeCanvasToContainer) { // Verificamos si la funci√≥n existe
                        window.resizeCanvasToContainer();
                    }
                }, 250);
            }
        }

        function resetModalSize() {
            const modalDialog = document.querySelector('#elementModal .modal-dialog');
            // Nos aseguramos de que est√© en modo normal (xl)
            if (modalDialog.classList.contains('modal-fullscreen-bs4')) {
                modalDialog.classList.remove('modal-fullscreen-bs4');
                modalDialog.classList.add('modal-xl');
                // Esperamos la animaci√≥n CSS antes de redimensionar el lienzo
                setTimeout(() => {
                    if (window.resizeCanvasToContainer) {
                        window.resizeCanvasToContainer();
                    }
                }, 250);
            }
        }

        
        //variable para rastrear la polil√≠nea seleccionada
        let selectedPolyline = null;

        let isUpdateScheduled = false;

        var nameJs = '@(nameTemp ?? "")';
        console.log("ver name ", nameJs);

        // Pasas los segmentos de polil√≠nea
        @* const existingSegments = JSON.parse(@Html.Raw(existingSegmentsJson));
           console.log("Segmentos existentes cargados desde TempData:", existingSegments); *@

           const existingSegmentsJson = '@Html.Raw(TempData["ExistingSegments"] as string ?? "[]")';
           const existingSegments = JSON.parse(existingSegmentsJson);
           console.log("Segmentos existentes cargados desde TempData:", existingSegments);

           const currentProjectId = @(projectId.HasValue? projectId.Value.ToString() : "null");
           console.log("ID del proyecto disponible en JS:", currentProjectId);

          @{
                // Usamos LINQ para crear una nueva lista de objetos an√≥nimos.
                // Para cada elemento, copiamos sus propiedades y transformamos 'iconUrl'
                // usando Url.Content() para generar una ruta v√°lida para el navegador.
                var elementTypesForJs = Model.ElementTypes.Select(e => new
                {
                    id = e.Id,
                    name = e.Name,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
                    iconUrl = Url.Content(e.IconoUrl) // <-- ¬°Esta es la correcci√≥n!
                });
            }

          // Ahora serializamos la nueva lista con las URLs corregidas.                                                                                                                                                                                                                                   
         const elementTypes = @Html.Raw(Json.Serialize(elementTypesForJs));
         console.log("Tipos de Elementos (con URLs corregidas):", elementTypes);

        //traer la lista de colores desde el contrrolador
        const availableColors =@Html.Raw(JsonSerializer.Serialize(colorList));
        console.log("üé® Colores disponibles:", availableColors);

        const availableColorsComplete = @Html.Raw(JsonSerializer.Serialize(Model.ColorTraces ?? new List<ColorTraces>()));
        console.log("üé® Colores disponibles:", availableColorsComplete);

        // El problema: existingElements es un STRING, no un Array.
        // La Soluci√≥n: Convertimos (parseamos) el string a un Array de JavaScript real.
        // ======================================================================
        const existingElements = @Html.Raw(TempData["ExistingPlacedElements"] as string ?? "[]");
        console.log("ver elementos llegando a la vista dise√±o (YA PARSEADO):", existingElements);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                @*const existingElementsJson = '@Html.Raw(TempData["ExistingPlacedElements"] as string ?? "[]")';
        const existingElements = JSON.parse(existingElementsJson);
        console.log("ver elementos llegando a la vista dise√±o (YA PARSEADO):", existingElements); *@

        let currentPolygon = null;
        let currentPolyLine = null;
        let currentPolygonCoords = [];
        let currentPolylineCoords = [];

        let selectedColor = null;

        // Aqu√≠ guardaremos todos los elementos (postes, cajas, etc.) que el usuario coloque.
        let placedElements = [];
        //Variable para gestionar el listener del mapa ---
        let mapClickListener = null;
        // Agregamos una variable para guardar el tipo de elemento activo
        let activeElementType = null;
        //tomo los datos del elemento para enviarlo al controlador dibujo
        let selectedMapElementData = null;

        // NUEVA VARIABLE GLOBAL: Array para almacenar m√∫ltiples polil√≠neas independientes
        let polylineSegments = [];
        let allMapMarkers = []; // <-- NUEVA L√çNEA: Para guardar los objetos de marcador visuales
        let activeSegmentIndex = 0; // √çndice del segmento actualmente seleccionado

        function initMap() {
            console.log("Color inicial seleccionado:", selectedColor);
            let center;
            
            const mapCenterLat = parseFloat('@(Model.InitialLat.HasValue? Model.InitialLat.Value.ToString(System.Globalization.CultureInfo.InvariantCulture) : "-13.44255087")');
            const mapCenterLng = parseFloat('@(Model.InitialLng.HasValue? Model.InitialLng.Value.ToString(System.Globalization.CultureInfo.InvariantCulture) : "-76.1470107")');
            

        if (existingSegments && existingSegments.length > 0 && existingSegments[0].Coordinates.length > 0)
         {
            const firstCoord = existingSegments[0].Coordinates[0];
               // Comprueba si existe 'lat' (min√∫scula), si no, usa 'Lat' (may√∫scula)
             center = { 
                lat: parseFloat(firstCoord.lat || firstCoord.Lat), 
                lng: parseFloat(firstCoord.lng || firstCoord.Lng)
            };
         } 
          else 
          {
            center = { lat: mapCenterLat, lng: mapCenterLng };
         }

                         const map = new google.maps.Map(document.getElementById("map"),
                        {
                           zoom: 12,
                            center: center,
                            mapTypeId: "terrain",
                            mapTypeControl: true,
                             streetViewControl: true,
                            fullscreenControl: true,
                            gestureHandling: 'greedy' //para usar zoom solo con la rueda nomas

                        });

        if (existingSegments && existingSegments.length > 0) 
        {
            console.log(`Cargando ${existingSegments.length} segmentos desde TempData.`);

             existingSegments.forEach(segment =>
              {
                // Usa la misma l√≥gica de fallback para las coordenadas del path
                const path = segment.Coordinates.map(c => ({ 
                lat: parseFloat(c.lat || c.Lat), 
                lng: parseFloat(c.lng || c.Lng)
            }));

        // Crea una polil√≠nea para ESTE segmento
        const polyline = new google.maps.Polyline({
            path: path,
            map: map,
            strokeColor: segment.Color || '#0000FF', // Usa el color del segmento, o uno por defecto
            strokeOpacity: 0.8,
            strokeWeight: 3,
            clickable: true,
            editable: true,
            zIndex: 1,
            segmentId: segment.SegmentId // Almacena su ID
        });

        // A√±ade los listeners para que sea editable y seleccionable
        setPolylineListeners(polyline);
        
        // A√±√°delo a tu array global de segmentos
        polylineSegments.push(polyline);
        
        // Guarda las coordenadas en el propio objeto de la l√≠nea
        updatePolylineCoords(polyline);
    });

    console.log("Todos los segmentos de polil√≠nea han sido cargados y dibujados.");

    // MEJORA CLAVE: Seleccionar autom√°ticamente el primer segmento para una mejor experiencia de usuario.
    if (polylineSegments.length > 0) {
        selectPolylineSegment(polylineSegments[0]);
        console.log('Primer segmento de la lista auto-seleccionado.');
    }


}  else {
    new google.maps.Marker({
        position: center,
        map: map,
        title: "Ubicaci√≥n inicial"
    });
}
           


            //Dibujar los elementos(cajas,postes etc al cargar)
            if (existingElements.length > 0) {
                console.log(`Cargando ${existingElements.length} elementos existentes.`);

                existingElements.forEach(element => {
                    // Buscamos el tipo de elemento completo para obtener su URL de icono
                    const elementType = elementTypes.find(t => t.id === element.ElementTypeId);
                    if (elementType) {
                        const location = { lat: element.Lat, lng: element.Lng };
                        console.log("Encontrado tipo de elemento, dibujando marcador en:", location);
                        // Reutilizamos la funci√≥n que ya tienes para colocar marcadores
                        placeMarker(location, elementType, map, element);
                    }
                });

                // ‚≠ê AGREGAR ESTA L√çNEA DESPU√âS DE CARGAR TODOS LOS ELEMENTOS:
                 // Esperar un poco para que se carguen todos los marcadores y l√≠neas
                 setTimeout(() => {
                  reconnectExistingMarkersToPolylines();
                 }, 500);

            }


function setPolylineListeners(polyline) {
    google.maps.event.addListener(polyline.getPath(), 'set_at', () => {
        updatePolylineCoords(polyline);
        updateAttachedMarkers(); // ‚≠ê SOLO AGREGAR ESTA L√çNEA
    });
    
    google.maps.event.addListener(polyline.getPath(), 'insert_at', () => {
        updatePolylineCoords(polyline);
        updateAttachedMarkers(); // ‚≠ê SOLO AGREGAR ESTA L√çNEA
    });
    
    google.maps.event.addListener(polyline.getPath(), 'remove_at', () => {
        updatePolylineCoords(polyline);
        updateAttachedMarkers(); // ‚≠ê SOLO AGREGAR ESTA L√çNEA
    });

    // Tu c√≥digo existente (no cambiar)
    google.maps.event.addListener(polyline, 'rightclick', function (event) {
        if (event.vertex !== undefined && event.vertex !== null) {
            const path = polyline.getPath();
            path.removeAt(event.vertex);
        }
    });

    google.maps.event.addListener(polyline, 'click', function () {
        selectPolylineSegment(polyline);
    });
}


            function setPolygonListeners(polygon) {
                google.maps.event.addListener(polygon.getPath(), 'set_at', () => updatePolygonCoords(polygon));
                google.maps.event.addListener(polygon.getPath(), 'insert_at', () => updatePolygonCoords(polygon));
                google.maps.event.addListener(polygon.getPath(), 'remove_at', () => updatePolygonCoords(polygon));
            }

            const drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: google.maps.drawing.OverlayType.POLYLINE,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.POLYLINE,
                        google.maps.drawing.OverlayType.MARKER
                    ],
                },
                polygonOptions: {
                    fillColor: '#AA0000', fillOpacity: 0.3, strokeWeight: 2,
                    strokeColor: '#FF0000', clickable: true, editable: true, zIndex: 1,
                },
                polylineOptions: {
                    strokeColor: '#0000FF', strokeOpacity: 0.8, strokeWeight: 3,
                    clickable: true, editable: true, zIndex: 1,
                }
            });

            drawingManager.setMap(map);

            google.maps.event.addListener(drawingManager, 'overlaycomplete', function (event) {
    deactivateCustomButtons();
    
    if (event.type == google.maps.drawing.OverlayType.POLYLINE) {
        // NO COMBINAR - Crear un nuevo segmento independiente
        const newSegment = event.overlay;
        
        // Asignar ID √∫nico al segmento
        const segmentId = `segment_${Date.now()}`;
        newSegment.segmentId = segmentId;
        
        // Configurar el segmento
        newSegment.setOptions({
            strokeColor: selectedColor ? selectedColor.Color : '#0000FF',
            strokeOpacity: 0.8,
            strokeWeight: 3,
            clickable: true,
            editable: true,
            zIndex: 1
        });

        // Agregar listeners espec√≠ficos para este segmento
        setPolylineListeners(newSegment);

        //Capturamos las coordenadas iniciales justo al terminar de dibujar.
        updatePolylineCoords(newSegment);
        
        // Agregar al array de segmentos
        polylineSegments.push(newSegment);
        activeSegmentIndex = polylineSegments.length - 1;
        
        // Seleccionar autom√°ticamente el nuevo segmento
        selectPolylineSegment(newSegment);
        
        console.log(`Nuevo segmento creado: ${segmentId}. Total de segmentos: ${polylineSegments.length}`);
        
        drawingManager.setDrawingMode(null);
    } else if (event.type == google.maps.drawing.OverlayType.POLYGON) {
                    if (currentPolyLine) {
                        google.maps.event.clearInstanceListeners(currentPolyLine.getPath());
                        google.maps.event.clearInstanceListeners(currentPolyLine);
                        currentPolyLine.setMap(null);
                        currentPolyLine = null;
                        currentPolylineCoords = [];
                    }
                    if (currentPolygon) {
                        google.maps.event.clearInstanceListeners(currentPolygon.getPath());
                        google.maps.event.clearInstanceListeners(currentPolygon);
                        currentPolygon.setMap(null);
                    }
                    currentPolygon = event.overlay;
                    setPolygonListeners(currentPolygon);
                    updatePolygonCoords(currentPolygon);
                    drawingManager.setDrawingMode(null);

                }
    
    // La l√≥gica para pol√≠gonos se mantiene igual...
});

// NUEVA FUNCI√ìN: Seleccionar un segmento espec√≠fico
function selectPolylineSegment(segment) {
    // Resetear estilos de todos los segmentos
    polylineSegments.forEach(seg => {
        seg.setOptions({
            strokeWeight: 3,
            strokeOpacity: 0.8
        });
    });
    
    // Resaltar el segmento seleccionado
    segment.setOptions({
        strokeWeight: 5,
        strokeOpacity: 1.0
    });
    
    selectedPolyline = segment;
    activeSegmentIndex = polylineSegments.findIndex(seg => seg.segmentId === segment.segmentId);
    
    console.log(`Segmento seleccionado: ${segment.segmentId}`);
}


            function updatePolygonCoords(polygon) {
                const path = polygon.getPath();
                currentPolygonCoords = [];
                path.getArray().forEach(function (latLng) {
                    currentPolygonCoords.push({ lat: latLng.lat(), lng: latLng.lng() });
                });
                console.log("Coordenadas del pol√≠gono actualizadas:", currentPolygonCoords);
            }

            function updatePolylineCoords(polyline) {
    const path = polyline.getPath();
    const coords = [];
    path.getArray().forEach(function (latLng) {
        coords.push({ lat: latLng.lat(), lng: latLng.lng() });
    });
    
    // Guardar coordenadas espec√≠ficas para este segmento
    polyline.coordinates = coords;
    
    console.log(`Coordenadas actualizadas para segmento: ${polyline.segmentId}`, coords);
}

            //NUEVO C√ìDIGO: A√ëADIR CONTROLES PERSONALIZADOS PARA ELEMENTOS ---
            // Le pasamos el 'drawingManager' para poder controlarlo
            createCustomElementControls(map, drawingManager);
            createCustomColorControls(map, drawingManager);

        }


         function createCustomColorControls(map, drawingManager) {
    const colorToolbar = document.createElement('div');
    
    colorToolbar.style.margin = '8px';
    colorToolbar.style.display = 'flex';
    colorToolbar.style.gap = '2px';
    colorToolbar.style.backgroundColor = 'white';
    colorToolbar.style.padding = '3px';
    colorToolbar.style.borderRadius = '2px';
    colorToolbar.style.boxShadow = 'rgba(0, 0, 0, 0.3) 0px 1px 4px -1px';
    colorToolbar.id = 'customColorToolbar';

    availableColorsComplete.forEach((colorObject, index) => {
        const button = document.createElement('button');
        button.className = 'custom-color-button';

        button.style.backgroundColor = colorObject.Color;
        button.style.border = '2px solid #ccc';
        button.style.width = '24px';
        button.style.height = '24px';
        button.style.borderRadius = '4px';
        button.style.cursor = 'pointer';
        button.style.margin = '1px';
        button.title = `${colorObject.name} - ${colorObject.Color}`;

        // IMPORTANTE: Seleccionar el primer color por defecto al cargar
        if (index === 0) {
            button.classList.add('active');
            button.style.border = '2px solid #3385ff';
            button.style.boxShadow = '0 0 3px rgba(51, 133, 255, 0.5)';
            selectedColor = colorObject; // ESTABLECER COLOR POR DEFECTO
        }

        button.addEventListener('click', () => {
            // 1. Desactivar todos los botones
            deactivateColorButtons();

            // 2. Activar este bot√≥n
            button.classList.add('active');
            button.style.border = '2px solid #3385ff';
            button.style.boxShadow = '0 0 3px rgba(51, 133, 255, 0.5)';

            // 3. Establecer el color seleccionado (PARA NUEVAS L√çNEAS)
            selectedColor = colorObject;

            // 4. Si hay una l√≠nea existente seleccionada, cambiar su color
            if (selectedPolyline) {
                selectedPolyline.setOptions({ strokeColor: selectedColor.Color });
                console.log(`Color aplicado a segmento existente: ${selectedPolyline.segmentId}`);
            }

            console.log(`Color seleccionado para nuevas l√≠neas: ${selectedColor.Color}`);

            // 5. Configurar color para el drawingManager (l√≠neas futuras)
            drawingManager.setOptions({
                polylineOptions: {
                    strokeColor: selectedColor.Color,
                    strokeOpacity: 0.8,
                    strokeWeight: 3,
                    clickable: true,
                    editable: true,
                    zIndex: 1
                }
            });
        });

        colorToolbar.appendChild(button);
    });

    map.controls[google.maps.ControlPosition.TOP_RIGHT].push(colorToolbar);
}
        
        // Funci√≥n para desactivar todos los botones de color
        function deactivateColorButtons() {
            document.querySelectorAll('#customColorToolbar .custom-color-button').forEach(button => {
                button.classList.remove('active');
                button.style.border = '2px solid #ccc';
                button.style.boxShadow = 'none';
            });
        }

        // Funci√≥n mejorada para obtener el color seleccionado (ahora devuelve solo el string del color)
        function getSelectedColor() {
            // Si un objeto de color est√° seleccionado, devuelve su propiedad .Color.
            // Si no, devuelve el primer color del array de strings como predeterminado.
            return selectedColor ? selectedColor.Color : availableColors[0];
        }



        //FUNCI√ìN ACTUALIZADA: Crea los botones y gestiona el estado activo.

        function createCustomElementControls(map, drawingManager) {
            // 1. Crea un contenedor para nuestros botones.
            const toolbar = document.createElement('div');

            toolbar.style.margin = '8px'; // Espacio respecto a los controles de Google
            toolbar.style.display = 'flex';
            toolbar.style.gap = '2px';
            toolbar.style.backgroundColor = 'white';
            toolbar.style.padding = '3px';
            toolbar.style.borderRadius = '2px';
            toolbar.style.boxShadow = 'rgba(0, 0, 0, 0.3) 0px 1px 4px -1px';
            toolbar.id = 'customToolbar'; // Le damos un ID para encontrarlo despu√©s

            // 2. Itera sobre tus tipos de elementos para crear un bot√≥n para cada uno.
            elementTypes.forEach(elementType => {
                const button = document.createElement('button');
                button.className = 'custom-element-button'; // Clase para aplicar estilos

                button.style.backgroundColor = 'white';
                button.style.border = 'none';
                button.style.padding = '5px';
                button.style.cursor = 'pointer';
                button.title = elementType.name;
                button.innerHTML = `<img src="${elementType.iconUrl}" style="width:18px; height:18px;">`;

                button.addEventListener('click', () => {
                    // 1. Desactivamos cualquier herramienta de Google y otros botones personalizados
                    deactivateCustomButtons();
                    drawingManager.setDrawingMode(null);

                    // 2. Activamos ESTE bot√≥n
                    button.classList.add('active');
                    map.setOptions({ draggableCursor: 'crosshair' });

                    // 3. Establecemos el tipo de elemento activo
                    activeElementType = elementType;

                    // 4. Agregamos el listener de clic en el mapa para colocar elementos,
                    // pero esta vez es un addListener normal, no once.
                    // ¬°Esto nos permite colocar m√∫ltiples elementos!
                    if (mapClickListener) {
                        google.maps.event.removeListener(mapClickListener);
                    }
                    mapClickListener = google.maps.event.addListener(map, 'click', (event) => {
                        placeMarker(event.latLng, activeElementType, map);
                    });

                    console.log(`Modo de colocaci√≥n activado para: ${elementType.name}`);
                });

                toolbar.appendChild(button);
            });

            map.controls[google.maps.ControlPosition.TOP_CENTER].push(toolbar);
        }

        function deactivateCustomButtons() {
            document.querySelectorAll('#customToolbar .custom-element-button').forEach(b => {
                b.classList.remove('active');
            });
            if (mapClickListener) {
                google.maps.event.removeListener(mapClickListener);
                mapClickListener = null;
            }
            // Asumiendo que 'map' es accesible globalmente o pasado como par√°metro
            const map = document.getElementById('map').__gmap_instance__;
            if (map) map.setOptions({ draggableCursor: '' });
        }


//codigo usado 
@* function placeMarker(location, elementType, map, element) {
    let finalLocation = location;
    let snapped = false;

    console.log("Intentando colocar marcador. ¬øHay una polil√≠nea seleccionada?", selectedPolyline ? "S√≠" : "No");

    if (selectedPolyline && !element) {
        console.log("Iniciando l√≥gica de acoplamiento...");
        const path = selectedPolyline.getPath();
        const clickLatLng = location;
        const tolerance = 0.01;

        for (let i = 0; i < path.getLength() - 1; i++) {
            const segmentStart = path.getAt(i);
            const segmentEnd = path.getAt(i + 1);

            const isOnEdge = google.maps.geometry.poly.isLocationOnEdge(
                clickLatLng,
                new google.maps.Polyline({ path: [segmentStart, segmentEnd] }),
                tolerance
            );

            if (isOnEdge) {
                // CAMBIO CLAVE: Calcular el punto EXACTO sobre la l√≠nea
                finalLocation = getClosestPointOnLineSegment(clickLatLng, segmentStart, segmentEnd);
                console.log(`‚úÖ ¬°Acoplado al segmento ${i}! Punto calculado exactamente sobre la l√≠nea.`);
                snapped = true;
                break;
            }
        }

        if (!snapped) {
            console.log("‚ùå No se encontr√≥ ning√∫n segmento cercano para acoplar.");
        }
    }

    // Resto de tu c√≥digo igual...
    const latitude = typeof finalLocation.lat === 'function' ? finalLocation.lat() : finalLocation.lat;
    const longitude = typeof finalLocation.lng === 'function' ? finalLocation.lng() : finalLocation.lng;

    const elementData = {
        databaseId: element ? element.Id : null,
        DrawingId: element ? element.DrawingId : null,
        internalId: Date.now() + Math.random(),
        lat: latitude,
        lng: longitude,
        elementTypeId: elementType.id,
        attachedToPolyline: snapped ? selectedPolyline.segmentId : null // ‚≠ê NUEVO
    };

    const marker = new google.maps.Marker({
        position: { lat: latitude, lng: longitude },
        map: map,
        draggable: true, // ‚≠ê NUEVO: Hacer arrastrable
        icon: {
            url: elementType.iconUrl,
            scaledSize: new google.maps.Size(32, 32),
            origin: new google.maps.Point(0, 0),
            anchor: new google.maps.Point(16, 16)
        }
    });

    marker.internalId = elementData.internalId;
    marker.attachedToPolyline = elementData.attachedToPolyline; // ‚≠ê NUEVO

    // ‚≠ê NUEVO: Listener para cuando se arrastra el marcador
    google.maps.event.addListener(marker, 'dragend', function() {
        handleMarkerDrag(marker);
    });

    // ‚≠ê NUEVO: Detectar cuando empieza a arrastrar
    google.maps.event.addListener(marker, 'dragstart', function() {
        marker.isDragging = true;
    });

    // Evento de click derecho (eliminar) - IGUAL que antes
    google.maps.event.addListener(marker, 'rightclick', function () {
        // Misi√≥n 1: Quitar el marcador del mapa VISUALMENTE
        this.setMap(null);
        // Misi√≥n 2: Eliminar los DATOS del marcador de nuestro array
        placedElements = placedElements.filter(el => el.internalId !== this.internalId);
        // ‚≠ê NUEVO: Tambi√©n eliminar de allMapMarkers
        allMapMarkers = allMapMarkers.filter(m => m.internalId !== this.internalId);
    });

    // Evento de click (abrir modal) - MEJORADO para evitar conflicto con arrastre
    google.maps.event.addListener(marker, 'click', function () {
        // ‚≠ê IMPORTANTE: Solo abrir modal si NO se est√° arrastrando
        if (!marker.isDragging) {
            // 1. Obtenemos los datos del elemento del mapa
            selectedMapElementData = placedElements.find(el => el.internalId === this.internalId);
            console.log("Elemento seleccionado:", selectedMapElementData);
            console.log("Dibujo ID:", selectedMapElementData ? selectedMapElementData.DrawingId : "N/A");
            
            // 2. Preparamos el modal una sola vez
            const elementModal = document.getElementById('elementModal');
            const myModal = new bootstrap.Modal(elementModal);

            // Asignamos el ID por si lo necesitamos
            if (selectedMapElementData) {
                elementModal.dataset.elementProjectId = selectedMapElementData.databaseId;
            }

            // 3. Verificamos si necesitamos cargar un dibujo existente
            if (selectedMapElementData && selectedMapElementData.DrawingId) {
                console.log(`Buscando datos del dibujo ID: ${selectedMapElementData.DrawingId}...`);

                $.ajax({
                    url: `/Project/GetDrawing/${selectedMapElementData.DrawingId}`,
                    type: 'GET',
                    dataType: 'json',
                    success: function (objetoJsonRecibido) {
                        console.log("‚úÖ Datos recibidos. Preparando para mostrar modal maximizado.");

                        const elementModal = document.getElementById('elementModal');
                        const myModal = new bootstrap.Modal(elementModal);

                        // USAMOS .one() PARA QUE ESTE EVENTO S√ìLO SE EJECUTE UNA VEZ POR CADA VEZ QUE SE ABRE EL MODAL.
                        $(elementModal).one('shown.bs.modal', function () {
                            console.log("Evento 'shown.bs.modal' disparado. El modal es completamente visible.");

                            if (window.cargarDesdeJSON) {
                                window.cargarDesdeJSON(objetoJsonRecibido);
                            } else {
                                console.error("La funci√≥n 'cargarDesdeJSON' no est√° disponible.");
                                alert("Error: No se pudo encontrar la funci√≥n para dibujar.");
                            }
                        });

                        // 1. PRIMERO: Llamamos a la funci√≥n para que A√ëADA las clases de maximizado.
                        maximizarModal();

                        // 2. SEGUNDO: Mostramos el modal.
                        myModal.show();
                    },
                    error: function (xhr) {
                        console.error('‚ùå Error al obtener los datos del dibujo:', xhr.responseText);
                        alert(`Error al cargar el dibujo. Respuesta: ${xhr.responseText}`);
                    }
                });
            } else {
                // 5. Si NO hay un dibujo guardado, simplemente limpiamos el lienzo y mostramos el modal vac√≠o.
                console.log("No hay dibujo asociado. Mostrando modal limpio.");
                if (window.limpiarLienzoKonvaGlobal) {
                    window.limpiarLienzoKonvaGlobal();
                }
                resetModalSize();
                myModal.show();
            }
        }
    });

    placedElements.push(elementData);
    allMapMarkers.push(marker); // ‚≠ê NUEVO: Guardar referencia al marcador visual

    console.log("Elemento colocado:", elementData, snapped ? "(Acoplado exactamente)" : "(Posici√≥n libre)");
} *@


function placeMarker(location, elementType, map, element) {
    let finalLocation = location;
    let snapped = false;

    // Solo aplicamos la l√≥gica de acoplamiento si hay una l√≠nea seleccionada y es un elemento nuevo.
    if (selectedPolyline && !element) {

        // --- INICIO DE LA NUEVA L√ìGICA DE PRECISI√ìN ---

        // PASO 1: Encontrar el punto m√°s cercano en la l√≠nea a nuestro clic.
        // Usamos la funci√≥n que ya existe en tu c√≥digo para esto.
        const snappedPosition = getClosestPointOnPolyline(location, selectedPolyline);

        // PASO 2: Calcular la distancia real en metros entre el clic y el punto m√°s cercano en la l√≠nea.
        const distance = google.maps.geometry.spherical.computeDistanceBetween(location, snappedPosition);

        // PASO 3: Definir un radio de "atracci√≥n" en metros.
        // Si el usuario hace clic a menos de esta distancia de la l√≠nea, lo acoplamos.
        // Puedes ajustar este valor si te parece muy grande o muy peque√±o.
        const TOLERANCIA_EN_METROS = 15;

        console.log(`Distancia a la l√≠nea: ${distance.toFixed(2)} metros.`);

        // PASO 4: Si el clic est√° dentro de nuestra tolerancia...
        if (distance < TOLERANCIA_EN_METROS) {
            console.log(`‚úÖ ¬°Acoplando! El clic est√° dentro de la tolerancia de ${TOLERANCIA_EN_METROS}m.`);

            // ...usamos el punto matem√°ticamente perfecto sobre la l√≠nea como la posici√≥n final.
            finalLocation = snappedPosition;
            snapped = true;

        } else {
            console.log("‚ùå Posici√≥n libre. El clic est√° demasiado lejos de la l√≠nea.");
            // Si no, 'finalLocation' sigue siendo la ubicaci√≥n original del clic.
        }
        // --- FIN DE LA NUEVA L√ìGICA DE PRECISI√ìN ---
    }

    // El resto del c√≥digo para crear el marcador, guardar datos y a√±adir eventos
    // permanece exactamente igual, ya que funciona correctamente.
    const latitude = typeof finalLocation.lat === 'function' ? finalLocation.lat() : finalLocation.lat;
    const longitude = typeof finalLocation.lng === 'function' ? finalLocation.lng() : finalLocation.lng;

    const elementData = {
        databaseId: element ? element.Id : null,
        DrawingId: element ? element.DrawingId : null,
        internalId: Date.now() + Math.random(),
        lat: latitude,
        lng: longitude,
        elementTypeId: elementType.id,
        attachedToPolyline: snapped ? selectedPolyline.segmentId : null
    };

    const marker = new google.maps.Marker({
        position: { lat: latitude, lng: longitude },
        map: map,
        draggable: true,
        icon: {
            url: elementType.iconUrl,
            scaledSize: new google.maps.Size(32, 32),
            origin: new google.maps.Point(0, 0),
            anchor: new google.maps.Point(16, 16)
        }
    });

    marker.internalId = elementData.internalId;
    marker.attachedToPolyline = elementData.attachedToPolyline;

    google.maps.event.addListener(marker, 'dragend', function() {
        handleMarkerDrag(marker);
    });

    google.maps.event.addListener(marker, 'dragstart', function() {
        marker.isDragging = true;
    });

    google.maps.event.addListener(marker, 'rightclick', function () {
        this.setMap(null);
        placedElements = placedElements.filter(el => el.internalId !== this.internalId);
        allMapMarkers = allMapMarkers.filter(m => m.internalId !== this.internalId);
    });

    google.maps.event.addListener(marker, 'click', function () {
        if (!marker.isDragging) {
            selectedMapElementData = placedElements.find(el => el.internalId === this.internalId);
            const elementModal = document.getElementById('elementModal');
            const myModal = new bootstrap.Modal(elementModal);

            if (selectedMapElementData) {
                elementModal.dataset.elementProjectId = selectedMapElementData.databaseId;
            }

            if (selectedMapElementData && selectedMapElementData.DrawingId) {
                $.ajax({
                    url: `/Project/GetDrawing/${selectedMapElementData.DrawingId}`,
                    type: 'GET',
                    dataType: 'json',
                    success: function (objetoJsonRecibido) {
                        $(elementModal).one('shown.bs.modal', () => window.cargarDesdeJSON && window.cargarDesdeJSON(objetoJsonRecibido));
                        maximizarModal();
                        myModal.show();
                    },
                    error: (xhr) => alert(`Error al cargar el dibujo: ${xhr.responseText}`)
                });
            } else {
                window.limpiarLienzoKonvaGlobal && window.limpiarLienzoKonvaGlobal();
                resetModalSize();
                myModal.show();
            }
        }
    });

    placedElements.push(elementData);
    allMapMarkers.push(marker);

    console.log("Elemento colocado:", elementData, snapped ? "(Acoplado con precisi√≥n)" : "(Posici√≥n libre)");
}



function handleMarkerDrag(marker) {
    const newPosition = marker.getPosition();
    
    // Si el marcador estaba conectado a una l√≠nea, mantenerlo conectado
    if (marker.attachedToPolyline) {
        const polyline = polylineSegments.find(p => p.segmentId === marker.attachedToPolyline);
        
        if (polyline) {
            // Encontrar el punto m√°s cercano en la l√≠nea
            const snappedPosition = getClosestPointOnPolyline(newPosition, polyline);
            
            // Mover el marcador al punto m√°s cercano de la l√≠nea
            marker.setPosition(snappedPosition);
            
            // Actualizar los datos del elemento
            const elementData = placedElements.find(el => el.internalId === marker.internalId);
            if (elementData) {
                elementData.lat = snappedPosition.lat();
                elementData.lng = snappedPosition.lng();
            }
            
            console.log(`üìç Marcador ${marker.internalId} reposicionado en la l√≠nea`);
        }
    } else {
        // Si no estaba conectado, solo actualizar las coordenadas
        const elementData = placedElements.find(el => el.internalId === marker.internalId);
        if (elementData) {
            elementData.lat = newPosition.lat();
            elementData.lng = newPosition.lng();
        }
    }
    
    // Resetear el flag de arrastrar despu√©s de un momento
    setTimeout(() => {
        marker.isDragging = false;
    }, 100);
}




function updateAttachedMarkers() {
    allMapMarkers.forEach(marker => {
        // ‚≠ê NO mover marcadores que se est√°n arrastrando
        if (marker.attachedToPolyline && !marker.isDragging) {
            const polyline = polylineSegments.find(p => p.segmentId === marker.attachedToPolyline);
            if (polyline) {
                const currentPos = marker.getPosition();
                const newPos = getClosestPointOnPolyline(currentPos, polyline);
                
                // Solo mover si la diferencia es significativa (evitar micro-movimientos)
                const distance = google.maps.geometry.spherical.computeDistanceBetween(currentPos, newPos);
                if (distance > 1) { // Solo mover si est√° a m√°s de 1 metro
                    marker.setPosition(newPos);
                    
                    const elementData = placedElements.find(el => el.internalId === marker.internalId);
                    if (elementData) {
                        elementData.lat = newPos.lat();
                        elementData.lng = newPos.lng();
                    }
                }
            }
        }
    });
}


function reconnectExistingMarkersToPolylines() {
    console.log("üîó Reconectando cajas existentes a l√≠neas...");
    
    allMapMarkers.forEach(marker => {
        // ‚≠ê AGREGAR: Hacer arrastrables los marcadores existentes tambi√©n
        if (!marker.getDraggable()) {
            marker.setDraggable(true);
            
            // Agregar listeners de arrastrar a marcadores existentes
            google.maps.event.addListener(marker, 'dragend', function() {
                handleMarkerDrag(marker);
            });
            
            google.maps.event.addListener(marker, 'dragstart', function() {
                marker.isDragging = true;
            });
        }
        
        // Resto del c√≥digo de reconexi√≥n igual...
        if (!marker.attachedToPolyline) {
            const markerPos = marker.getPosition();
            const tolerance = 50;
            
            let closestPolyline = null;
            let minDistance = Infinity;
            
            polylineSegments.forEach(polyline => {
                const isNear = google.maps.geometry.poly.isLocationOnEdge(
                    markerPos, 
                    polyline, 
                    tolerance / 111320
                );
                
                if (isNear) {
                    const closestPoint = getClosestPointOnPolyline(markerPos, polyline);
                    const distance = google.maps.geometry.spherical.computeDistanceBetween(markerPos, closestPoint);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestPolyline = polyline;
                    }
                }
            });
            
            if (closestPolyline) {
                marker.attachedToPolyline = closestPolyline.segmentId;
                
                const elementData = placedElements.find(el => el.internalId === marker.internalId);
                if (elementData) {
                    elementData.attachedToPolyline = closestPolyline.segmentId;
                }
                
                console.log(`‚úÖ Marcador ${marker.internalId} conectado a l√≠nea ${closestPolyline.segmentId}`);
            }
        }
    });
}


function getClosestPointOnPolyline(point, polyline) {
    const path = polyline.getPath();
    let closestPoint = null;
    let minDistance = Infinity;

    // Revisar cada segmento de la l√≠nea
    for (let i = 0; i < path.getLength() - 1; i++) {
        const segmentStart = path.getAt(i);
        const segmentEnd = path.getAt(i + 1);
        
        const candidatePoint = getClosestPointOnLineSegment(point, segmentStart, segmentEnd);
        const distance = google.maps.geometry.spherical.computeDistanceBetween(point, candidatePoint);
        
        if (distance < minDistance) {
            minDistance = distance;
            closestPoint = candidatePoint;
        }
    }

    return closestPoint || point;
}

// NUEVA FUNCI√ìN: Calcular el punto m√°s cercano sobre un segmento de l√≠nea
function getClosestPointOnLineSegment(point, segmentStart, segmentEnd) {
    const startLat = segmentStart.lat();
    const startLng = segmentStart.lng();
    const endLat = segmentEnd.lat();
    const endLng = segmentEnd.lng();
    const pointLat = point.lat();
    const pointLng = point.lng();

    // Calcular vectores
    const A = pointLat - startLat;
    const B = pointLng - startLng;
    const C = endLat - startLat;
    const D = endLng - startLng;

    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;

    if (lenSq !== 0) {
        param = dot / lenSq;
    }

    let closestLat, closestLng;

    if (param < 0) {
        // El punto m√°s cercano es el inicio del segmento
        closestLat = startLat;
        closestLng = startLng;
    } else if (param > 1) {
        // El punto m√°s cercano es el final del segmento
        closestLat = endLat;
        closestLng = endLng;
    } else {
        // El punto m√°s cercano est√° en el medio del segmento
        closestLat = startLat + param * C;
        closestLng = startLng + param * D;
    }

    return new google.maps.LatLng(closestLat, closestLng);
}
        

        document.getElementById('saveCoordsBtn').addEventListener('click', function () {
               let dataToSend = null;

    // CASO 1: Hay segmentos de polil√≠nea dibujados. Esta es ahora la √∫nica forma de guardar l√≠neas.
    if (polylineSegments && polylineSegments.length > 0) {
        const segmentsData = polylineSegments.map(segment => ({
            segmentId: segment.segmentId,
            color: segment.get('strokeColor'),
            coordinates: segment.coordinates ? segment.coordinates.map(c => ({
                lat: c.lat,
                lng: c.lng
            })) : []
        }));

        dataToSend = {
            Name: nameJs,
            Id: currentProjectId,
            Type: 'multi_polyline', // El backend recibe un tipo consistente.
            Segments: segmentsData,
            PlacedElements: placedElements
        };
    }
    // CASO 2: No hay l√≠neas, pero s√≠ hay un pol√≠gono.
    else if (currentPolygonCoords.length > 0) {
        dataToSend = {
            Name: nameJs,
            Id: currentProjectId,
            Type: 'polygon',
            Coordinates: currentPolygonCoords.map(c => ({ lat: c.lat, lng: c.lng })),
            PlacedElements: placedElements
        };
    }
    // CASO 3: No hay nada que guardar.
    else {
        // Tambi√©n puedes guardar si solo hay elementos colocados sin l√≠neas
        if (placedElements && placedElements.length > 0) {
             dataToSend = {
                Name: nameJs,
                Id: currentProjectId,
                Type: 'elements_only', // Un tipo para indicar que solo van elementos
                Segments: [],
                PlacedElements: placedElements
            };
        } else {
            alert("Por favor, dibuja una l√≠nea/pol√≠gono o coloca alg√∫n elemento antes de guardar.");
            return;
        }
    }

    // El resto de tu c√≥digo de fetch es perfecto y no necesita cambios.
    console.log("üì§ Datos que se van a enviar:", dataToSend);
    console.log("üì§ JSON a enviar:", JSON.stringify(dataToSend));

    fetch('/Project/Coordinate', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(dataToSend)
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`Error HTTP! estado: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        console.log('Datos guardados. Redirigiendo a:', data.redirectToUrl);
        window.location.href = data.redirectToUrl;
    })
    .catch((error) => {
        console.error('Error:', error);
        alert('Hubo un error al guardar las coordenadas: ' + error.message);
    });
});




        // Esta l√≠nea es crucial para que Google Maps sepa qu√© funci√≥n llamar una vez que el API est√© cargada
        window.initMap = initMap;


        // C√≥digo de colores est√°ndar TIA-598-C para cables
        const CABLE_COLOR_PALETTES = {
            // Para cables espec√≠ficos de 5 hilos
            5: [
                '#007bff', // 1. Azul
                '#fd7e14', // 2. Naranja
                '#28a745', // 3. Verde
                '#a0522d', // 4. Marr√≥n
                '#6c757d'  // 5. Gris
            ],
            // C√≥digo de colores est√°ndar TIA-598-C para 12 fibras. Se usar√° para cables de 8, 12 y otros tama√±os.
            default: [
                '#007bff', // 1. Azul
                '#fd7e14', // 2. Naranja
                '#28a745', // 3. Verde
                '#a0522d', // 4. Marr√≥n
                '#6c757d', // 5. Gris (Slate)
                '#D3D3D3', // 6. Gris Claro (en lugar de Blanco)
                '#dc3545', // 7. Rojo
                '#000000', // 8. Negro
                '#ffc107', // 9. Amarillo
                '#8a2be2', // 10. Violeta
                '#e83e8c', // 11. Rosa
                '#17a2b8'  // 12. Aguamarina
            ]
        };
         



        // =================================================================================
        // =========== INICIO DE LA L√ìGICA DE KONVA.JS (CON GUARDADO SVG) =================
        // =================================================================================
       
        let mainLayer;
        let stage;
        let cableCreationCounter = 0;//contador para crear cables en base a logica derecha o izquierda
        
        document.addEventListener('DOMContentLoaded', function () {
          
             let nodeIdCounter = 0;
             let currentMode = 'select';
             let isDrawingLine = false, lineStartPoint = null, previewLine = null;
              let startElement = null, endElement = null;


function setupZoomAndPan(stage) {
    const zoomFactor = 1.1;
    const minScale = 0.2;
    const maxScale = 10.0;
    const stageContainer = stage.container();

    // --- L√ìGICA DE ZOOM (Sin cambios) ---
    function zoomStage(event) {
        event.evt.preventDefault();
        const oldScale = stage.scaleX();
        const pointer = stage.getPointerPosition();
        const mousePointTo = {
            x: (pointer.x - stage.x()) / oldScale,
            y: (pointer.y - stage.y()) / oldScale,
        };
        const direction = event.evt.deltaY > 0 ? -1 : 1;
        let newScale = direction > 0 ? oldScale * zoomFactor : oldScale / zoomFactor;
        newScale = Math.max(minScale, Math.min(maxScale, newScale));
        stage.scale({ x: newScale, y: newScale });
        const newPos = {
            x: pointer.x - mousePointTo.x * newScale,
            y: pointer.y - mousePointTo.y * newScale,
        };
        stage.position(newPos);
        stage.batchDraw();
    }
    stage.on('wheel', zoomStage);

    // --- L√ìGICA DE PANEO (Sin cambios) ---
    let isSpacebarPanning = false;
    let isDragPanning = false;
    let panStartPos = { x: 0, y: 0 };
    let spacebarPressed = false;

    window.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && document.activeElement.tagName === 'BODY') {
            e.preventDefault();
            spacebarPressed = true;
            if (!isSpacebarPanning && !isDragPanning) {
                stageContainer.style.cursor = 'grab';
            }
        }
    });

    window.addEventListener('keyup', (e) => {
        if (e.code === 'Space') {
            e.preventDefault();
            spacebarPressed = false;
            isSpacebarPanning = false;
            if (!isDragPanning) {
                stageContainer.style.cursor = 'default';
            }
        }
    });

    stage.on('mousedown', (e) => {
        if (spacebarPressed) {
            isSpacebarPanning = true;
            panStartPos = stage.getPointerPosition();
            stageContainer.style.cursor = 'grabbing';
            return;
        }
        if (e.target === stage) {
            isDragPanning = true;
            panStartPos = stage.getPointerPosition();
            stageContainer.style.cursor = 'grabbing';
        }
    });
    
    // --- MANEJADOR 'mousemove' UNIFICADO Y CORREGIDO ---
    stage.on('mousemove', () => {
        // --- 1. L√ìGICA DE PANEO ---
        if (isSpacebarPanning || isDragPanning) {
            const currentPos = stage.getPointerPosition();
            if (!currentPos) return;

            const dx = currentPos.x - panStartPos.x;
            const dy = currentPos.y - panStartPos.y;
            stage.move({ x: dx, y: dy });
            panStartPos = currentPos;
            stage.batchDraw();
            return; 
        }

        // --- 2. L√ìGICA DE DIBUJO ---
        if (currentMode === 'draw' && isDrawingLine && previewLine) {
            let globalPos = stage.getPointerPosition();
            if (!globalPos) return;

            const hasSnapPoint = getSnapPoint(globalPos);
            let endPosGlobal = hasSnapPoint || globalPos;
            
            // Traducir la coordenada final a la local de la capa
            const transform = mainLayer.getAbsoluteTransform().copy().invert();
            const endPosLocal = transform.point(endPosGlobal);
            
            // =================================================================
            // === ESTA ES LA CORRECCI√ìN CLAVE PARA EL C√çRCULO ROJO ===========
            // =================================================================
            if (hasSnapPoint) {
                // Posicionamos el indicador usando la coordenada LOCAL
                snapIndicator.position(endPosLocal).show();
            } else {
                snapIndicator.hide();
            }
            // =================================================================

            // Actualizamos la l√≠nea de previsualizaci√≥n (esto ya estaba bien)
            previewLine.points(calculateOrthogonalPoints(lineStartPoint, endPosLocal));
            
            mainLayer.draw();
        }
    });

    // --- L√ìGICA MOUSEUP (Sin cambios) ---
    window.addEventListener('mouseup', () => {
        const wasPanning = isSpacebarPanning || isDragPanning;
        isSpacebarPanning = false;
        isDragPanning = false;

        if (wasPanning) {
           if (spacebarPressed) {
               stageContainer.style.cursor = 'grab';
           } else {
               stageContainer.style.cursor = 'default';
           }
        }
    });

    console.log("üöÄ Funcionalidad de Zoom y Paneo UNIFICADA inicializada.");
}

            // --- 1. CONFIGURACI√ìN INICIAL ---
            @* let stage = new Konva.Stage({ container: 'konva-container', width: 750, height: 500 }); *@

                //funcion central para redimensionar el lienzo de Konva
                function resizeCanvasToContainer() {
                    if (stage && stage.container) {
                        const container = stage.container();
                        const newWidth = container.clientWidth;
                        const newHeight = container.clientHeight;

                        if (newWidth > 0 && newHeight > 0) {
                            stage.width(newWidth);
                            stage.height(newHeight);
                            stage.draw();
                            console.log(`‚úÖ Lienzo redimensionado a: ${newWidth}x${newHeight}`);
                        }
                    }
                }
             //aqui antes estaba declarado la varoiable let stage pero se declaro de una forma global no olvidar
            const container = document.getElementById('konva-container');
             stage = new Konva.Stage({
                container: 'konva-container',
                width: 1,   // Ancho din√°mico basado en el contenedor
                height: 1  // Alto din√°mico basado en el contenedor
            });

            mainLayer = new Konva.Layer();
            stage.add(mainLayer);

            // Le decimos a la capa que no tenga ninguna √°rea de recorte.
// Esto fuerza a Konva a dibujar siempre todos los objetos,
// sin importar si est√°n fuera de la vista inicial.
mainLayer.clipFunc(null);
mainLayer.clipX(undefined);
mainLayer.clipY(undefined);
mainLayer.clipWidth(undefined);
mainLayer.clipHeight(undefined);

             // Llama a la nueva funci√≥n limpia aqu√≠
             setupZoomAndPan(stage);


             //resetear zoom para no generar error 
             function resetStageView(stage) {
    if (stage) {
        // Restablecer la escala a 100%
        stage.scale({ x: 1, y: 1 });
        
        // Restablecer la posici√≥n al punto de origen
        stage.position({ x: 0, y: 0 });
        
        // Redibujar el lienzo para aplicar los cambios
        stage.batchDraw();
        
        console.log("‚úÖ Vista del lienzo reseteada a 100%");
    }
}


//codigo para exportar imagen del dibujo realizado

document.getElementById('export-button').addEventListener('click', () => {
    // Obtener la URL de datos del stage
    // Puedes especificar el formato ('image/jpeg') y la calidad (0-1) si quieres.
    const dataURL = stage.toDataURL({
        mimeType: 'image/png',
        quality: 1, // Calidad m√°xima para un PNG
        pixelRatio: 2 // Opcional: Para una imagen de mayor resoluci√≥n en pantallas Retina
    });

    // Crear un elemento de enlace (<a>) en la memoria
    const link = document.createElement('a');
    link.download = 'mi-diagrama-de-cables.png'; // Nombre del archivo
    link.href = dataURL;

    // Simular un clic en el enlace para iniciar la descarga
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link); // Limpiar el enlace
});

// va ligado con el zoom Escucha el evento que se dispara JUSTO ANTES de que el modal 'elementModal' se muestre.
    $('#elementModal').on('show.bs.modal', function () {
        // 'stage' debe ser la variable global o accesible que contiene tu lienzo de Konva
        // Aseg√∫rate de que la variable 'stage' est√© disponible en este scope.
        if (typeof stage !== 'undefined') {
            resetStageView(stage);

        // EXTRA: Es una buena pr√°ctica tambi√©n asegurarse de que el lienzo se redimensione
        // por si el tama√±o de la ventana cambi√≥ mientras el modal estaba cerrado.
        resizeCanvasToContainer();
        }
    });


            // --- 3. EL C√ìDIGO FINAL PARA EL BOT√ìN MAXIMIZAR EN BOOTSTRAP 4 ---
            document.getElementById('toggleFullscreenBtn').addEventListener('click', function () {
                const modalDialog = document.querySelector('#elementModal .modal-dialog');

                // Alternamos nuestra clase personalizada '.modal-fullscreen-bs4'
                modalDialog.classList.toggle('modal-fullscreen-bs4');

                // Y tambi√©n alternamos '.modal-xl' para que no est√©n ambas al mismo tiempo
                modalDialog.classList.toggle('modal-xl');

                // Esperamos la animaci√≥n y llamamos a nuestra funci√≥n central.
                setTimeout(resizeCanvasToContainer, 250);

            });

            const colorPicker = document.getElementById('colorPicker');
            const brushSize = document.getElementById('brushSize');
            const clearCanvasBtn = document.getElementById('clearCanvasBtn');
            const saveCanvasBtn = document.getElementById('saveCanvasBtn');
            const componentControls = document.getElementById('componentGeneratorControls');
            const selectModeBtn = document.getElementById('selectModeBtn');
            const drawModeBtn = document.getElementById('drawModeBtn');
             //lo estoy colocando de forma global si hay falla descomentar y usar local
            //let currentMode = 'select';
            let templateCableGroup = null;
            let selectedCanvasColor = '#000000';

            let transformer = new Konva.Transformer({
                borderStroke: 'blue', borderDash: [6, 2], rotateEnabled: true, anchorSize: 8, name: 'tool_transformer'
            });
            mainLayer.add(transformer);

            let snapIndicator = new Konva.Circle({
                radius: 7, stroke: 'red', strokeWidth: 2, visible: false, name: 'tool_snap_indicator'
            });
            mainLayer.add(snapIndicator);

            // --- 2. GESTI√ìN DE MODOS DE TRABAJO ---
            function setMode(newMode) {
                currentMode = newMode;
                if (newMode === 'select') {
                    selectModeBtn.classList.add('btn-primary');
                    selectModeBtn.classList.remove('btn-outline-secondary');
                    drawModeBtn.classList.add('btn-outline-secondary');
                    drawModeBtn.classList.remove('btn-primary');
                    stage.container().style.cursor = 'default';
                    abortLineDrawing();
                } else { // 'draw'
                    drawModeBtn.classList.add('btn-primary');
                    drawModeBtn.classList.remove('btn-outline-secondary');
                    selectModeBtn.classList.add('btn-outline-secondary');
                    selectModeBtn.classList.remove('btn-primary');
                    stage.container().style.cursor = 'crosshair';
                    transformer.nodes([]);
                }
            }

            // Crear paleta de colores para l√≠neas
            function createCanvasColorPalette() {
                const toolbar = document.getElementById('toolbar');
                const colorSection = document.createElement('div');
                colorSection.className = 'me-3 border-end pe-3';
                colorSection.innerHTML = '<span class="me-2 small">COLOR L√çNEA:</span>';

                const availableColorsComplete = [
                    { name: 'Negro', Color: '#000000' },
                    { name: 'Rojo', Color: '#FF0000' },
                    { name: 'Azul', Color: '#0000FF' },
                    { name: 'Verde', Color: '#008000' }
                ];

                availableColorsComplete.forEach((colorObject, index) => {
                    const colorBtn = document.createElement('button');
                    colorBtn.className = 'btn btn-sm me-1 canvas-color-btn';
                    colorBtn.style.backgroundColor = colorObject.Color;
                    colorBtn.style.width = '25px';
                    colorBtn.style.height = '25px';
                    colorBtn.style.border = '2px solid #ccc';
                    colorBtn.style.borderRadius = '4px';
                    colorBtn.title = `${colorObject.name} - ${colorObject.Color}`;
                    colorBtn.dataset.color = colorObject.Color;

                    if (index === 0) {
                        colorBtn.classList.add('active-canvas-color');
                        colorBtn.style.border = '2px solid #007bff';
                        selectedCanvasColor = colorObject.Color;
                    }

                    colorBtn.addEventListener('click', () => {
                        document.querySelectorAll('.canvas-color-btn').forEach(btn => {
                            btn.classList.remove('active-canvas-color');
                            btn.style.border = '2px solid #ccc';
                        });

                        colorBtn.classList.add('active-canvas-color');
                        colorBtn.style.border = '2px solid #007bff';
                        selectedCanvasColor = colorObject.Color;
                        colorPicker.value = colorObject.Color;

                        console.log(`üé® Color seleccionado para l√≠neas: ${colorObject.Color}`);
                    });

                    colorSection.appendChild(colorBtn);
                });

                const modeSection = toolbar.querySelector('.border-end');
                modeSection.parentNode.insertBefore(colorSection, modeSection.nextSibling);
            }

            if (document.getElementById('toolbar')) {
                createCanvasColorPalette();
            }

            selectModeBtn.addEventListener('click', () => setMode('select'));
            drawModeBtn.addEventListener('click', () => setMode('draw'));

            // --- 3. GESTI√ìN DE EVENTOS DE RAT√ìN ---
            @* let isDrawingLine = false, lineStartPoint = null, previewLine = null;
            let startElement = null, endElement = null; *@

            stage.on('click tap', (e) => {
                if (currentMode === 'select') {
                    handleSelection(e);
                } else {
                    handleLineDrawing(e);
                }
            });


function handleSelection(e) {
    // ‚úÖ L√çNEA A√ëADIDA: Si se hace clic en la imagen de referencia, no hacemos nada.
    if (e.target && e.target.hasName('reference_image')) {
        transformer.nodes([]); // Deseleccionamos cualquier otra cosa
        mainLayer.draw();
        return; // Y salimos de la funci√≥n
    }
    // 1. LIMPIEZA PREVENTIVA: Ocultamos todos los manejadores 'X' que puedan estar visibles.
    //    Esto asegura que cada nueva selecci√≥n comience desde un estado visual limpio.
    mainLayer.find('.line_handle').forEach(h => h.hide());

    // 2. CASO DE DESELECCI√ìN: Si el usuario hizo clic en el fondo del lienzo...
    if (e.target === stage) {
        // ...le decimos al transformer que olvide TODO lo que ten√≠a seleccionado.
        transformer.nodes([]);
        mainLayer.draw();
        return; // Salimos de la funci√≥n inmediatamente.
    }

    // 3. IDENTIFICACI√ìN PRECISA DEL OBJETIVO:
    let targetNode;
    const parentGroup = e.target.getParent();

    // Comprobamos si el clic fue en una parte de un cable/splitter.
    if (parentGroup && (parentGroup.hasName('cable') || parentGroup.hasName('splitter'))) {
        targetNode = parentGroup; // El objetivo real es el grupo completo.
    }
    // Si no, comprobamos si fue directamente en una l√≠nea.
    else if (e.target.hasName('connector')) {
        targetNode = e.target; // El objetivo es la propia l√≠nea.
    }
    // Si no es un objeto seleccionable...
    else {
        transformer.nodes([]); // ...tambi√©n deseleccionamos todo.
        mainLayer.draw();
        return;
    }

    // 4. ¬°LA CORRECCI√ìN M√ÅS IMPORTANTE! LA SELECCI√ìN √öNICA.
    //    Al usar `transformer.nodes([targetNode])`, estamos REEMPLAZANDO la selecci√≥n.
    //    Esto BORRA la lista anterior de objetos seleccionados y la sustituye con una nueva
    //    lista que contiene √öNICAMENTE el 'targetNode' que acabamos de clickear.
    //    Esto previene el "da√±o colateral" porque es imposible tener selecciones m√∫ltiples accidentales.
    transformer.nodes([targetNode]);

    // 5. MOSTRAR HERRAMIENTAS CONTEXTUALES:
    //    Solo si el objeto reci√©n seleccionado es una l√≠nea, llamamos a la funci√≥n
    //    que se encarga de mostrar sus manejadores 'X'.
    if (targetNode.hasName('connector')) {
        updateLineHandles(targetNode);
    }
    
    // 6. REDIBUJAR: Mostramos los cambios en el lienzo (el nuevo cuadro de selecci√≥n, etc.).
    mainLayer.draw();
}

            

            function calculateOrthogonalPoints(startPos, endPos) {
                const midX = startPos.x + (endPos.x - startPos.x) / 2;
                return [startPos.x, startPos.y, midX, startPos.y, midX, endPos.y, endPos.x, endPos.y];
            }



            // REEMPLAZA TU FUNCI√ìN ACTUAL CON ESTA VERSI√ìN CORREGIDA
            function findElementAtPosition(pos) {
                let closestElement = null;
                let closestPointData = null;
                let minDistance = 15; // Este es nuestro radio m√°ximo de b√∫squeda

                // Recorremos todos los cables y splitters
                mainLayer.find('.cable, .splitter').forEach(group => {
                    // Recorremos los puntos de conexi√≥n de cada grupo
                    (group.attrs.connectionPoints || []).forEach((point, index) => {
                        // Obtenemos la posici√≥n real del punto en el lienzo
                        const transform = group.getAbsoluteTransform();
                        const worldPoint = transform.point(point);

                        // Calculamos la distancia desde el cursor a este punto
                        const distance = Math.sqrt(Math.pow(worldPoint.x - pos.x, 2) + Math.pow(worldPoint.y - pos.y, 2));

                        // ===================================================================
                        // === ESTA ES LA L√ìGICA CORREGIDA ==================================
                        // ===================================================================
                        // Si la distancia actual es MENOR que la m√≠nima distancia que hemos encontrado hasta ahora...
                        if (distance < minDistance) {
                            // ...actualizamos la m√≠nima distancia a este nuevo valor m√°s peque√±o.
                            minDistance = distance;
                            // Y guardamos este elemento y este punto como los "ganadores" actuales.
                            closestElement = group;
                            closestPointData = { point: point, index: index, worldPos: worldPoint };
                        }
                        // ===================================================================
                    });
                });

                // Al final del recorrido, devolvemos el elemento y el punto que resultaron ser los m√°s cercanos de todos.
                return closestElement ? { element: closestElement, connectionPoint: closestPointData } : null;
            }

         
          function handleLineDrawing(e) {
    // Funci√≥n auxiliar para obtener la posici√≥n del puntero (sin cambios)
    function getPointerPosInLayer() {
        const transform = mainLayer.getAbsoluteTransform().copy().invert();
        const pos = stage.getPointerPosition();
        if (!pos) return { x: 0, y: 0 };
        return transform.point(pos);
    }

    let pos = getPointerPosInLayer();

    // L√≥gica del PRIMER clic (para iniciar la l√≠nea). Esta parte no cambia.
    if (!isDrawingLine) {
        isDrawingLine = true;
        lineStartPoint = pos;
        startElement = findElementAtPosition(stage.getPointerPosition());

        let lineColor = selectedCanvasColor;
        if (startElement && startElement.connectionPoint.point.color) {
            lineColor = startElement.connectionPoint.point.color;
        }

        if (!previewLine) {
            previewLine = new Konva.Line({
                stroke: lineColor,
                strokeWidth: parseInt(brushSize.value),
                dash: [8, 4],
                name: 'connector_preview',
                visible: false
            });
            mainLayer.add(previewLine);
        }

        previewLine.stroke(lineColor);
        previewLine.points([lineStartPoint.x, lineStartPoint.y, pos.x, pos.y]);
        previewLine.visible(true);
        mainLayer.draw();
    } 
    // L√≥gica del SEGUNDO clic (para finalizar la l√≠nea). Aqu√≠ est√° la mejora.
    else {
        endElement = findElementAtPosition(stage.getPointerPosition());

        if (lineStartPoint.x === pos.x && lineStartPoint.y === pos.y) {
            abortLineDrawing();
            return;
        }

        // =================================================================================
        // =========== INICIO DE LA MODIFICACI√ìN CLAVE =======================================
        // =================================================================================
        // 1. Tomamos el color inicial de la l√≠nea de previsualizaci√≥n como base.
        let finalLineColor = previewLine.stroke();

        // 2. ¬°LA MAGIA OCURRE AQU√ç!
        //    Comprobamos si el punto de DESTINO (endElement) tiene un color definido.
        //    Si es as√≠ (por ejemplo, el c√≠rculo rojo de un cable), usamos ESE color.
        if (endElement && endElement.connectionPoint.point.color) {
            finalLineColor = endElement.connectionPoint.point.color;
        }
        // =================================================================================
        // =========== FIN DE LA MODIFICACI√ìN ==============================================
        // =================================================================================

        const finalLine = new Konva.Line({
            points: [lineStartPoint.x, lineStartPoint.y, pos.x, pos.y],
            stroke: finalLineColor, // Usamos el color final que acabamos de determinar
            strokeWidth: parseInt(brushSize.value),
            name: 'connector',
            hitStrokeWidth: 20,
            cableAId: startElement ? startElement.element.id() : null,
            cableAConnIdx: startElement ? startElement.connectionPoint.index : null,
            cableBId: endElement ? endElement.element.id() : null,
            cableBConnIdx: endElement ? endElement.connectionPoint.index : null
        });

        attachPointAddingListener(finalLine);
        mainLayer.add(finalLine);
        if (!window.connectors) window.connectors = [];
        window.connectors.push(finalLine);

        abortLineDrawing();
        transformer.nodes([finalLine]);
        updateLineHandles(finalLine);
    }
}




            function calculateAdaptiveLine(startPos, endPos) {
                const dx = endPos.x - startPos.x;
                const dy = endPos.y - startPos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 80) {
                    return [startPos.x, startPos.y, endPos.x, endPos.y];
                }

                const controlDistance = Math.min(distance * 0.4, 100);

                if (Math.abs(dx) > Math.abs(dy)) {
                    const midX1 = startPos.x + (dx > 0 ? controlDistance : -controlDistance);
                    const midX2 = endPos.x - (dx > 0 ? controlDistance : -controlDistance);
                    return [startPos.x, startPos.y, midX1, startPos.y, midX2, endPos.y, endPos.x, endPos.y];
                } else {
                    const midY1 = startPos.y + (dy > 0 ? controlDistance : -controlDistance);
                    const midY2 = endPos.y - (dy > 0 ? controlDistance : -controlDistance);
                    return [startPos.x, startPos.y, startPos.x, midY1, endPos.x, midY2, endPos.x, endPos.y];
                }
            }


function updateConnectedLines(movedElement) {
    // Obtenemos la matriz de transformaci√≥n inversa de la capa.
    // Esta matriz es la "traductora" que convierte coordenadas del mundo (con zoom) a coordenadas locales (sin zoom).
    const layerTransform = mainLayer.getAbsoluteTransform().copy().invert();

    window.connectors.forEach(connector => {
        // Comprobamos si la l√≠nea est√° conectada al elemento que se movi√≥.
        if (connector.attrs.cableAId === movedElement.id() || connector.attrs.cableBId === movedElement.id()) {
            const cableA = mainLayer.findOne('#' + connector.attrs.cableAId);
            const cableB = mainLayer.findOne('#' + connector.attrs.cableBId);

            if (cableA && cableB) {
                // PASO 1: Obtenemos la posici√≥n ABSOLUTA (en el mundo con zoom) de los puntos de conexi√≥n.
                const absPosA = cableA.getAbsoluteTransform().point(cableA.attrs.connectionPoints[connector.attrs.cableAConnIdx]);
                const absPosB = cableB.getAbsoluteTransform().point(cableB.attrs.connectionPoints[connector.attrs.cableBConnIdx]);

                // PASO 2: Usamos nuestra "traductora" para convertir esas posiciones absolutas a locales.
                const localPosA = layerTransform.point(absPosA);
                const localPosB = layerTransform.point(absPosB);

                // PASO 3: Actualizamos los puntos de la l√≠nea usando las coordenadas LOCALES correctas.
                const points = connector.points();
                points[0] = localPosA.x;
                points[1] = localPosA.y;
                points[points.length - 2] = localPosB.x;
                points[points.length - 1] = localPosB.y;
                connector.points(points);

                // Actualizamos la posici√≥n de los manejadores 'X' si existen.
                updateLineHandles(connector);
            }
        }
    });

    // Redibujamos la capa para mostrar los cambios.
    mainLayer.batchDraw();
}




function distanceToSegment(p, v, w) {
    const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
    if (l2 === 0) return Math.sqrt((p.x - v.x)**2 + (p.y - v.y)**2);
    let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    t = Math.max(0, Math.min(1, t));
    const closestX = v.x + t * (w.x - v.x);
    const closestY = v.y + t * (w.y - v.y);
    return Math.sqrt((p.x - closestX)**2 + (p.y - closestY)**2);
}


function attachPointAddingListener(line) {
    line.on('click tap', (evt) => {
        // Esta parte no cambia: solo permitimos a√±adir puntos si estamos en modo selecci√≥n
        // y no estamos haciendo clic sobre un manejador 'X' existente.
        if (currentMode !== 'select' || (evt.target.getParent() && evt.target.getParent().hasName('line_handle'))) {
            return;
        }

        // ===================================================================
        // === INICIO DE LA CORRECCI√ìN CLAVE =================================
        // ===================================================================

        // 1. Funci√≥n auxiliar para obtener la posici√≥n del puntero DENTRO de la capa
        function getPointerPosInLayer() {
            const transform = mainLayer.getAbsoluteTransform().copy().invert();
            const pos = stage.getPointerPosition();
            if (!pos) return null; // Prevenir error si el puntero est√° fuera
            return transform.point(pos);
        }

        // 2. Usamos la nueva posici√≥n LOCAL en lugar de la global.
        const clickPos = getPointerPosInLayer();
        if (!clickPos) return; // Salimos si no se pudo obtener la posici√≥n

        // ===================================================================
        // === FIN DE LA CORRECCI√ìN ==========================================
        // ===================================================================

        const points = line.points();
        
        // La l√≥gica para encontrar el segmento m√°s cercano ahora funcionar√° correctamente
        // porque `clickPos` y los puntos de la l√≠nea est√°n en el mismo sistema de coordenadas.
        let bestSegmentIndex = 0;
        let minDistance = Infinity;

        // El bucle de b√∫squeda no necesita cambios
        for (let i = 0; i < points.length - 2; i += 2) {
            // Transformamos los puntos de la l√≠nea a coordenadas absolutas para la comparaci√≥n
            const p1 = line.getAbsoluteTransform().point({ x: points[i], y: points[i + 1] });
            const p2 = line.getAbsoluteTransform().point({ x: points[i + 2], y: points[i + 3] });
            
            // Usamos la posici√≥n global del puntero para la distancia, ya que los puntos de la l√≠nea tambi√©n son globales ahora
            const dist = distanceToSegment(stage.getPointerPosition(), p1, p2);
            if (dist < minDistance) {
                minDistance = dist;
                bestSegmentIndex = i + 2;
            }
        }
        
        // Insertamos el nuevo punto LOCAL (x, y) en el array de puntos de la l√≠nea.
        points.splice(bestSegmentIndex, 0, clickPos.x, clickPos.y);
        line.points(points);
        
        // Actualizamos los manejadores para que aparezca el nuevo.
        updateLineHandles(line);
    });
}


            function restoreOriginalShape() {
                mainLayer.find('.connector').forEach(line => {
                    if (line.attrs.startConnection && line.attrs.endConnection) {
                        const startTransform = line.attrs.startConnection.element.getAbsoluteTransform();
                        const endTransform = line.attrs.endConnection.element.getAbsoluteTransform();
                        const startPos = startTransform.point(line.attrs.startConnection.connectionPoint.point);
                        const endPos = endTransform.point(line.attrs.endConnection.connectionPoint.point);
                        line.points(calculateOrthogonalPoints(startPos, endPos));
                        line.tension(0);
                    }
                });
                mainLayer.draw();
            }

             function abortLineDrawing() {
                isDrawingLine = false;
                if (previewLine) previewLine.destroy();
                previewLine = null;
                startElement = null;
                endElement = null;
                snapIndicator.hide();
                mainLayer.draw();
            } 
 

            function getSnapPoint(pos) {
                let closestPoint = null;
                let minDistance = 15;
                mainLayer.find('.cable, .splitter').forEach(group => {
                    (group.attrs.connectionPoints || []).forEach(point => {
                        const transform = group.getAbsoluteTransform();
                        const worldPoint = transform.point(point);
                        const distance = Math.sqrt(Math.pow(worldPoint.x - pos.x, 2) + Math.pow(worldPoint.y - pos.y, 2));
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestPoint = worldPoint;
                        }
                    });
                });
                return closestPoint;
            }
             

            componentControls.addEventListener('click', (e) => {
    const target = e.target;
    if (target.tagName !== 'BUTTON') return;

    // =========== NUEVO ===========
    // L√≥gica para el bot√≥n de autoconexi√≥n
    if (target.id === 'autoConnectBtn') {
        autoConnectLastTwoCables();
        return; // Salimos para no generar un cable nuevo
    }
    // =============================


    // Decidimos la direcci√≥n (derecha/izquierda) bas√°ndonos en el contador.
    // Esta l√≥gica ya la ten√≠as y es correcta.
    const direction = (cableCreationCounter % 2 === 0) ? 'right' : 'left';
    const initialX = (direction === 'right') ? 100 : stage.width() - 100;

    // CASO 1: Es un bot√≥n de cable simple (data-strands)
    if (target.dataset.strands) {
        const newCable = createCableGroup(parseInt(target.dataset.strands), direction);
        newCable.position({ x: initialX, y: 250 });
        mainLayer.add(newCable);
    }
    // CASO 2: Es el nuevo bot√≥n de multi-cable (data-multi-cable)
    else if (target.dataset.multiCable) {
        const [strands, cables] = target.dataset.multiCable.split('x').map(Number); // "12x4" -> [12, 4]
        
        // Llamamos a nuestra nueva funci√≥n para crear el bloque de 4 cables.
        const newBlock = createMultiCableBlock(strands, cables, direction);
        newBlock.position({ x: initialX, y: 150 }); // Lo ponemos un poco m√°s arriba
        mainLayer.add(newBlock);
    }
    // CASO 3: Es un bot√≥n de splitter
    else if (target.dataset.splitterOut) {
        const splitterGroup = createSplitterGroup(1, parseInt(target.dataset.splitterOut));
        splitterGroup.position({ x: 750 - 150, y: 250 });
        mainLayer.add(splitterGroup);
    }

    // Incrementamos el contador para la pr√≥xima vez, sin importar qu√© bot√≥n se puls√≥.
    cableCreationCounter++;
    
    mainLayer.draw();
});

           
function createCableGroup(numStrands, direction = 'right', bufferLineColor = null) {
    const groupId = 'cable_' + nodeIdCounter++;
    const group = new Konva.Group({ id: groupId, draggable: true, name: 'cable', connectionPoints: [] });

    group.attrs.direction = direction;

    const directionMultiplier = (direction === 'left') ? -1 : 1;
    const lineThickness = 3, verticalSpacing = 15, cableWidth = 30;
    const circleRadius = 8;
    const fontSize = 10;
    const finalX = cableWidth * directionMultiplier;
    const totalHeight = (numStrands - 1) * verticalSpacing;
    const startY = -totalHeight / 2;
    let firstLineY, lastLineY;

    const colorsToUse = CABLE_COLOR_PALETTES[numStrands] || CABLE_COLOR_PALETTES.default;
    group.attrs.strandColors = [];

    // --- PASO 1: Dibujar todos los componentes de los hilos (siempre van al frente) ---
    for (let i = 0; i < numStrands; i++) {
        const currentY = startY + (i * verticalSpacing);
        const strandColor = colorsToUse[i % colorsToUse.length];
        group.attrs.strandColors.push(strandColor);

        if (i === 0) firstLineY = currentY;
        if (i === numStrands - 1) lastLineY = currentY;

        const linePoints = [0, currentY, finalX, currentY];
        if (strandColor === '#ffffff') {
            group.add(new Konva.Line({ points: linePoints, stroke: 'black', strokeWidth: lineThickness, lineCap: 'round', listening: false }));
            group.add(new Konva.Line({ points: linePoints, stroke: strandColor, strokeWidth: lineThickness - 1.5, lineCap: 'round', listening: false }));
        } else {
            group.add(new Konva.Line({ points: linePoints, stroke: strandColor, strokeWidth: lineThickness, lineCap: 'round', listening: false }));
        }

        const circleX = finalX + (circleRadius * directionMultiplier);
        group.attrs.connectionPoints.push({ x: circleX, y: currentY, color: strandColor, index: i });
        const circle = new Konva.Circle({ x: circleX, y: currentY, radius: circleRadius, fill: 'white', stroke: strandColor, strokeWidth: 2, listening: false });
        group.add(circle);
        const numberText = new Konva.Text({ x: circleX - circleRadius, y: currentY - circleRadius, width: circleRadius * 2, height: circleRadius * 2, align: 'center', verticalAlign: 'middle', text: (i + 1).toString(), fontSize: fontSize, fill: 'black', listening: false });
        group.add(numberText);
    }
    
    // --- PASO 2: A√±adir los elementos de fondo ---
    const mainVerticalLine = new Konva.Line({
        points: [0, firstLineY, 0, lastLineY],
        stroke: 'black',
        strokeWidth: lineThickness,
        lineCap: 'round',
        listening: false
    });
    group.add(mainVerticalLine);

    let bufferLine = null;
    if (bufferLineColor) {
        bufferLine = new Konva.Line({
            // =================================================================================
            // === ESTA ES LA CORRECCI√ìN CLAVE: Se ajustaron las coordenadas Y ===============
            // =================================================================================
            points: [
                0, startY + 70,                         // Punto de inicio: m√°s arriba
                -20 * directionMultiplier, startY + 90  // Punto final: m√°s abajo (Y mayor)
            ],
            // =================================================================================
            stroke: bufferLineColor,
            strokeWidth: 5,
            listening: false,
            name: 'buffer_line'
        });
        group.add(bufferLine);
    }
    
    // --- PASO 3: Crear el hitbox DESPU√âS de que todo lo visible est√© a√±adido ---
    const hitbox = new Konva.Rect({ ...group.getClientRect({ relativeTo: group }), fill: 'transparent' });
    group.add(hitbox);

    // --- PASO 4: Establecer el orden de apilado (esta parte ya es correcta) ---
    mainVerticalLine.moveToBottom();
    if (bufferLine) {
        bufferLine.moveToBottom();
    }
    hitbox.moveToBottom();
    
    // --- PASO 5: Asignar eventos ---
    group.on('dragmove', () => updateConnectedLines(group));
    group.on('transform', () => updateConnectedLines(group));

    return group;
}



// =============================================================================
// =========== NUEVA FUNCI√ìN COMPLETA: L√≥gica de la autoconexi√≥n ===========
// =============================================================================
/**
 * Busca los dos √∫ltimos cables individuales creados, comprueba que sean opuestos 
 * (uno derecho, uno izquierdo) y los conecta autom√°ticamente uniendo los hilos del mismo color.
 */

function autoConnectLastTwoCables() {

    // CASO 1: Intentar conectar BLOQUES de cables (ej: 12x4 vs 12x4, o 12x8 vs 12x8)
    const allBlocks = mainLayer.find('.cable_block');
    if (allBlocks.length >= 2) {
        const lastTwoBlocks = allBlocks.slice(-2);
        const block1 = lastTwoBlocks[0];
        const block2 = lastTwoBlocks[1];

        // Obtenemos la direcci√≥n del primer cable DENTRO de cada bloque para saber la orientaci√≥n del bloque.
        const dir1 = block1.findOne('.cable')?.attrs.direction;
        const dir2 = block2.findOne('.cable')?.attrs.direction;

        // Si los bloques son opuestos, procedemos a conectarlos
        if (dir1 && dir2 && dir1 !== dir2) {
            const cables1 = block1.find('.cable');
            const cables2 = block2.find('.cable');

            // Verificaci√≥n de seguridad: los bloques deben tener el mismo n√∫mero de cables internos.
            if (cables1.length !== cables2.length) {
                alert("Error: Los bloques de cables no tienen el mismo n√∫mero de cables internos y no se pueden conectar.");
                return;
            }

            console.log(`‚úÖ Detectados dos bloques opuestos. Iniciando conexi√≥n de bloques...`);
            const layerTransform = mainLayer.getAbsoluteTransform().copy().invert();

            // Iteramos por cada cable DENTRO de los bloques (el 1ro de aqu√≠ con el 1ro de all√°, etc.)
            for (let i = 0; i < cables1.length; i++) {
                const cableA = cables1[i];
                const cableB = cables2[i];

                // Ahora, para cada par de cables, conectamos sus hilos por √≠ndice
                cableA.attrs.connectionPoints.forEach(pointA => {
                    const pointB = cableB.attrs.connectionPoints.find(p => p.index === pointA.index);
                    if (pointB) {
                        // Es CRUCIAL usar getAbsoluteTransform() para obtener la posici√≥n real del hilo en el lienzo,
                        // ya que est√° dentro de un cable, que a su vez est√° dentro de un bloque.
                        const absPosA = cableA.getAbsoluteTransform().point(pointA);
                        const absPosB = cableB.getAbsoluteTransform().point(pointB);

                        // Convertimos de vuelta a coordenadas locales de la capa para crear la l√≠nea
                        const localPosA = layerTransform.point(absPosA);
                        const localPosB = layerTransform.point(absPosB);

                        const newLine = new Konva.Line({
                            points: [localPosA.x, localPosA.y, localPosB.x, localPosB.y],
                            stroke: pointA.color,
                            strokeWidth: parseInt(brushSize.value),
                            name: 'connector',
                            hitStrokeWidth: 20,
                            cableAId: cableA.id(),
                            cableAConnIdx: pointA.index,
                            cableBId: cableB.id(),
                            cableBConnIdx: pointB.index
                        });

                        attachPointAddingListener(newLine);
                        mainLayer.add(newLine);
                        if (!window.connectors) window.connectors = [];
                        window.connectors.push(newLine);
                    }
                });
            }
            mainLayer.draw();
            console.log(`‚úÖ Autoconexi√≥n de bloques completada.`);
            return; // ¬°Importante! Terminamos la ejecuci√≥n aqu√≠ para no pasar a la l√≥gica de cables individuales.
        }
    }

    // CASO 2: Si no se encontraron bloques, buscar CABLES INDIVIDUALES (l√≥gica de respaldo)
    console.log("No se encontraron bloques opuestos, buscando cables individuales...");
    const singleCables = mainLayer.find('.cable').filter(c => {
        const parent = c.getParent();
        return parent && !parent.hasName('cable_block');
    });

    if (singleCables.length < 2) {
        alert("No se encontraron dos cables individuales opuestos para conectar.");
        return;
    }

    const lastTwoCables = singleCables.slice(-2);
    const cable1 = lastTwoCables[0];
    const cable2 = lastTwoCables[1];

    if (cable1.attrs.direction === cable2.attrs.direction) {
        alert("Los dos √∫ltimos cables individuales generados no son opuestos.");
        return;
    }
    if (cable1.attrs.connectionPoints.length !== cable2.attrs.connectionPoints.length) {
        alert("Error: Los cables individuales no tienen el mismo n√∫mero de hilos.");
        return;
    }

    const layerTransform = mainLayer.getAbsoluteTransform().copy().invert();
    cable1.attrs.connectionPoints.forEach(point1 => {
        const matchingPoint2 = cable2.attrs.connectionPoints.find(p2 => p2.index === point1.index);
        if (matchingPoint2) {
            const absPos1 = cable1.getAbsoluteTransform().point(point1);
            const absPos2 = cable2.getAbsoluteTransform().point(matchingPoint2);
            const localPos1 = layerTransform.point(absPos1);
            const localPos2 = layerTransform.point(absPos2);

            const newLine = new Konva.Line({
                points: [localPos1.x, localPos1.y, localPos2.x, localPos2.y],
                stroke: point1.color,
                strokeWidth: parseInt(brushSize.value),
                name: 'connector',
                hitStrokeWidth: 20,
                cableAId: cable1.id(),
                cableAConnIdx: point1.index,
                cableBId: cable2.id(),
                cableBConnIdx: matchingPoint2.index
            });
            attachPointAddingListener(newLine);
            mainLayer.add(newLine);
            if (!window.connectors) window.connectors = [];
            window.connectors.push(newLine);
        }
    });

    mainLayer.draw();
    console.log(`‚úÖ Autoconexi√≥n de cables individuales completada.`);
}

            @* function createSplitterGroup(numInputs, numOutputs) {
    const groupId = 'splitter_' + nodeIdCounter++;
    const group = new Konva.Group({ id: groupId, draggable: true, name: 'splitter', connectionPoints: [] });

    // --- 1. NUEVAS CONSTANTES PARA LOS CUADRADOS NUMERADOS ---
    const spacing = 20, width = 60, height = (numOutputs - 1) * spacing;
    const boxSize = 15;  // Tama√±o del cuadrado
    const fontSize = 10; // Tama√±o del n√∫mero

    // Punto de conexi√≥n de entrada (sin cambios)
    //group.attrs.connectionPoints.push({ x: 0, y: 0 });
    group.attrs.connectionPoints.push({ x: 0, y: 0, index: 0 });


    // Hitbox y forma del splitter (sin cambios)
    const hitbox = new Konva.Rect({ x: 0, y: -height / 2, width: width, height: height, fill: 'transparent' });
    group.add(hitbox);
    group.add(new Konva.Line({
        points: [0, 0, width, -height / 2, width, height / 2],
        closed: true,
        fill: 'white',
        stroke: 'black',
        strokeWidth: 2,
        listening: false
    }));

    // C√≠rculo de entrada (sin cambios)
    group.add(new Konva.Circle({ x: 0, y: 0, radius: 5, fill: 'black', listening: false }));

    // ===================================================================
    // === INICIO DE LA MODIFICACI√ìN: Bucle para Salidas Numeradas =======
    // ===================================================================
    for (let i = 0; i < numOutputs; i++) {
        const y = -height / 2 + i * spacing;

        // El punto de conexi√≥n sigue estando en el centro, esto es correcto.
        //group.attrs.connectionPoints.push({ x: width, y: y });

        group.attrs.connectionPoints.push({ x: width, y: y, index: i + 1 });

        // 2. Creamos el Cuadrado (Konva.Rect)
        // La posici√≥n (x, y) de un rect√°ngulo es su esquina superior izquierda,
        // as√≠ que restamos la mitad del tama√±o para centrarlo.
        const rect = new Konva.Rect({
            x: width - boxSize / 2,
            y: y - boxSize / 2,
            width: boxSize,
            height: boxSize,
            fill: 'white',
            stroke: 'black',
            strokeWidth: 2,
            listening: false
        });
        group.add(rect);

        // 3. Creamos el Texto con el n√∫mero
        // Usamos la misma posici√≥n y tama√±o para centrar el texto dentro del cuadrado.
        const numberText = new Konva.Text({
            x: width - boxSize / 2,
            y: y - boxSize / 2,
            width: boxSize,
            height: boxSize,
            text: (i + 1).toString(), // El n√∫mero es el √≠ndice + 1
            fontSize: fontSize,
            fill: 'black',
            align: 'center',       // Centrado horizontal
            verticalAlign: 'middle', // Centrado vertical
            listening: false
        });
        group.add(numberText);
    }

     //a√±ado esto para colocar comentario en el spliter
          const descriptionText = new Konva.Text({
    x: width / 2, // <-- CAMBIO 1: Lo movemos a la mitad del ancho del splitter
    y: (height / 2) + 8, // <-- CAMBIO 2: Lo bajamos un poco m√°s para que respire
    text: '',
    fontSize: 11, // Un poco m√°s peque√±o y discreto
    fontFamily: 'Arial, sans-serif', // Una fuente m√°s est√°ndar y legible
    fontStyle: 'italic', // <-- CAMBIO 3: Estilo en cursiva para que parezca un comentario
    fill: '#555555', // <-- CAMBIO 4: Un gris oscuro, m√°s suave que el negro
    width: width + 20, // Hacemos la caja un poco m√°s ancha para textos largos
    align: 'center',
    offsetX: (width + 20) / 2, // <-- CAMBIO 5 (EL M√ÅS IMPORTANTE): Este es el truco para el centrado perfecto.
    name: 'description_text'
});
    group.add(descriptionText);

    // 2. A√ëADIMOS EL EVENTO DE DOBLE CLIC AL GRUPO COMPLETO
    group.on('dblclick dbltap', () => {
        // Obtenemos la descripci√≥n actual guardada en el grupo, o un string vac√≠o si no existe
        const oldDescription = group.attrs.description || '';
        
        // Usamos un 'prompt' de JavaScript. Es simple y efectivo.
        const newDescription = prompt("Descripci√≥n del Splitter:", oldDescription);

        // Si el usuario escribi√≥ algo y no presion√≥ "Cancelar" (que devuelve null)
        if (newDescription !== null) {
            // Guardamos el nuevo texto como un atributo personalizado en el grupo.
            // ¬°ESTO ES LO QUE SE GUARDAR√Å EN EL JSON!
            group.setAttr('description', newDescription);
            
            // Actualizamos el texto visual del nodo que creamos antes.
            descriptionText.text(newDescription);
            
            // Redibujamos la capa para que se vea el cambio.
            mainLayer.draw();
        }
    });
 
    
    // Eventos (sin cambios)
    group.on('dragmove', () => updateConnectedLines(group));
    group.on('transform', () => updateConnectedLines(group));
    // Eliminamos 'dragend' si ya no usas restoreOriginalShape
    // group.on('dragend', () => restoreOriginalShape());

    return group;
} *@


function createSplitterGroup(numInputs, numOutputs) {
    const groupId = 'splitter_' + nodeIdCounter++;
    const group = new Konva.Group({ id: groupId, draggable: true, name: 'splitter', connectionPoints: [] });

    const spacing = 20, width = 60, height = (numOutputs - 1) * spacing;
    const boxSize = 15;
    const fontSize = 10;

    // Punto de conexi√≥n de entrada
    group.attrs.connectionPoints.push({ x: 0, y: 0, index: 0 });

    // Hitbox y forma del splitter
    const hitbox = new Konva.Rect({ x: 0, y: -height / 2, width: width, height: height, fill: 'transparent' });
    group.add(hitbox);
    group.add(new Konva.Line({
        points: [0, 0, width, -height / 2, width, height / 2],
        closed: true,
        fill: 'white',
        stroke: 'black',
        strokeWidth: 2,
        listening: false
    }));

    // C√≠rculo de entrada
    group.add(new Konva.Circle({ x: 0, y: 0, radius: 5, fill: 'black', listening: false }));

    // ===================================================================
    // === PUERTOS DE SALIDA CON CUADRADOS NUMERADOS Y DESCRIPCI√ìN ======
    // ===================================================================
    for (let i = 0; i < numOutputs; i++) {
        const y = -height / 2 + i * spacing;

        // ‚úÖ CADA PUERTO TIENE SU PROPIO CAMPO description
        group.attrs.connectionPoints.push({ 
            x: width, 
            y: y, 
            index: i + 1,
            description: '' // üëà Comentario individual por puerto
        });

        // Cuadrado numerado
        const rect = new Konva.Rect({
            x: width - boxSize / 2,
            y: y - boxSize / 2,
            width: boxSize,
            height: boxSize,
            fill: 'white',
            stroke: 'black',
            strokeWidth: 2,
            listening: true // ‚úÖ IMPORTANTE: Para poder hacer doble clic
        });
        group.add(rect);

        // N√∫mero dentro del cuadrado
        const numberText = new Konva.Text({
            x: width - boxSize / 2,
            y: y - boxSize / 2,
            width: boxSize,
            height: boxSize,
            text: (i + 1).toString(),
            fontSize: fontSize,
            fill: 'black',
            align: 'center',
            verticalAlign: 'middle',
            listening: false
        });
        group.add(numberText);
    }

    // ===================================================================
    // === DESCRIPCI√ìN GENERAL DEL SPLITTER (LA QUE YA TEN√çAS) ==========
    // ===================================================================
    const descriptionText = new Konva.Text({
        x: width / 2,
        y: (height / 2) + 8,
        text: '',
        fontSize: 11,
        fontFamily: 'Arial, sans-serif',
        fontStyle: 'italic',
        fill: '#555555',
        width: width + 20,
        align: 'center',
        offsetX: (width + 20) / 2,
        name: 'description_text'
    });
    group.add(descriptionText);

    // ===================================================================
    // === EVENTO DE DOBLE CLIC EN EL GRUPO (DESCRIPCI√ìN GENERAL) =======
    // ===================================================================
    group.on('dblclick dbltap', () => {
        const oldDescription = group.attrs.description || '';
        const newDescription = prompt("Descripci√≥n General del Splitter:", oldDescription);

        if (newDescription !== null) {
            group.setAttr('description', newDescription);
            descriptionText.text(newDescription);
            mainLayer.draw();
        }
    });

    // ===================================================================
    // === NUEVO: EVENTOS DE DOBLE CLIC EN CADA PUERTO ==================
    // ===================================================================
    group.find('Rect').forEach((rect, index) => {
        // Ignoramos el hitbox (√≠ndice 0)
        if (index === 0) return;
        
        const portIndex = index; // El √≠ndice del puerto
        
        rect.on('dblclick dbltap', (e) => {
            e.cancelBubble = true; // ‚úÖ Evita que el evento suba al grupo
            
            const port = group.attrs.connectionPoints[portIndex];
            if (!port) return;
            
            const oldDescription = port.description || '';
            const newDescription = prompt(`Comentario para Puerto ${port.index}:`, oldDescription);
            
            if (newDescription !== null) {
                port.description = newDescription;
                displayPortComments(group);
                mainLayer.draw();
            }
        });
    });

    // Eventos de movimiento
    group.on('dragmove', () => updateConnectedLines(group));
    group.on('transform', () => updateConnectedLines(group));

    return group;
}





// üÜï FUNCI√ìN PARA MOSTRAR LOS COMENTARIOS DE CADA PUERTO
function displayPortComments(splitterGroup) {
    if (!splitterGroup) return;

    // Primero, borramos todos los comentarios antiguos
    splitterGroup.find('.port_comment_text').forEach(text => text.destroy());

    const connectionPoints = splitterGroup.attrs.connectionPoints || [];
    const width = 60;

    connectionPoints.forEach(port => {
        // Si el puerto tiene descripci√≥n y no es el de entrada (index 0)
        if (port.description && port.index > 0) {
            const commentText = new Konva.Text({
                x: width + 20,
                y: port.y - 6,
                text: port.description,
                fontSize: 10,
                fontFamily: 'Arial, sans-serif',
                fontStyle: 'italic',
                fill: '#0066cc',
                name: 'port_comment_text',
                listening: false
            });
            splitterGroup.add(commentText);
        }
    });
}


//este es el codigo que estoy usando pero esta comenatdo para probar otro
function createMultiCableBlock(numStrands, numCables, direction) {
    const blockGroup = new Konva.Group({
        draggable: true,
        name: 'cable_block'
    });

    const blockSpacing = 20;

    for (let i = 0; i < numCables; i++) {
        // ===================================================================
        // === CAMBIO CLAVE: Obtenemos el color del buffer para este cable ===
        // ===================================================================
        // Usamos el √≠ndice 'i' para sacar el color correspondiente del c√≥digo est√°ndar.
        // El '%' (m√≥dulo) es por seguridad, si se crearan m√°s de 12 cables, volver√≠a a empezar por el azul.
        const bufferLineColor = CABLE_COLOR_PALETTES.default[i % CABLE_COLOR_PALETTES.default.length];
        
        // Y ahora pasamos ese color al crear el cable individual.
        const singleCable = createCableGroup(numStrands, direction, bufferLineColor);
        // ===================================================================
        
        const cableHeight = (numStrands - 1) * 15 + 2 * 8;
        const yPos = i * (cableHeight + blockSpacing);

        singleCable.position({ x: 0, y: yPos });
        singleCable.draggable(false);
        blockGroup.add(singleCable);
    }

    blockGroup.on('dragmove transform', () => {
        blockGroup.find('.cable').forEach(singleCable => {
            updateConnectedLines(singleCable);
        });
    });

    return blockGroup;
}



function updateLineHandles(line) {
    // Primero, eliminamos todos los manejadores antiguos asociados con esta l√≠nea para evitar duplicados.
    mainLayer.find('.line_handle').forEach(handle => {
        if (handle.attrs.line === line) {
            handle.destroy();
        }
    });

    // Si la l√≠nea no est√° seleccionada, no hacemos nada m√°s.
    if (!transformer.nodes().includes(line)) {
        mainLayer.draw();
        return;
    }

    const points = line.points();
    // Creamos un manejador para cada PUNTO INTERMEDIO de la l√≠nea.
    // (Ignoramos el primer y √∫ltimo punto, que est√°n anclados a los cables).
    for (let i = 2; i < points.length - 2; i += 2) {
        const x = points[i];
        const y = points[i + 1];
        const pointIndex = i; // Guardamos el √≠ndice de este punto

        const handle = new Konva.Group({
            x: x,
            y: y,
            draggable: true,
            name: 'line_handle'
        });

        // Guardamos la referencia a la l√≠nea y al √≠ndice del punto en el manejador.
        handle.attrs.line = line;
        handle.attrs.pointIndex = pointIndex;

        handle.add(new Konva.Circle({ radius: 8, fill: '#dc3545', stroke: 'black', strokeWidth: 1 }));
        handle.add(new Konva.Text({ text: 'X', fontSize: 12, fill: 'white', fontStyle: 'bold', width: 16, height: 16, x: -8, y: -8, align: 'center', verticalAlign: 'middle' }));
        
        mainLayer.add(handle);

        // EVENTO DE ARRASTRE: Mueve el punto en el array de la l√≠nea.
        handle.on('dragmove', () => {
            const lineToUpdate = handle.attrs.line;
            const index = handle.attrs.pointIndex;
            const points = lineToUpdate.points();
            
            points[index] = handle.x();
            points[index + 1] = handle.y();
            lineToUpdate.points(points);
        });

        // EVENTO DE CLIC: Elimina el punto del array de la l√≠nea.
        handle.on('click tap', () => {
            const lineToUpdate = handle.attrs.line;
            const index = handle.attrs.pointIndex;
            const points = lineToUpdate.points();

            // Eliminamos el par de coordenadas (x, y) del array de puntos.
            points.splice(index, 2);
            lineToUpdate.points(points);

            // Volvemos a dibujar los manejadores, que ahora ser√°n menos.
            updateLineHandles(lineToUpdate);
        });
    }
    mainLayer.find('.line_handle').forEach(h => h.moveToTop());
}




            // =========================================================================
            // === NUEVO SISTEMA DE GUARDADO SVG + JSON ================================
            // =========================================================================

            /**
             * üéØ NUEVA FUNCI√ìN: Genera tanto JSON como SVG del dibujo actual
             */
            function generarDatosCompletos() {
                // 1. JSON (para edici√≥n)
                const jsonData = stage.toJSON();

                // 2. Preparar para exportar SVG
                transformer.nodes([]);  // quita selecci√≥n
                snapIndicator.hide();
                mainLayer.draw();

                // 3. Exportar a SVG de manera segura
                let svgData = null;
                if (stage.toSVG) {
                    try {
                        svgData = stage.toSVG();
                    } catch (err) {
                        console.error("‚ùå Error al exportar SVG:", err);
                        svgData = "<!-- Error en exportaci√≥n -->";
                    }
                } else if (Konva && Konva.exportToSVG) {
                    svgData = Konva.exportToSVG(stage);
                } else {
                    console.warn("‚ö†Ô∏è Exportaci√≥n SVG no disponible.");
                    svgData = "<!-- Exportaci√≥n SVG no disponible -->";
                }

                return {
                    jsonContent: jsonData,
                    svgContent: svgData
                };
            }



              window.cargarDesdeJSON = function (dataFromAjax) {
                try {
                    let jsonData;
                    // Se asegura de que jsonData sea un string para poder parsearlo despu√©s
                    if (typeof dataFromAjax === 'object' && dataFromAjax !== null) {
                        jsonData = JSON.stringify(dataFromAjax);
                    } else if (typeof dataFromAjax === 'string' && dataFromAjax.trim() !== '') {
                        jsonData = dataFromAjax;
                    } else {
                        throw new Error("Los datos recibidos no son un JSON v√°lido.");
                    }

                    if (stage) {
                        stage.destroy();
                    }

                    // ===================================================================
                    // =========== ESTE ES EL CAMBIO FUNDAMENTAL Y CORRECTO ==============
                    // ===================================================================

                    // 1. CREAMOS UN NUEVO LIENZO VAC√çO CON LAS DIMENSIONES ACTUALES Y CORRECTAS
                    const container = document.getElementById('konva-container');
                    stage = new Konva.Stage({
                        container: 'konva-container',
                        width: container.clientWidth,
                        height: container.clientHeight
                    });

                    // 2. AHORA, CREAMOS LA CAPA A PARTIR DE LOS "HIJOS" DEL JSON
                    const data = JSON.parse(jsonData);
                    // data.children[0] es el objeto de la capa principal guardado en el JSON
                    mainLayer = Konva.Node.create(data.children[0]);
                    stage.add(mainLayer); // La a√±adimos a nuestro nuevo lienzo grande

                    // ===================================================================

                    // Vuelve a inicializar el zoom y paneo en el NUEVO stage.
                      setupZoomAndPan(stage);

                    // 3. (Opcional pero recomendado) Aplicamos el "clip fix" por si acaso
                    if (mainLayer) {
                        mainLayer.clipFunc(null);
                        mainLayer.clipX(undefined);
                        mainLayer.clipY(undefined);
                        mainLayer.clipWidth(undefined);
                        mainLayer.clipHeight(undefined);
                    }

                    // 4. Re-a√±adimos las herramientas a la nueva capa
                    transformer = new Konva.Transformer({ /* ... tus propiedades ... */ });
                    snapIndicator = new Konva.Circle({ /* ... tus propiedades ... */ });
                    mainLayer.add(transformer, snapIndicator);

                    // 5. Reconectamos los eventos
                    reconectarEventos();

                    // =========================================================================
        // === L√çNEA A√ëADIDA: Aqu√≠ ocurre la magia del centrado autom√°tico ========
        // =========================================================================
        centerAndFitContent(stage, mainLayer);
        // =========================================================================

                    // 6. ¬°AHORA S√ç! Dibujamos todo en el lienzo ya grande.
                    stage.draw();

                    console.log("‚úÖ Dibujo cargado en un nuevo lienzo con las dimensiones correctas.");

                } catch (error) {
                    console.error("‚ùå Error CR√çTICO dentro de cargarDesdeJSON:", error);
                    alert("Error final al procesar los datos del dibujo: " + error.message);
                }
            }; 

           // =========================================================================
// === NUEVA FUNCI√ìN DE AYUDA: Centrar y ajustar el contenido cargado =====
// =========================================================================
            function centerAndFitContent(stage, layer, padding = 0.9) {
    if (!layer) return;

    // 1. Obtener el rect√°ngulo que envuelve a TODOS los elementos de la capa.
    const box = layer.getClientRect();

    // Si no hay nada en la capa o no tiene dimensiones, no hacemos nada.
    if (box.width === 0 || box.height === 0) {
        // Simplemente reseteamos la vista a la posici√≥n inicial
        stage.position({ x: 0, y: 0 });
        stage.scale({ x: 1, y: 1 });
        stage.draw();
        return;
    }

    const stageWidth = stage.width();
    const stageHeight = stage.height();

    // 2. Calcular el nivel de zoom necesario para que el contenido quepa.
    // Comparamos el ancho del lienzo con el ancho del contenido, y lo mismo con el alto.
    // Usamos la escala m√°s peque√±a de las dos para asegurarnos de que todo entre sin ser cortado.
    const scaleX = stageWidth / box.width;
    const scaleY = stageHeight / box.height;
    const scale = Math.min(scaleX, scaleY) * padding;

    // 3. Calcular la nueva posici√≥n del lienzo.
    // Queremos que el centro del contenido coincida con el centro del lienzo visible.
    const newPos = {
        x: -box.x * scale + (stageWidth - box.width * scale) / 2,
        y: -box.y * scale + (stageHeight - box.height * scale) / 2,
    };

    // 4. Aplicar la nueva escala y posici√≥n al lienzo.
    stage.scale({ x: scale, y: scale });
    stage.position(newPos);
    stage.draw();

    console.log("‚úÖ Contenido cargado y centrado en la vista.");
}

@* function reconectarEventos() {
    if (!stage || !mainLayer) return;

    // Sincronizar el contador de IDs (esto ya estaba bien y se mantiene)
    let maxId = -1;
    mainLayer.find('.cable, .splitter').forEach(group => {
        const id = group.id();
        if (id) {
            const numericPart = parseInt(id.split('_')[1], 10);
            if (!isNaN(numericPart) && numericPart > maxId) {
                maxId = numericPart;
            }
        }
    });
    nodeIdCounter = maxId + 1;
    console.log(`‚úÖ Contador de IDs sincronizado. El pr√≥ximo ID ser√°: ${nodeIdCounter}`);

    // Limpiar manejadores fantasma (esto ya estaba bien)
    mainLayer.find('.line_handle').forEach(handle => handle.destroy());

    // Reconectar listeners de l√≠neas (esto ya estaba bien)
    window.connectors = [];
    mainLayer.find('.connector').forEach(connector => {
        window.connectors.push(connector);
        attachPointAddingListener(connector);
    });

    // Reconstruir eventos para CABLES y SPLITTERS
    mainLayer.find('.cable, .splitter').forEach(group => {
        const isChildOfBlock = group.getParent() && group.getParent().hasName('cable_block');

        if (!isChildOfBlock) {
            group.draggable(true);
            group.off('dragmove transform');
            group.on('dragmove', () => updateConnectedLines(group));
            group.on('transform', () => updateConnectedLines(group));
        } else {
            group.draggable(false);
        }

        // ==========================================================================================
        // === INICIO DE LA CORRECCI√ìN CLAVE ========================================================
        // ==========================================================================================
        // Antes, esta secci√≥n borraba y recalculaba los connectionPoints, causando el desfase.
        // Ahora, simplemente nos aseguramos de que los puntos cargados desde el JSON existan.
        // El c√°lculo solo se ejecutar√° como un respaldo si los datos no se cargaron por alguna raz√≥n.
        if (group.hasName('cable')) {
            if (!group.attrs.connectionPoints || group.attrs.connectionPoints.length === 0) {
                // Este c√≥digo solo se ejecutar√° si se carga un dibujo muy antiguo sin datos de conexi√≥n.
                console.warn(`‚ö†Ô∏è Reconstruyendo connectionPoints para el cable ${group.id()} porque no se encontraron en los datos cargados.`);
                group.attrs.connectionPoints = [];
                const numStrands = group.attrs.strandColors.length;
                const firstLine = group.findOne('Line');
                const direction = (firstLine && firstLine.points()[2] > 0) ? 'right' : 'left';
                const directionMultiplier = (direction === 'left') ? -1 : 1;
                const verticalSpacing = 15, cableWidth = 30, circleRadius = 8;
                const finalX = cableWidth * directionMultiplier;
                const circleX = finalX + (circleRadius * directionMultiplier);
                const totalHeight = (numStrands - 1) * verticalSpacing;
                const startY = -totalHeight / 2;
                for (let i = 0; i < numStrands; i++) {
                    const currentY = startY + (i * verticalSpacing);
                    const strandColor = group.attrs.strandColors[i];
                    group.attrs.connectionPoints.push({ x: circleX, y: currentY, color: strandColor, index: i });
                }
            }
            // Si los puntos ya existen en group.attrs (que es lo normal al cargar desde JSON),
            // ¬°NO HACEMOS NADA! Y as√≠ evitamos el bug.
        }
        // ==========================================================================================
        // === FIN DE LA CORRECCI√ìN =================================================================
        // ==========================================================================================
    });


    //codigo para mostarar la descripcion del splitter al cargar

    mainLayer.find('.splitter').forEach(group => {
        group.off('dblclick dbltap'); 
        group.on('dblclick dbltap', () => {
            const oldDescription = group.attrs.description || '';
            const newDescription = prompt("Editar Descripci√≥n del Splitter:", oldDescription);
            if (newDescription !== null) {
                group.setAttr('description', newDescription);
                const textNode = group.findOne('.description_text');
                if (textNode) {
                    textNode.text(newDescription);
                }
                mainLayer.draw();
            }
        });
    });


    // Reconectar eventos de los bloques de cables (esto ya estaba bien)
    mainLayer.find('.cable_block').forEach(blockGroup => {
        blockGroup.draggable(true);
        blockGroup.off('dragmove transform');
        blockGroup.on('dragmove transform', () => {
            blockGroup.find('.cable').forEach(singleCable => {
                updateConnectedLines(singleCable);
            });
        });
    });

    // Reconectar eventos generales del stage (esto ya estaba bien)
    stage.off('click tap');
    stage.on('click tap', (e) => {
        if (currentMode === 'select') {
            handleSelection(e);
        } else {
            handleLineDrawing(e);
        }
    });

    console.log("üîó Eventos, datos y listeners de l√≠nea reconectados correctamente. Total de conectores:", window.connectors.length);
} *@

function reconectarEventos() {
    if (!stage || !mainLayer) return;

    // Sincronizar el contador de IDs
    let maxId = -1;
    mainLayer.find('.cable, .splitter').forEach(group => {
        const id = group.id();
        if (id) {
            const numericPart = parseInt(id.split('_')[1], 10);
            if (!isNaN(numericPart) && numericPart > maxId) {
                maxId = numericPart;
            }
        }
    });
    nodeIdCounter = maxId + 1;
    console.log(`‚úÖ Contador de IDs sincronizado. El pr√≥ximo ID ser√°: ${nodeIdCounter}`);

    // Limpiar manejadores fantasma
    mainLayer.find('.line_handle').forEach(handle => handle.destroy());

    // Reconectar listeners de l√≠neas
    window.connectors = [];
    mainLayer.find('.connector').forEach(connector => {
        window.connectors.push(connector);
        attachPointAddingListener(connector);
    });

    // Reconstruir eventos para CABLES y SPLITTERS
    mainLayer.find('.cable, .splitter').forEach(group => {
        const isChildOfBlock = group.getParent() && group.getParent().hasName('cable_block');

        if (!isChildOfBlock) {
            group.draggable(true);
            group.off('dragmove transform');
            group.on('dragmove', () => updateConnectedLines(group));
            group.on('transform', () => updateConnectedLines(group));
        } else {
            group.draggable(false);
        }

        // Reconstruir connectionPoints para CABLES (sin cambios)
        if (group.hasName('cable')) {
            if (!group.attrs.connectionPoints || group.attrs.connectionPoints.length === 0) {
                console.warn(`‚ö†Ô∏è Reconstruyendo connectionPoints para el cable ${group.id()}`);
                group.attrs.connectionPoints = [];
                const numStrands = group.attrs.strandColors.length;
                const firstLine = group.findOne('Line');
                const direction = (firstLine && firstLine.points()[2] > 0) ? 'right' : 'left';
                const directionMultiplier = (direction === 'left') ? -1 : 1;
                const verticalSpacing = 15, cableWidth = 30, circleRadius = 8;
                const finalX = cableWidth * directionMultiplier;
                const circleX = finalX + (circleRadius * directionMultiplier);
                const totalHeight = (numStrands - 1) * verticalSpacing;
                const startY = -totalHeight / 2;
                for (let i = 0; i < numStrands; i++) {
                    const currentY = startY + (i * verticalSpacing);
                    const strandColor = group.attrs.strandColors[i];
                    group.attrs.connectionPoints.push({ x: circleX, y: currentY, color: strandColor, index: i });
                }
            }
        }
    });

    // ===================================================================
    // === RECONECTAR EVENTOS PARA SPLITTERS CON COMENTARIOS POR PUERTO =
    // ===================================================================
    mainLayer.find('.splitter').forEach(group => {
        // 1. Reconectar evento de doble clic en el GRUPO (descripci√≥n general)
        group.off('dblclick dbltap');
        group.on('dblclick dbltap', () => {
            const oldDescription = group.attrs.description || '';
            const newDescription = prompt("Editar Descripci√≥n General del Splitter:", oldDescription);
            if (newDescription !== null) {
                group.setAttr('description', newDescription);
                const textNode = group.findOne('.description_text');
                if (textNode) {
                    textNode.text(newDescription);
                }
                mainLayer.draw();
            }
        });

        // 2. Reconectar eventos de doble clic en cada PUERTO
        group.find('Rect').forEach((rect, index) => {
            if (index === 0) return; // Ignorar hitbox
            
            const portIndex = index;
            rect.off('dblclick dbltap'); // Limpiar eventos anteriores
            
            rect.on('dblclick dbltap', (e) => {
                e.cancelBubble = true;
                const port = group.attrs.connectionPoints[portIndex];
                if (!port) return;
                
                const oldDescription = port.description || '';
                const newDescription = prompt(`Comentario para Puerto ${port.index}:`, oldDescription);
                
                if (newDescription !== null) {
                    port.description = newDescription;
                    displayPortComments(group);
                    mainLayer.draw();
                }
            });
        });

        // 3. ‚úÖ MOSTRAR los comentarios guardados en el JSON
        displayPortComments(group);
    });

    // Reconectar eventos de los bloques de cables
    mainLayer.find('.cable_block').forEach(blockGroup => {
        blockGroup.draggable(true);
        blockGroup.off('dragmove transform');
        blockGroup.on('dragmove transform', () => {
            blockGroup.find('.cable').forEach(singleCable => {
                updateConnectedLines(singleCable);
            });
        });
    });

    // Reconectar eventos generales del stage
    stage.off('click tap');
    stage.on('click tap', (e) => {
        if (currentMode === 'select') {
            handleSelection(e);
        } else {
            handleLineDrawing(e);
        }
    });

    console.log("üîó Eventos reconectados correctamente. Total de conectores:", window.connectors.length);
}



 

            // =========================================================================
            // === BOT√ìN GUARDAR MEJORADO ==============================================
            // =========================================================================
            saveCanvasBtn.addEventListener('click', () => {
                // Ocultar herramientas antes de guardar
                transformer.nodes([]);
                snapIndicator.hide();
                mainLayer.draw();

                // Verificar que hay contenido
                const elementos = mainLayer.find('.cable, .splitter, .connector');
                if (elementos.length === 0) {
                    alert("No hay nada en el lienzo para guardar.");
                    return;
                }

                // Verificar datos del mapa
                if (!selectedMapElementData) {
                    alert("Error: No se ha seleccionado ning√∫n elemento del mapa. Cierra esta ventana y haz clic en una caja en el mapa primero.");
                    return;
                }

                // Generar datos completos
                const datosCompletos = generarDatosCompletos();

                // Preparar payload para el servidor
                const payload = {
                    DrawingId: selectedMapElementData.DrawingId,
                    ElementProjectId: selectedMapElementData.databaseId,
                    ProjectId: currentProjectId,
                    JsonContent: datosCompletos.jsonContent,
                    SvgContent: datosCompletos.svgContent
                };

                console.log("üì§ Enviando datos al servidor...", payload);

                // Enviar al servidor
                $.ajax({
                    url: '/Project/Save',
                    type: 'POST',
                    contentType: 'application/json; charset=utf-8',
                    dataType: 'json',
                    data: JSON.stringify(payload),

                    success: function (response) {
                        console.log('‚úÖ Guardado exitoso:', response.message);
                        alert(`¬°Dibujo guardado con √©xito! ID: ${response.message}`);
                        //window.location.reload(); // Recarga la p√°gina para reflejar cambios
                        window.location = '/Project';

                    },

                    error: function (xhr, status, error) {
                        console.error('‚ùå Error al guardar:', { status, error, response: xhr.responseText });
                        alert(`Error al guardar: ${xhr.responseText || error}`);
                    }
                });
            });

            // --- 5. L√ìGICA DE TECLAS Y BOTONES ---
            clearCanvasBtn.addEventListener('click', () => {
                limpiarLienzoKonva();
            });

        

             function limpiarLienzoKonva() {
             // 1. Desvinculamos el transformer actual para evitar errores
                transformer.nodes([]);

             // 2. Destruimos todos los hijos de la capa de forma segura
                mainLayer.destroyChildren();

                // ‚úÖ L√çNEA A√ëADIDA: Nos aseguramos de eliminar tambi√©n la imagen
               const refImage = mainLayer.findOne('#referenceImage');
                if (refImage) {
                  refImage.destroy();
               }

              // ===================================================================
              // === ESTA ES LA CORRECCI√ìN CLAVE ===================================
              // ===================================================================
              // 3. ¬°VOLVEMOS A CREAR EL TRANSFORMER DESDE CERO!
              //    Esto nos da una instancia nueva y "sana" en lugar de usar
              //    la referencia al objeto que fue destruido.
              transformer = new Konva.Transformer({
              borderStroke: 'blue',
              borderDash: [6, 2],
              rotateEnabled: true,
              anchorSize: 8,
              name: 'tool_transformer' // Es importante mantener el nombre
             });
        // ===================================================================

             // 4. A√±adimos las herramientas (el nuevo transformer y el snapIndicator) a la capa vac√≠a
                mainLayer.add(transformer, snapIndicator);

             // 5. Limpiamos nuestras variables de JavaScript
               templateCableGroup = null;
               window.connectors = [];

             // 6. Redibujamos la capa
               mainLayer.draw();

              console.log("üßπ Lienzo completamente limpiado y reinicializado con un nuevo transformer.");
          }

window.addEventListener('keydown', (e) => {
    if (e.key === 'Delete' || e.key === 'Backspace') {
        const selectedNodes = transformer.nodes();
        if (selectedNodes.length === 0) return;

        // 1. Desvinculamos el transformer INMEDIATAMENTE.
        //    Esto es crucial para prevenir que Konva intente operar sobre nodos que vamos a destruir.
        transformer.nodes([]);

        // 2. Destruimos los objetos que el usuario seleccion√≥.
        selectedNodes.forEach(node => {
            // Si el nodo es un cable o splitter, tambi√©n debemos destruir las l√≠neas conectadas a √©l.
            if (node.hasName('cable') || node.hasName('splitter')) {
                const idToDelete = node.id();
                // Usamos un bucle inverso para borrar de forma segura mientras iteramos.
                const connectors = mainLayer.find('.connector');
                for (let i = connectors.length - 1; i >= 0; i--) {
                    const line = connectors[i];
                    if (line.attrs.cableAId === idToDelete || line.attrs.cableBId === idToDelete) {
                        if (line.attrs.handle) {
                            line.attrs.handle.destroy();
                        }
                        line.destroy();
                    }
                }
            }
            
            // Si el propio nodo seleccionado era una l√≠nea, destruimos su manejador.
            if (node.hasName('connector') && node.attrs.handle) {
                node.attrs.handle.destroy();
            }

            // Finalmente, destruimos el propio nodo seleccionado.
            node.destroy();
        });

        // ===================================================================
        // === LA CLAVE DE LA ESTABILIDAD: RECONSTRUIR, NO FILTRAR ===========
        // ===================================================================
        // 3. Despu√©s de que toda la destrucci√≥n visual ha terminado, reconstruimos nuestro
        //    array de datos desde la √∫nica "fuente de verdad": lo que queda en el lienzo.
        //    Esto es mucho m√°s seguro que intentar filtrar un array potencialmente corrupto.
        //window.connectors = mainLayer.find('.connector').toArray();
        window.connectors = [...mainLayer.find('.connector')];
        // ===================================================================

        // 4. Redibujamos el lienzo para mostrar el estado final.
        mainLayer.draw();

        console.log("üóëÔ∏è Borrado seguro completado. Conectores restantes:", window.connectors.length);
    }

    // ... tu l√≥gica para duplicar con la tecla 'd' no cambia
});



    


            // Cambio de color de l√≠neas seleccionadas
            colorPicker.addEventListener('input', () => {
                const selectedNodes = transformer.nodes();
                if (selectedNodes.length > 0) {
                    selectedNodes.forEach(node => {
                        if (node.getClassName() === 'Line' && node.name() === 'connector') {
                            node.stroke(colorPicker.value);
                        }
                    });
                    mainLayer.draw();
                }
            });

            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('canvas-color-btn')) {
                    const newColor = e.target.dataset.color;
                    const selectedNodes = transformer.nodes();
                    if (selectedNodes.length > 0) {
                        selectedNodes.forEach(node => {
                            if (node.getClassName() === 'Line' && node.name() === 'connector') {
                                node.stroke(newColor);
                            }
                        });
                        mainLayer.draw();
                    }
                }
            });

            window.limpiarLienzoKonvaGlobal = limpiarLienzoKonva;

            console.log("üöÄ Sistema Konva con guardado SVG inicializado correctamente");
        });



function displayImageOnCanvas(imageUrl) {
    // 1. Limpieza: Busca si ya existe un widget y lo elimina.
    //    Cambiamos el ID para referirnos al grupo completo.
    const existingGroup = mainLayer.findOne('#referenceWidget');
    if (existingGroup) {
        existingGroup.destroy();
    }

    // 2. Cargamos la imagen desde la URL del controlador.
    Konva.Image.fromURL(imageUrl, function (konvaImage) {
        // --- Redimensionamiento (sin cambios) ---
        const MAX_SIZE = 200;
        const originalRatio = konvaImage.width() / konvaImage.height();
        let newWidth, newHeight;
        if (originalRatio > 1) { newWidth = MAX_SIZE; newHeight = MAX_SIZE / originalRatio; }
        else { newHeight = MAX_SIZE; newWidth = MAX_SIZE * originalRatio; }
        konvaImage.width(newWidth);
        konvaImage.height(newHeight);
        konvaImage.cornerRadius(4); // Peque√±o detalle: esquinas redondeadas para la imagen.
        konvaImage.setAttrs({ name: 'reference_image_content' });

        // --- Creaci√≥n del GRUPO interactivo con SOMBRA y preparaci√≥n para ANIMACI√ìN ---
        const referenceGroup = new Konva.Group({
            id: 'referenceWidget', // ID para el grupo completo
            draggable: true,
            name: 'reference_image',
            // ‚úÖ SOMBRA PARA EFECTO DE PROFUNDIDAD
            shadowColor: 'black',
            shadowBlur: 10,
            shadowOffset: { x: 5, y: 5 },
            shadowOpacity: 0.5,
            // ‚úÖ PREPARACI√ìN PARA LA ANIMACI√ìN DE ENTRADA
            opacity: 0,
            scaleX: 0.95,
            scaleY: 0.95
        });
        
        referenceGroup.add(konvaImage);

        // --- A√±adimos t√≠tulo y bot√≥n de cerrar (sin cambios) ---
        const titleBackground = new Konva.Rect({ x: 0, y: newHeight, width: newWidth, height: 20, fill: 'black', opacity: 0.7 });
        referenceGroup.add(titleBackground);
        const titleText = new Konva.Text({ x: 5, y: newHeight + 2, text: 'Imagen de Referencia', fontSize: 14, fill: 'white', fontFamily: 'Calibri' });
        referenceGroup.add(titleText);
        const closeButton = new Konva.Text({ x: newWidth - 20, y: 5, text: '‚úñ', fontSize: 18, fill: 'white', stroke: 'black', strokeWidth: 2, padding: 5, name: 'close_button' });
        
        // ‚úÖ EVENTO DE CERRAR CON ANIMACI√ìN DE SALIDA
        closeButton.on('click tap', () => {
            new Konva.Tween({
                node: referenceGroup,
                duration: 0.2,
                opacity: 0,
                scaleX: 0.95,
                scaleY: 0.95,
                easing: Konva.Easings.EaseOut,
                onFinish: () => {
                    referenceGroup.destroy(); // Se destruye al final de la animaci√≥n
                }
            }).play();
        });
        referenceGroup.add(closeButton);

        // --- Posicionamos el grupo (sin cambios) ---
        const padding = 10;
        const xPos = ((-stage.x() + stage.width()) / stage.scaleX()) - newWidth - padding;
        const yPos = (-stage.y() / stage.scaleY()) + padding;
        referenceGroup.position({ x: xPos, y: yPos });

        // --- A√±adimos el grupo a la capa y ejecutamos la animaci√≥n de entrada ---
        mainLayer.add(referenceGroup);
        referenceGroup.moveToTop(); // Lo ponemos encima para que se vean los controles
        
        // ‚úÖ EJECUTAMOS LA ANIMACI√ìN DE ENTRADA
        new Konva.Tween({
            node: referenceGroup,
            duration: 0.3,
            opacity: 1,
            scaleX: 1,
            scaleY: 1,
            easing: Konva.Easings.EaseOut
        }).play();

    }, function() {
        alert("No se pudo cargar la imagen de referencia.");
    });
}




$(document).ready(function () {
    // Este bloque se ejecuta solo cuando el DOM est√° completamente cargado.
    $('#imageUploadInput').on('change', function (e) {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();

            reader.onload = function (event) {
                const base64String = event.target.result.split(',')[1];
                // const mimeType = file.type; // <-- Ya no lo necesitamos si no lo enviamos

                if (!selectedMapElementData || !selectedMapElementData.databaseId) {
                    console.error("Error: No se encontr√≥ el ID del proyecto del elemento. Aseg√∫rate de que se ha hecho clic en un elemento del mapa.");
                    alert("Error: No se pudo encontrar el ID del proyecto para guardar la imagen.");
                    return;
                }
                const elementProjectId = selectedMapElementData.databaseId;

                console.log(`Subiendo imagen para el ID del proyecto: ${elementProjectId}`);
                console.log("Imagen convertida a Base64. Enviando al controlador...");

                $.ajax({
                    url: '/Project/SaveImage',
                    type: 'POST',
                    contentType: 'application/json',
                    data: JSON.stringify({
                        base64Image: base64String,
                        // mimeType: mimeType, // <-- ¬°Eliminado de aqu√≠!
                        elementProjectId: elementProjectId
                    }),
                    success: function (response) {
                        console.log('¬°Imagen subida con √©xito!');
                        console.log('Respuesta del servidor:', response.message);
                        alert(response.message);
                         if(response.redirectToUrl)
                         {
                          console.log("Redirigiendo a:", response.redirectToUrl);
                             window.location.href = response.redirectToUrl;

                         }
                    },
                    error: function (xhr, status, error) {
                        console.error('Error al subir la imagen:', error);
                        alert('Hubo un error al subir la imagen. Por favor, int√©ntalo de nuevo.');
                    }
                });
            };

            reader.readAsDataURL(file);
        }
    });

      
      $('#viewSavedImageBtn').on('click', function() {
          // 1. Validamos que tengamos un elemento del mapa seleccionado
          if (!selectedMapElementData || !selectedMapElementData.databaseId) {
             alert('Error: Para ver la imagen, primero debes seleccionar un elemento en el mapa.');
             return;
            }

            const elementId = selectedMapElementData.databaseId;
            const imageUrl = `/Project/GetImage/${elementId}`;

            // 2. Llamamos a nuestra nueva funci√≥n para que la ponga en el lienzo
            displayImageOnCanvas(imageUrl);
        });

});

  


    </script>

    @* Carga la API de Google Maps. ¬°Aseg√∫rate de que 'libraries=drawing' est√© presente! *
   Reemplaza 'AIzaSyDp_qGGShO7CvdR5zFiH7KT4Mk3eGZO6VY' con tu CLAVE DE API real. *@
    <script async defer
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDp_qGGShO7CvdR5zFiH7KT4Mk3eGZO6VY&callback=initMap&v=weekly&solution_channel=GMP_CCS_simplepolygon_v2&libraries=geometry,drawing">
        </script>
}