@model GoogleRuta.ViewModels.DiseÃ±oViewModel
@using System.Text.Json

@{
    ViewData["Title"] = "DiseÃ±ar Proyecto";
    Layout = "~/Views/Shared/_Layout.cshtml";

    //var initialLat = ViewData["InitialLat"] as double?;
    //var initialLng = ViewData["InitialLng"] as double?;


    var processedCoordsJson = TempData["ProcessedCoordinatess"] as string ?? "[]";
    var projectId = TempData["ProjectId"] as int?;
    var nameTemp = TempData["Name"] as string;

    //color desde el backend
    //tomo cada objeto de la lista , extraigo solo el codigo del color
    //creo un list de string osea un array de string para pasarlo a javascrip
    var colorList = (Model.ColorTraces != null && Model.ColorTraces.Any())
    ? Model.ColorTraces.Select(c => c.Color).ToList()
    : new List<string> { "#FF0000", "#00FF00", "#0000FF" };
}

<style>
    /* 1. Define nuestra clase personalizada para el modal-dialog */
    .modal-dialog.modal-fullscreen-bs4 {
        width: 100%;
        max-width: none;
        /* Anula el max-width de Bootstrap 4 */
        height: 100%;
        margin: 0;
    }

    /* 2. Asegura que el contenido del modal llene el dialog */
    .modal-dialog.modal-fullscreen-bs4 .modal-content {
        height: 100%;
        border-radius: 0;
        /* Opcional: quita los bordes redondeados en pantalla completa */
        border: none;
        display: flex;
        /* Â¡Clave! Usa Flexbox para distribuir el espacio */
        flex-direction: column;
    }

    /* 3. Â¡LA MAGIA! Fuerza al modal-body a estirarse */
    .modal-dialog.modal-fullscreen-bs4 .modal-body {
        flex-grow: 1;
        /* Permite que el cuerpo crezca y ocupe el espacio sobrante */
        overflow-y: auto;
        /* AÃ±ade scroll si el contenido se desborda */
        display: flex;
        flex-direction: column;
    }

    /* 4. Y que el contenedor de Konva llene el modal-body */
    .modal-dialog.modal-fullscreen-bs4 #konva-container {
        flex-grow: 1;
        /* Ocupa todo el espacio disponible en el body */
    }
</style>

@* Este es el contenido de tu vista que se renderizarÃ¡ dentro de _Layout.cshtml *@

<div class="container-fluid" style="height: calc(100vh - 100px);"> @* Ajusta la altura del contenedor principal de tu vista *@
    <h2 class="mt-3">Dashboard</h2>

    <div id="map" style="height: 100%; width: 100%;"></div>
    <button id="saveCoordsBtn" class="btn btn-primary mt-3">Guardar</button>

</div>

<div class="modal fade" id="elementModal" tabindex="-1" aria-labelledby="elementModalLabel" aria-hidden="true">
    <!-- 1. Modal extra grande con la clase "modal-xl" -->
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="elementModalLabel">Lienzo de DiseÃ±o Profesional</h5>

                <!-- Controles de dibujo se mantienen en la cabecera -->
                <div class="ms-auto d-flex align-items-center">
                    <label for="colorPicker" class="form-label mb-0 me-2 small">Color:</label>
                    <input type="color" class="form-control form-control-sm me-3" id="colorPicker" value="#000000"
                        style="width: 50px;">

                    <label for="brushSize" class="form-label mb-0 me-2 small">Grosor:</label>
                    <input type="range" class="form-range me-3" id="brushSize" min="1" max="10" value="2"
                        style="width: 100px;">

                    <button id="clearCanvasBtn" class="btn btn-sm btn-outline-danger">Limpiar Todo</button>

                    <!-- âœ… BotÃ³n maximizar mejorado -->
                    <button type="button" class="btn btn-sm btn-outline-secondary me-2" id="toggleFullscreenBtn"
                        title="Maximizar pantalla completa">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                            class="bi bi-arrows-fullscreen" viewBox="0 0 16 16">
                            <path fill-rule="evenodd"
                                d="M5.828 10.172a.5.5 0 0 0-.707 0L2 13.293V11.5a.5.5 0 0 0-1 0v3a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 0-1H2.707l3.121-3.121a.5.5 0 0 0 0-.707zM10.172 5.828a.5.5 0 0 0 .707 0L14 2.707V4.5a.5.5 0 0 0 1 0v-3a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0 0 1h1.793L10.172 5.121a.5.5 0 0 0 0 .707z" />
                        </svg>
                    </button>


                </div>

                <!-- 4. BotÃ³n de cierre estÃ¡ndar en la cabecera -->
                <button type="button" class="btn-close ms-3" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>

            <!-- 3. Cuerpo del modal con fondo gris claro para resaltar el lienzo -->
            <div class="modal-body p-2" style="background-color: #f8f9fa; text-align: center;">

                <!-- Barra de herramientas (sin cambios) -->
                <div id="toolbar"
                    class="mb-2 p-2 rounded d-flex justify-content-center align-items-center bg-light border-bottom">
                    <div class="me-3 border-end pe-3">
                        <span class="me-2 small">MODO:</span>
                        <button id="selectModeBtn" class="btn btn-sm btn-primary"
                            title="Modo SelecciÃ³n (Mover, Seleccionar, Borrar)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                                class="bi bi-cursor-fill" viewBox="0 0 16 16">
                                <path
                                    d="M14.082 2.182a.5.5 0 0 1 .103.557L8.528 15.467a.5.5 0 0 1-.917-.007L5.57 10.694.803 8.652a.5.5 0 0 1-.006-.916l12.728-5.657a.5.5 0 0 1 .556.103z" />
                            </svg>
                        </button>
                        <button id="drawModeBtn" class="btn btn-sm btn-outline-secondary"
                            title="Modo Conector (Dibujar LÃ­neas)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                                class="bi bi-slash-lg" viewBox="0 0 16 16">
                                <path fill-rule="evenodd"
                                    d="M13.854 2.146a.5.5 0 0 1 0 .708l-11 11a.5.5 0 0 1-.708-.708l11-11a.5.5 0 0 1 .708 0z" />
                            </svg>
                        </button>
                    </div>
                    <div id="componentGeneratorControls" class="d-flex align-items-center">
                        <div class="me-3"><span class="me-2 small">CABLE:</span>
                            <button class="btn btn-sm btn-outline-primary" data-strands="5">1x5</button>
                            <button class="btn btn-sm btn-outline-primary" data-strands="8">1x8</button>
                            <button class="btn btn-sm btn-outline-primary" data-strands="12">1x12</button>
                        </div>
                        <div><span class="me-2 small">SPLITTER:</span>
                            <button class="btn btn-sm btn-outline-success" data-splitter-out="4">1x4</button>
                            <button class="btn btn-sm btn-outline-success" data-splitter-out="8">1x8</button>
                            <button class="btn btn-sm btn-outline-success" data-splitter-out="16">1x16</button>
                        </div>
                    </div>
                </div>

                <!-- 2. Contenedor del lienzo con fondo de cuadrÃ­cula  inline-block; -->
                <div id="konva-container" style="
                    border: 1px solid #ccc;
                    inline-block;
                    background-color: #ffffff;
                    background-image:
                        linear-gradient(#e0e0e0 1px, transparent 1px),
                        linear-gradient(90deg, #e0e0e0 1px, transparent 1px);
                    background-size: 20px 20px;">
                </div>

            </div>
            <div class="modal-footer">
                <!-- Se puede simplificar, ya que el cierre principal estÃ¡ en la cabecera -->
                <button type="button" id="saveCanvasBtn" class="btn btn-primary">Guardar DiseÃ±o</button>
            </div>
        </div>
    </div>
</div>


@* <script src="https://unpkg.com/konva@9.3.0/konva.min.js"></script> *@
<script src="https://cdn.jsdelivr.net/npm/konva@9/konva.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/konva-svg-export@1.0.0/konva-svg-export.min.js"></script>


@section Scripts {

    <style>
        /* Estilos para el botÃ³n activo. Da feedback visual al usuario. */
        .custom-element-button.active {
            background-color: #e0e0e0 !important;
            border: 1px solid #3385ff !important;
        }

        /* NUEVOS ESTILOS PARA LOS BOTONES DE COLORES */
        .custom-color-button.active {
            border: 2px solid #3385ff !important;
            box-shadow: 0 0 3px rgba(51, 133, 255, 0.5) !important;
        }

        .custom-color-button:hover {
            transform: scale(1.1);
            transition: transform 0.1s ease;
        }

        .canvas-color-btn.active-canvas-color {
            border: 2px solid #007bff !important;
            box-shadow: 0 0 3px rgba(0, 123, 255, 0.5) !important;
        }

        .canvas-color-btn:hover {
            transform: scale(1.05);
            transition: transform 0.1s ease;
        }
    </style>

    <script>


        // âœ… NUEVO: Funciones para controlar el tamaÃ±o del modal
        function maximizarModal() {
            const modalDialog = document.querySelector('#elementModal .modal-dialog');
            // Nos aseguramos de que estÃ© en modo maximizado
            if (!modalDialog.classList.contains('modal-fullscreen-bs4')) {
                modalDialog.classList.add('modal-fullscreen-bs4');
                modalDialog.classList.remove('modal-xl');
                // Esperamos la animaciÃ³n CSS antes de redimensionar el lienzo
                setTimeout(() => {
                    if (window.resizeCanvasToContainer) { // Verificamos si la funciÃ³n existe
                        window.resizeCanvasToContainer();
                    }
                }, 250);
            }
        }

        function resetModalSize() {
            const modalDialog = document.querySelector('#elementModal .modal-dialog');
            // Nos aseguramos de que estÃ© en modo normal (xl)
            if (modalDialog.classList.contains('modal-fullscreen-bs4')) {
                modalDialog.classList.remove('modal-fullscreen-bs4');
                modalDialog.classList.add('modal-xl');
                // Esperamos la animaciÃ³n CSS antes de redimensionar el lienzo
                setTimeout(() => {
                    if (window.resizeCanvasToContainer) {
                        window.resizeCanvasToContainer();
                    }
                }, 250);
            }
        }
        //variable para rastrear la polilÃ­nea seleccionada
        let selectedPolyline = null;

        let isUpdateScheduled = false;

        var nameJs = '@(nameTemp ?? "")';
        console.log("ver name ", nameJs);

        const currentProjectId = @(projectId.HasValue? projectId.Value.ToString() : "null");
        console.log("ID del proyecto disponible en JS:", currentProjectId);

        @{
                // Usamos LINQ para crear una nueva lista de objetos anÃ³nimos.
                // Para cada elemento, copiamos sus propiedades y transformamos 'iconUrl'
                // usando Url.Content() para generar una ruta vÃ¡lida para el navegador.
                var elementTypesForJs = Model.ElementTypes.Select(e => new
                {
                    id = e.Id,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   name = e.Name,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   iconUrl = Url.Content(e.IconoUrl) // <-- Â¡Esta es la correcciÃ³n!
                });
            }

                                                                                                                                                                                                                                                         // Ahora serializamos la nueva lista con las URLs corregidas.
                                                                                                                                                                                                                                                         const elementTypes = @Html.Raw(Json.Serialize(elementTypesForJs));
        console.log("Tipos de Elementos (con URLs corregidas):", elementTypes);

        //traer la lista de colores desde el contrrolador
        const availableColors =@Html.Raw(JsonSerializer.Serialize(colorList));
        console.log("ðŸŽ¨ Colores disponibles:", availableColors);
        const availableColorsComplete = @Html.Raw(JsonSerializer.Serialize(Model.ColorTraces ?? new List<ColorTraces>()));
        console.log("ðŸŽ¨ Colores disponibles:", availableColorsComplete);

        // El problema: existingElements es un STRING, no un Array.
        // La SoluciÃ³n: Convertimos (parseamos) el string a un Array de JavaScript real.
        // ======================================================================
        const existingElements = @Html.Raw(TempData["ExistingPlacedElements"] as string ?? "[]");
        console.log("ver elementos llegando a la vista diseÃ±o (YA PARSEADO):", existingElements);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                @*const existingElementsJson = '@Html.Raw(TempData["ExistingPlacedElements"] as string ?? "[]")';
        const existingElements = JSON.parse(existingElementsJson);
        console.log("ver elementos llegando a la vista diseÃ±o (YA PARSEADO):", existingElements); *@

            let currentPolygon = null;
        let currentPolyLine = null;
        let currentPolygonCoords = [];
        let currentPolylineCoords = [];

        // AquÃ­ guardaremos todos los elementos (postes, cajas, etc.) que el usuario coloque.
        let placedElements = [];
        //Variable para gestionar el listener del mapa ---
        let mapClickListener = null;
        // Agregamos una variable para guardar el tipo de elemento activo
        let activeElementType = null;
        //tomo los datos del elemento para enviarlo al controlador dibujo
        let selectedMapElementData = null;

        function initMap() {
            let center;
            // Procesar coordenadas de la base de datos con validaciÃ³n
            const rawCoords = JSON.parse(@Html.Raw(JsonSerializer.Serialize(processedCoordsJson)));
            const processedCoords = rawCoords.map(coord => ({
                lat: parseFloat(coord.lat || coord.Lat || 0),
                lng: parseFloat(coord.lng || coord.Lng || 0)
            })).filter(coord =>
                !isNaN(coord.lat) && !isNaN(coord.lng) &&
                isFinite(coord.lat) && isFinite(coord.lng)
            );

            console.log("coordenadas procesadas", processedCoords)
            console.log("ver lista pintar", processedCoords)

            const mapCenterLat = parseFloat('@(Model.InitialLat.HasValue? Model.InitialLat.Value.ToString(System.Globalization.CultureInfo.InvariantCulture) : "-13.44255087")');
            const mapCenterLng = parseFloat('@(Model.InitialLng.HasValue? Model.InitialLng.Value.ToString(System.Globalization.CultureInfo.InvariantCulture) : "-76.1470107")');

            if (processedCoords.length > 0) {
                center = { lat: processedCoords[0].lat, lng: processedCoords[0].lng };

            }
            else {
                center = { lat: mapCenterLat, lng: mapCenterLng };
            }

            const map = new google.maps.Map(document.getElementById("map"), {
                zoom: 12,
                center: center,
                mapTypeId: "terrain",
                mapTypeControl: true,
                streetViewControl: true,
                fullscreenControl: true
            });

            if (processedCoords.length > 0) {
                const path = processedCoords.map(p => ({ lat: p.lat, lng: p.lng }));

                const polyline = new google.maps.Polyline({
                    path: path,
                    map: map,
                    strokeColor: '#0000FF',
                    strokeOpacity: 0.8,
                    strokeWeight: 3,
                    clickable: true,
                    editable: true,
                    zIndex: 1,
                });

                currentPolyLine = polyline;
                setPolylineListeners(currentPolyLine);
                selectedPolyline = currentPolyLine;
                currentPolyLine.setOptions({
                    strokeWeight: 5,
                    strokeOpacity: 1.0
                });
                console.log('LÃ­nea inicial auto-seleccionada');
                updatePolylineCoords(currentPolyLine);
            } else {
                new google.maps.Marker({
                    position: center,
                    map: map,
                    title: "UbicaciÃ³n inicial"
                });
            }


            //Dibujar los elementos(cajas,postes etc al cargar)
            if (existingElements.length > 0) {
                console.log(`Cargando ${existingElements.length} elementos existentes.`);

                existingElements.forEach(element => {
                    // Buscamos el tipo de elemento completo para obtener su URL de icono
                    const elementType = elementTypes.find(t => t.id === element.ElementTypeId);
                    if (elementType) {
                        const location = { lat: element.Lat, lng: element.Lng };
                        console.log("Encontrado tipo de elemento, dibujando marcador en:", location);
                        // Reutilizamos la funciÃ³n que ya tienes para colocar marcadores
                        placeMarker(location, elementType, map, element);
                    }
                });

            }

            // --- FUNCIÃ“N DE LISTENERS MEJORADA CON BORRADO MANUAL ---
            function setPolylineListeners(polyline) {
                // Listeners para arrastrar y aÃ±adir puntos (estos suelen funcionar bien)
                google.maps.event.addListener(polyline.getPath(), 'set_at', () => updatePolylineCoords(polyline));
                google.maps.event.addListener(polyline.getPath(), 'insert_at', () => updatePolylineCoords(polyline));

                // Listener para el evento de borrado que ya tenÃ­as (lo dejamos como respaldo)
                google.maps.event.addListener(polyline.getPath(), 'remove_at', () => updatePolylineCoords(polyline));

                // *** LISTENER CLAVE PARA EL BORRADO MANUAL POR CLIC DERECHO ***
                google.maps.event.addListener(polyline, 'rightclick', function (event) {
                    // El evento 'rightclick' nos da informaciÃ³n sobre dÃ³nde se hizo clic.
                    // 'event.vertex' nos dirÃ¡ el Ã­ndice del vÃ©rtice si se hizo clic en uno.
                    if (event.vertex !== undefined && event.vertex !== null) {
                        console.log(`Clic derecho detectado en el vÃ©rtice: ${event.vertex}`);

                        // Obtenemos el path (la ruta) de la polilÃ­nea.
                        const path = polyline.getPath();

                        // Eliminamos el vÃ©rtice en ese Ã­ndice.
                        path.removeAt(event.vertex);

                        // Nota: No es necesario llamar a updatePolylineCoords aquÃ­, porque
                        // removeAt dispara automÃ¡ticamente el evento 'remove_at' que ya estamos escuchando.
                    }
                });

                // NUEVO: Listener para seleccionar la polilÃ­nea con clic izquierdo
                google.maps.event.addListener(polyline, 'click', function () {
                    // Resetear el estilo de la polilÃ­nea anteriormente seleccionada
                    if (selectedPolyline && selectedPolyline !== polyline) {
                        selectedPolyline.setOptions({
                            strokeWeight: 3,
                            strokeOpacity: 0.8
                        });
                    }

                    // Marcar esta polilÃ­nea como seleccionada
                    selectedPolyline = polyline;

                    // Cambiar el estilo para indicar que estÃ¡ seleccionada
                    polyline.setOptions({
                        strokeWeight: 5,  // MÃ¡s gruesa
                        strokeOpacity: 1.0 // MÃ¡s opaca
                    });

                    console.log('PolilÃ­nea seleccionada');
                });

            }

            function setPolygonListeners(polygon) {
                google.maps.event.addListener(polygon.getPath(), 'set_at', () => updatePolygonCoords(polygon));
                google.maps.event.addListener(polygon.getPath(), 'insert_at', () => updatePolygonCoords(polygon));
                google.maps.event.addListener(polygon.getPath(), 'remove_at', () => updatePolygonCoords(polygon));
            }

            const drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: google.maps.drawing.OverlayType.POLYLINE,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.POLYLINE,
                        google.maps.drawing.OverlayType.MARKER
                    ],
                },
                polygonOptions: {
                    fillColor: '#AA0000', fillOpacity: 0.3, strokeWeight: 2,
                    strokeColor: '#FF0000', clickable: true, editable: true, zIndex: 1,
                },
                polylineOptions: {
                    strokeColor: '#0000FF', strokeOpacity: 0.8, strokeWeight: 3,
                    clickable: true, editable: true, zIndex: 1,
                }
            });

            drawingManager.setMap(map);

            google.maps.event.addListener(drawingManager, 'overlaycomplete', function (event) {
                // Si se completa un dibujo de Google, nos aseguramos de que ninguno de nuestros botones estÃ© activo.
                deactivateCustomButtons();
                if (event.type == google.maps.drawing.OverlayType.POLYGON) {
                    if (currentPolyLine) {
                        google.maps.event.clearInstanceListeners(currentPolyLine.getPath());
                        google.maps.event.clearInstanceListeners(currentPolyLine);
                        currentPolyLine.setMap(null);
                        currentPolyLine = null;
                        currentPolylineCoords = [];
                    }
                    if (currentPolygon) {
                        google.maps.event.clearInstanceListeners(currentPolygon.getPath());
                        google.maps.event.clearInstanceListeners(currentPolygon);
                        currentPolygon.setMap(null);
                    }
                    currentPolygon = event.overlay;
                    setPolygonListeners(currentPolygon);
                    updatePolygonCoords(currentPolygon);
                    drawingManager.setDrawingMode(null);

                } else if (event.type == google.maps.drawing.OverlayType.POLYLINE) {

                    if (currentPolygon) {
                        google.maps.event.clearInstanceListeners(currentPolygon.getPath());
                        google.maps.event.clearInstanceListeners(currentPolygon);
                        currentPolygon.setMap(null);
                        currentPolygon = null;
                        currentPolygonCoords = [];
                    }

                    const newPolylineSegment = event.overlay;
                    let combinedPath = [];

                    if (currentPolyLine) {
                        google.maps.event.clearInstanceListeners(currentPolyLine.getPath());
                        google.maps.event.clearInstanceListeners(currentPolyLine);
                        combinedPath = currentPolyLine.getPath().getArray();
                        currentPolyLine.setMap(null);
                    }

                    combinedPath = combinedPath.concat(newPolylineSegment.getPath().getArray());
                    newPolylineSegment.setMap(null);

                    const newCombinedPolyline = new google.maps.Polyline({
                        path: combinedPath, map: map,
                        strokeColor: '#0000FF', strokeOpacity: 0.8, strokeWeight: 3,
                        clickable: true, editable: true, zIndex: 1,
                    });

                    currentPolyLine = newCombinedPolyline;
                    setPolylineListeners(currentPolyLine);
                    updatePolylineCoords(currentPolyLine);
                    // 
                    selectedPolyline = newCombinedPolyline;
                    newCombinedPolyline.setOptions({
                        strokeWeight: 5,
                        strokeOpacity: 1.0
                    });
                    console.log('Nueva lÃ­nea combinada auto-seleccionada');
                    drawingManager.setDrawingMode(null);
                }
            });

            function updatePolygonCoords(polygon) {
                const path = polygon.getPath();
                currentPolygonCoords = [];
                path.getArray().forEach(function (latLng) {
                    currentPolygonCoords.push({ lat: latLng.lat(), lng: latLng.lng() });
                });
                console.log("Coordenadas del polÃ­gono actualizadas:", currentPolygonCoords);
            }

            function updatePolylineCoords(polyline) {
                const path = polyline.getPath();
                currentPolylineCoords = [];
                path.getArray().forEach(function (latLng) {
                    currentPolylineCoords.push({ lat: latLng.lat(), lng: latLng.lng() });
                });
                console.log("Coordenadas de la polilÃ­nea actualizadas:", currentPolylineCoords);
            }

            //NUEVO CÃ“DIGO: AÃ‘ADIR CONTROLES PERSONALIZADOS PARA ELEMENTOS ---
            // Le pasamos el 'drawingManager' para poder controlarlo
            createCustomElementControls(map, drawingManager);
            createCustomColorControls(map, drawingManager);

        }

        //variable selectedColor asignado a null
        let selectedColor = null;


        function createCustomColorControls(map, drawingManager) {
            // 1. Crea un contenedor para los botones de colores
            const colorToolbar = document.createElement('div');

            colorToolbar.style.margin = '8px';
            colorToolbar.style.display = 'flex';
            colorToolbar.style.gap = '2px';
            colorToolbar.style.backgroundColor = 'white';
            colorToolbar.style.padding = '3px';
            colorToolbar.style.borderRadius = '2px';
            colorToolbar.style.boxShadow = 'rgba(0, 0, 0, 0.3) 0px 1px 4px -1px';
            colorToolbar.id = 'customColorToolbar';

            // 2. Itera sobre los colores disponibles para crear un botÃ³n para cada uno
            availableColorsComplete.forEach(colorObject => {
                const button = document.createElement('button');
                button.className = 'custom-color-button'; // Clase para aplicar estilos

                button.style.backgroundColor = colorObject.Color; // El color de fondo es el color real
                button.style.border = '2px solid #ccc';
                button.style.width = '24px';
                button.style.height = '24px';
                button.style.borderRadius = '4px';
                button.style.cursor = 'pointer';
                button.style.margin = '1px';
                button.title = `Nombre: ${colorObject.name} - Color: ${colorObject.Color}`; // Mostramos mÃ¡s informaciÃ³n en el tooltip (tÃ­tulo)

                // Efecto hover
                button.addEventListener('mouseenter', () => {
                    if (!button.classList.contains('active')) {
                        button.style.border = '2px solid #666';
                    }
                });

                button.addEventListener('mouseleave', () => {
                    if (!button.classList.contains('active')) {
                        button.style.border = '2px solid #ccc';
                    }
                });

                // Evento de clic para seleccionar el color
                button.addEventListener('click', () => {
                    // Verificar si hay una polilÃ­nea seleccionada
                    if (!selectedPolyline) {
                        alert('Por favor, selecciona una lÃ­nea primero haciendo clic en ella');
                        return;
                    }
                    // 1. Desactivamos todos los otros botones de color
                    deactivateColorButtons();

                    // 2. Activamos ESTE botÃ³n
                    button.classList.add('active');
                    button.style.border = '2px solid #3385ff';
                    button.style.boxShadow = '0 0 3px rgba(51, 133, 255, 0.5)';

                    // 3. Guardamos el OBJETO COMPLETO del color seleccionado
                    selectedColor = colorObject;

                    console.log("ðŸŽ¨ Color seleccionado:", selectedColor);
                    //Solo cambiar el color de la polilÃ­nea SELECCIONADA
                    selectedPolyline.setOptions({ strokeColor: selectedColor.Color });

                    // 4. AquÃ­ puedes agregar lÃ³gica adicional, como cambiar el color de las lÃ­neas futuras
                    // Por ejemplo, si tienes un drawingManager:
                    // drawingManager.setOptions({
                    //     polylineOptions: {
                    //         ...drawingManager.get('polylineOptions'),
                    //         strokeColor: color
                    //     }
                    // });
                    //NUEVA FUNCIONALIDAD: Cambiamos el color de las futuras polilÃ­neas
                    drawingManager.setOptions({
                        polylineOptions: {
                            strokeColor: selectedColor.Color // Usamos la propiedad .Color
                        }
                    });

                });

                colorToolbar.appendChild(button);
            });

            // 3. AÃ±ade la barra de colores al mapa (puedes cambiar la posiciÃ³n segÃºn prefieras)
            map.controls[google.maps.ControlPosition.TOP_RIGHT].push(colorToolbar);
        }
        // FunciÃ³n para desactivar todos los botones de color
        function deactivateColorButtons() {
            document.querySelectorAll('#customColorToolbar .custom-color-button').forEach(button => {
                button.classList.remove('active');
                button.style.border = '2px solid #ccc';
                button.style.boxShadow = 'none';
            });
        }

        // FunciÃ³n mejorada para obtener el color seleccionado (ahora devuelve solo el string del color)
        function getSelectedColor() {
            // Si un objeto de color estÃ¡ seleccionado, devuelve su propiedad .Color.
            // Si no, devuelve el primer color del array de strings como predeterminado.
            return selectedColor ? selectedColor.Color : availableColors[0];
        }



        //FUNCIÃ“N ACTUALIZADA: Crea los botones y gestiona el estado activo.

        function createCustomElementControls(map, drawingManager) {
            // 1. Crea un contenedor para nuestros botones.
            const toolbar = document.createElement('div');

            toolbar.style.margin = '8px'; // Espacio respecto a los controles de Google
            toolbar.style.display = 'flex';
            toolbar.style.gap = '2px';
            toolbar.style.backgroundColor = 'white';
            toolbar.style.padding = '3px';
            toolbar.style.borderRadius = '2px';
            toolbar.style.boxShadow = 'rgba(0, 0, 0, 0.3) 0px 1px 4px -1px';
            toolbar.id = 'customToolbar'; // Le damos un ID para encontrarlo despuÃ©s

            // 2. Itera sobre tus tipos de elementos para crear un botÃ³n para cada uno.
            elementTypes.forEach(elementType => {
                const button = document.createElement('button');
                button.className = 'custom-element-button'; // Clase para aplicar estilos

                button.style.backgroundColor = 'white';
                button.style.border = 'none';
                button.style.padding = '5px';
                button.style.cursor = 'pointer';
                button.title = elementType.name;
                button.innerHTML = `<img src="${elementType.iconUrl}" style="width:18px; height:18px;">`;

                button.addEventListener('click', () => {
                    // 1. Desactivamos cualquier herramienta de Google y otros botones personalizados
                    deactivateCustomButtons();
                    drawingManager.setDrawingMode(null);

                    // 2. Activamos ESTE botÃ³n
                    button.classList.add('active');
                    map.setOptions({ draggableCursor: 'crosshair' });

                    // 3. Establecemos el tipo de elemento activo
                    activeElementType = elementType;

                    // 4. Agregamos el listener de clic en el mapa para colocar elementos,
                    // pero esta vez es un addListener normal, no once.
                    // Â¡Esto nos permite colocar mÃºltiples elementos!
                    if (mapClickListener) {
                        google.maps.event.removeListener(mapClickListener);
                    }
                    mapClickListener = google.maps.event.addListener(map, 'click', (event) => {
                        placeMarker(event.latLng, activeElementType, map);
                    });

                    console.log(`Modo de colocaciÃ³n activado para: ${elementType.name}`);
                });

                toolbar.appendChild(button);
            });

            map.controls[google.maps.ControlPosition.TOP_CENTER].push(toolbar);
        }

        function deactivateCustomButtons() {
            document.querySelectorAll('#customToolbar .custom-element-button').forEach(b => {
                b.classList.remove('active');
            });
            if (mapClickListener) {
                google.maps.event.removeListener(mapClickListener);
                mapClickListener = null;
            }
            // Asumiendo que 'map' es accesible globalmente o pasado como parÃ¡metro
            const map = document.getElementById('map').__gmap_instance__;
            if (map) map.setOptions({ draggableCursor: '' });
        }

        function placeMarker(location, elementType, map, element) {
            // 1. Extrae las coordenadas de forma segura (esto ya lo tenÃ­as bien)
            const latitude = typeof location.lat === 'function' ? location.lat() : location.lat;
            const longitude = typeof location.lng === 'function' ? location.lng() : location.lng;

            // 2. Crea el objeto de datos CON un ID Ãºnico para la sesiÃ³n.
            // Usamos Date.now() y un nÃºmero aleatorio para asegurar que sea Ãºnico.
            const elementData = {
                databaseId: element ? element.Id : null,
                DrawingId: element ? element.DrawingId : null,
                internalId: Date.now() + Math.random(), // ID Ãºnico para vincular marcador y datos
                lat: latitude,
                lng: longitude,
                elementTypeId: elementType.id
            };

            // 3. Crea el marcador visual
            const marker = new google.maps.Marker({
                position: { lat: latitude, lng: longitude }, // Es mejor usar el objeto lat/lng aquÃ­
                map: map,
                icon: {
                    url: elementType.iconUrl,
                    scaledSize: new google.maps.Size(32, 32),
                    origin: new google.maps.Point(0, 0),
                    anchor: new google.maps.Point(16, 16)
                }
            });

            // 4. Vincula el marcador con los datos guardando el ID Ãºnico en el propio marcador.
            marker.internalId = elementData.internalId;

            // 5. Â¡LA CLAVE! AÃ±ade el listener de click derecho para la eliminaciÃ³n.
            google.maps.event.addListener(marker, 'rightclick', function () {
                // 'this' dentro de este listener se refiere al marcador que fue clickeado.

                // a) Elimina el marcador visual del mapa.
                this.setMap(null);

                // b) Encuentra y elimina el objeto de datos del array 'placedElements'.
                // Usamos .filter() para crear un nuevo array que excluya el elemento con nuestro ID.
                placedElements = placedElements.filter(el => el.internalId !== this.internalId);

                console.log(`Elemento con ID ${this.internalId} eliminado.`);
                console.log("Estado actual de 'placedElements':", placedElements);
            });



            google.maps.event.addListener(marker, 'click', function () {
                // 1. Obtenemos los datos del elemento del mapa
                selectedMapElementData = placedElements.find(el => el.internalId === this.internalId);
                console.log("Elemento seleccionado:", selectedMapElementData);
                console.log("Dibujo ID:", selectedMapElementData ? selectedMapElementData.DrawingId : "N/A");
                // 2. Preparamos el modal una sola vez
                const elementModal = document.getElementById('elementModal');
                const myModal = new bootstrap.Modal(elementModal);

                // Asignamos el ID por si lo necesitamos
                if (selectedMapElementData) {
                    elementModal.dataset.elementProjectId = selectedMapElementData.databaseId;
                }

                // 3. Verificamos si necesitamos cargar un dibujo existente
                if (selectedMapElementData && selectedMapElementData.DrawingId) {
                    console.log(`Buscando datos del dibujo ID: ${selectedMapElementData.DrawingId}...`);

                    $.ajax({
                        url: `/Project/GetDrawing/${selectedMapElementData.DrawingId}`,
                        type: 'GET',
                        dataType: 'json',
                        success: function (objetoJsonRecibido) {
                            console.log("âœ… Datos recibidos. Preparando para mostrar modal maximizado.");

                            const elementModal = document.getElementById('elementModal');
                            const myModal = new bootstrap.Modal(elementModal); // AsegÃºrate de tener la instancia del modal

                            // USAMOS .one() PARA QUE ESTE EVENTO SÃ“LO SE EJECUTE UNA VEZ POR CADA VEZ QUE SE ABRE EL MODAL.
                            // ESTO ES CRUCIAL PARA EVITAR MÃšLTIPLES CARGAS.
                            $(elementModal).one('shown.bs.modal', function () {
                                console.log("Evento 'shown.bs.modal' disparado. El modal es completamente visible.");

                                // AHORA, y solo ahora que el modal tiene sus dimensiones finales,
                                // cargamos el dibujo en el lienzo.
                                if (window.cargarDesdeJSON) {
                                    window.cargarDesdeJSON(objetoJsonRecibido);
                                } else {
                                    console.error("La funciÃ³n 'cargarDesdeJSON' no estÃ¡ disponible.");
                                    alert("Error: No se pudo encontrar la funciÃ³n para dibujar.");
                                }
                            });

                            // 1. PRIMERO: Llamamos a la funciÃ³n para que AÃ‘ADA las clases de maximizado.
                            // El modal todavÃ­a estÃ¡ oculto, pero cuando se muestre, usarÃ¡ estas clases.
                            maximizarModal();

                            // 2. SEGUNDO: Mostramos el modal.
                            // Esto iniciarÃ¡ la animaciÃ³n de Bootstrap. Cuando termine, se dispararÃ¡ el evento 'shown.bs.modal' que configuramos arriba.
                            myModal.show();
                        },
                        error: function (xhr) {
                            console.error('âŒ Error al obtener los datos del dibujo:', xhr.responseText);
                            alert(`Error al cargar el dibujo. Respuesta: ${xhr.responseText}`);
                            // Opcional: mostrar el modal vacÃ­o incluso si hay un error
                            // myModal.show();
                        }
                    });
                } else {
                    // 5. Si NO hay un dibujo guardado, simplemente limpiamos el lienzo y mostramos el modal vacÃ­o.
                    console.log("No hay dibujo asociado. Mostrando modal limpio.");
                    if (window.limpiarLienzoKonvaGlobal) {
                        window.limpiarLienzoKonvaGlobal();
                    }
                    resetModalSize();
                    myModal.show();
                }
            });


            // 6. AÃ±ade el elemento con su nuevo ID al array que se enviarÃ¡ al guardar.
            placedElements.push(elementData);

            console.log("Elemento colocado/cargado:", elementData);
            console.log("Todos los elementos:", placedElements);

        }

        document.getElementById('saveCoordsBtn').addEventListener('click', function () {
            let dataToSend = null; // Inicializamos a null

            // Verificamos cuÃ¡l arreglo de coordenadas tiene datos
            if (currentPolygonCoords.length > 0) {
                dataToSend = {
                    Name: nameJs,
                    Id: currentProjectId,
                    Type: 'polygon', // AÃºn enviamos el tipo para que el controlador sepa cÃ³mo procesarlo
                    Coordinates: currentPolygonCoords.map(c => [c.lat, c.lng]),
                    PlacedElements: placedElements
                };
                console.log("Enviando coordenadas de polÃ­gono:", dataToSend);
            } else if (currentPolylineCoords.length > 0) {
                dataToSend = {
                    Name: nameJs,
                    Id: currentProjectId,
                    Type: 'polyline', // AÃºn enviamos el tipo
                    Coordinates: currentPolylineCoords.map(c => [c.lat, c.lng]),
                    PlacedElements: placedElements
                };
                console.log("Enviando coordenadas de polilÃ­nea:", dataToSend);
            } else {
                alert("Por favor, dibuja un polÃ­gono o una polilÃ­nea antes de guardar.");
                return; // Detiene la funciÃ³n si no hay nada dibujado
            }

            // Si dataToSend sigue siendo null, significa que no se dibujÃ³ nada vÃ¡lido.
            if (dataToSend === null) {
                alert("No hay una forma vÃ¡lida dibujada para guardar.");
                return;
            }

            console.log("ðŸ“¤ Datos que se van a enviar:", dataToSend);
            console.log("ðŸ“¤ JSON a enviar:", JSON.stringify(dataToSend));

            // EnvÃ­a los datos usando la API Fetch
            fetch('/Project/Coordinate', { // Â¡Importante! Reemplaza con tu controlador y acciÃ³n reales.
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    // 'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value // Si lo usas
                },
                body: JSON.stringify(dataToSend)
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Error HTTP! estado: ${response.status}`);
                    }
                    return response.json(); // Esperamos el JSON { redirectToUrl: '...' }
                })
                .then(data => {
                    // Â¡Ã‰XITO! Ahora redirigimos el navegador a la URL que nos dio el servidor.
                    console.log('Datos guardados. Redirigiendo a:', data.redirectToUrl);
                    window.location.href = data.redirectToUrl;
                })
                .catch((error) => {
                    console.error('Error:', error);
                    alert('Hubo un error al guardar las coordenadas: ' + error.message);
                });

        });




        // Esta lÃ­nea es crucial para que Google Maps sepa quÃ© funciÃ³n llamar una vez que el API estÃ© cargada
        window.initMap = initMap;


        // CÃ³digo de colores estÃ¡ndar TIA-598-C para cables
        const CABLE_COLOR_PALETTES = {
            // Para cables especÃ­ficos de 5 hilos
            5: [
                '#007bff', // 1. Azul
                '#fd7e14', // 2. Naranja
                '#28a745', // 3. Verde
                '#a0522d', // 4. MarrÃ³n
                '#6c757d'  // 5. Gris
            ],
            // CÃ³digo de colores estÃ¡ndar TIA-598-C para 12 fibras. Se usarÃ¡ para cables de 8, 12 y otros tamaÃ±os.
            default: [
                '#007bff', // 1. Azul
                '#fd7e14', // 2. Naranja
                '#28a745', // 3. Verde
                '#a0522d', // 4. MarrÃ³n
                '#6c757d', // 5. Gris (Slate)
                '#D3D3D3', // 6. Gris Claro (en lugar de Blanco)
                '#dc3545', // 7. Rojo
                '#000000', // 8. Negro
                '#ffc107', // 9. Amarillo
                '#8a2be2', // 10. Violeta
                '#e83e8c', // 11. Rosa
                '#17a2b8'  // 12. Aguamarina
            ]
        };

        // =================================================================================
        // =========== INICIO DE LA LÃ“GICA DE KONVA.JS (CON GUARDADO SVG) =================
        // =================================================================================
        let mainLayer;
        let cableCreationCounter = 0;//contador para crear cables en base a logica derecha o izquierda
        document.addEventListener('DOMContentLoaded', function () {

            let nodeIdCounter = 0;
            // --- 1. CONFIGURACIÃ“N INICIAL ---
            @* let stage = new Konva.Stage({ container: 'konva-container', width: 750, height: 500 }); *@

                //funcion central para redimensionar el lienzo de Konva
                function resizeCanvasToContainer() {
                    if (stage && stage.container) {
                        const container = stage.container();
                        const newWidth = container.clientWidth;
                        const newHeight = container.clientHeight;

                        if (newWidth > 0 && newHeight > 0) {
                            stage.width(newWidth);
                            stage.height(newHeight);
                            stage.draw();
                            console.log(`âœ… Lienzo redimensionado a: ${newWidth}x${newHeight}`);
                        }
                    }
                }

            const container = document.getElementById('konva-container');
            let stage = new Konva.Stage({
                container: 'konva-container',
                width: 1,   // Ancho dinÃ¡mico basado en el contenedor
                height: 1  // Alto dinÃ¡mico basado en el contenedor
            });

            mainLayer = new Konva.Layer();
            stage.add(mainLayer);


            // --- 3. EL CÃ“DIGO FINAL PARA EL BOTÃ“N MAXIMIZAR EN BOOTSTRAP 4 ---
            document.getElementById('toggleFullscreenBtn').addEventListener('click', function () {
                const modalDialog = document.querySelector('#elementModal .modal-dialog');

                // Alternamos nuestra clase personalizada '.modal-fullscreen-bs4'
                modalDialog.classList.toggle('modal-fullscreen-bs4');

                // Y tambiÃ©n alternamos '.modal-xl' para que no estÃ©n ambas al mismo tiempo
                modalDialog.classList.toggle('modal-xl');

                // Esperamos la animaciÃ³n y llamamos a nuestra funciÃ³n central.
                setTimeout(resizeCanvasToContainer, 250);

            });

            const colorPicker = document.getElementById('colorPicker');
            const brushSize = document.getElementById('brushSize');
            const clearCanvasBtn = document.getElementById('clearCanvasBtn');
            const saveCanvasBtn = document.getElementById('saveCanvasBtn');
            const componentControls = document.getElementById('componentGeneratorControls');
            const selectModeBtn = document.getElementById('selectModeBtn');
            const drawModeBtn = document.getElementById('drawModeBtn');

            let currentMode = 'select';
            let templateCableGroup = null;
            let selectedCanvasColor = '#000000';

            let transformer = new Konva.Transformer({
                borderStroke: 'blue', borderDash: [6, 2], rotateEnabled: true, anchorSize: 8, name: 'tool_transformer'
            });
            mainLayer.add(transformer);

            let snapIndicator = new Konva.Circle({
                radius: 7, stroke: 'red', strokeWidth: 2, visible: false, name: 'tool_snap_indicator'
            });
            mainLayer.add(snapIndicator);

            // --- 2. GESTIÃ“N DE MODOS DE TRABAJO ---
            function setMode(newMode) {
                currentMode = newMode;
                if (newMode === 'select') {
                    selectModeBtn.classList.add('btn-primary');
                    selectModeBtn.classList.remove('btn-outline-secondary');
                    drawModeBtn.classList.add('btn-outline-secondary');
                    drawModeBtn.classList.remove('btn-primary');
                    stage.container().style.cursor = 'default';
                    abortLineDrawing();
                } else { // 'draw'
                    drawModeBtn.classList.add('btn-primary');
                    drawModeBtn.classList.remove('btn-outline-secondary');
                    selectModeBtn.classList.add('btn-outline-secondary');
                    selectModeBtn.classList.remove('btn-primary');
                    stage.container().style.cursor = 'crosshair';
                    transformer.nodes([]);
                }
            }

            // Crear paleta de colores para lÃ­neas
            function createCanvasColorPalette() {
                const toolbar = document.getElementById('toolbar');
                const colorSection = document.createElement('div');
                colorSection.className = 'me-3 border-end pe-3';
                colorSection.innerHTML = '<span class="me-2 small">COLOR LÃNEA:</span>';

                const availableColorsComplete = [
                    { name: 'Negro', Color: '#000000' },
                    { name: 'Rojo', Color: '#FF0000' },
                    { name: 'Azul', Color: '#0000FF' },
                    { name: 'Verde', Color: '#008000' }
                ];

                availableColorsComplete.forEach((colorObject, index) => {
                    const colorBtn = document.createElement('button');
                    colorBtn.className = 'btn btn-sm me-1 canvas-color-btn';
                    colorBtn.style.backgroundColor = colorObject.Color;
                    colorBtn.style.width = '25px';
                    colorBtn.style.height = '25px';
                    colorBtn.style.border = '2px solid #ccc';
                    colorBtn.style.borderRadius = '4px';
                    colorBtn.title = `${colorObject.name} - ${colorObject.Color}`;
                    colorBtn.dataset.color = colorObject.Color;

                    if (index === 0) {
                        colorBtn.classList.add('active-canvas-color');
                        colorBtn.style.border = '2px solid #007bff';
                        selectedCanvasColor = colorObject.Color;
                    }

                    colorBtn.addEventListener('click', () => {
                        document.querySelectorAll('.canvas-color-btn').forEach(btn => {
                            btn.classList.remove('active-canvas-color');
                            btn.style.border = '2px solid #ccc';
                        });

                        colorBtn.classList.add('active-canvas-color');
                        colorBtn.style.border = '2px solid #007bff';
                        selectedCanvasColor = colorObject.Color;
                        colorPicker.value = colorObject.Color;

                        console.log(`ðŸŽ¨ Color seleccionado para lÃ­neas: ${colorObject.Color}`);
                    });

                    colorSection.appendChild(colorBtn);
                });

                const modeSection = toolbar.querySelector('.border-end');
                modeSection.parentNode.insertBefore(colorSection, modeSection.nextSibling);
            }

            if (document.getElementById('toolbar')) {
                createCanvasColorPalette();
            }

            selectModeBtn.addEventListener('click', () => setMode('select'));
            drawModeBtn.addEventListener('click', () => setMode('draw'));

            // --- 3. GESTIÃ“N DE EVENTOS DE RATÃ“N ---
            let isDrawingLine = false, lineStartPoint = null, previewLine = null;
            let startElement = null, endElement = null;

            stage.on('click tap', (e) => {
                if (currentMode === 'select') {
                    handleSelection(e);
                } else {
                    handleLineDrawing(e);
                }
            });


@* function handleSelection(e) {
    let selectedNode = null;
    if (e.target === stage) {
        transformer.nodes([]);
    } else {
        const group = e.target.getParent();
        if (group && (group.hasName('cable') || group.hasName('splitter'))) {
            transformer.nodes([group]);
            selectedNode = group;
        } else if (e.target.name() === 'connector') {
            transformer.nodes([e.target]);
            selectedNode = e.target;
        } else {
            transformer.nodes([]);
        }
    }
    
    // Ocultamos todos los manejadores...
    mainLayer.find('.line_handle').forEach(h => h.hide());
    // ...y solo mostramos los de la lÃ­nea que acabamos de seleccionar.
    if (selectedNode && selectedNode.name() === 'connector') {
        updateLineHandles(selectedNode);
    }
    mainLayer.draw();
} *@

function handleSelection(e) {
    // 1. LIMPIEZA PREVENTIVA: Ocultamos todos los manejadores 'X' que puedan estar visibles.
    //    Esto asegura que cada nueva selecciÃ³n comience desde un estado visual limpio.
    mainLayer.find('.line_handle').forEach(h => h.hide());

    // 2. CASO DE DESELECCIÃ“N: Si el usuario hizo clic en el fondo del lienzo...
    if (e.target === stage) {
        // ...le decimos al transformer que olvide TODO lo que tenÃ­a seleccionado.
        transformer.nodes([]);
        mainLayer.draw();
        return; // Salimos de la funciÃ³n inmediatamente.
    }

    // 3. IDENTIFICACIÃ“N PRECISA DEL OBJETIVO:
    let targetNode;
    const parentGroup = e.target.getParent();

    // Comprobamos si el clic fue en una parte de un cable/splitter.
    if (parentGroup && (parentGroup.hasName('cable') || parentGroup.hasName('splitter'))) {
        targetNode = parentGroup; // El objetivo real es el grupo completo.
    }
    // Si no, comprobamos si fue directamente en una lÃ­nea.
    else if (e.target.hasName('connector')) {
        targetNode = e.target; // El objetivo es la propia lÃ­nea.
    }
    // Si no es un objeto seleccionable...
    else {
        transformer.nodes([]); // ...tambiÃ©n deseleccionamos todo.
        mainLayer.draw();
        return;
    }

    // 4. Â¡LA CORRECCIÃ“N MÃS IMPORTANTE! LA SELECCIÃ“N ÃšNICA.
    //    Al usar `transformer.nodes([targetNode])`, estamos REEMPLAZANDO la selecciÃ³n.
    //    Esto BORRA la lista anterior de objetos seleccionados y la sustituye con una nueva
    //    lista que contiene ÃšNICAMENTE el 'targetNode' que acabamos de clickear.
    //    Esto previene el "daÃ±o colateral" porque es imposible tener selecciones mÃºltiples accidentales.
    transformer.nodes([targetNode]);

    // 5. MOSTRAR HERRAMIENTAS CONTEXTUALES:
    //    Solo si el objeto reciÃ©n seleccionado es una lÃ­nea, llamamos a la funciÃ³n
    //    que se encarga de mostrar sus manejadores 'X'.
    if (targetNode.hasName('connector')) {
        updateLineHandles(targetNode);
    }
    
    // 6. REDIBUJAR: Mostramos los cambios en el lienzo (el nuevo cuadro de selecciÃ³n, etc.).
    mainLayer.draw();
}

            

            function calculateOrthogonalPoints(startPos, endPos) {
                const midX = startPos.x + (endPos.x - startPos.x) / 2;
                return [startPos.x, startPos.y, midX, startPos.y, midX, endPos.y, endPos.x, endPos.y];
            }



            // REEMPLAZA TU FUNCIÃ“N ACTUAL CON ESTA VERSIÃ“N CORREGIDA
            function findElementAtPosition(pos) {
                let closestElement = null;
                let closestPointData = null;
                let minDistance = 15; // Este es nuestro radio mÃ¡ximo de bÃºsqueda

                // Recorremos todos los cables y splitters
                mainLayer.find('.cable, .splitter').forEach(group => {
                    // Recorremos los puntos de conexiÃ³n de cada grupo
                    (group.attrs.connectionPoints || []).forEach((point, index) => {
                        // Obtenemos la posiciÃ³n real del punto en el lienzo
                        const transform = group.getAbsoluteTransform();
                        const worldPoint = transform.point(point);

                        // Calculamos la distancia desde el cursor a este punto
                        const distance = Math.sqrt(Math.pow(worldPoint.x - pos.x, 2) + Math.pow(worldPoint.y - pos.y, 2));

                        // ===================================================================
                        // === ESTA ES LA LÃ“GICA CORREGIDA ==================================
                        // ===================================================================
                        // Si la distancia actual es MENOR que la mÃ­nima distancia que hemos encontrado hasta ahora...
                        if (distance < minDistance) {
                            // ...actualizamos la mÃ­nima distancia a este nuevo valor mÃ¡s pequeÃ±o.
                            minDistance = distance;
                            // Y guardamos este elemento y este punto como los "ganadores" actuales.
                            closestElement = group;
                            closestPointData = { point: point, index: index, worldPos: worldPoint };
                        }
                        // ===================================================================
                    });
                });

                // Al final del recorrido, devolvemos el elemento y el punto que resultaron ser los mÃ¡s cercanos de todos.
                return closestElement ? { element: closestElement, connectionPoint: closestPointData } : null;
            }




            @* function handleLineDrawing(e) {
    let pos = stage.getPointerPosition();
    let snappedPos = getSnapPoint(pos) || pos;

    if (!isDrawingLine) {
        // ... (cÃ³digo del inicio del trazo, no cambia)
        isDrawingLine = true;
        lineStartPoint = snappedPos;
        startElement = findElementAtPosition(pos);
        const lineColor = startElement ? startElement.connectionPoint.point.color : selectedCanvasColor;
        previewLine = new Konva.Line({
            points: [snappedPos.x, snappedPos.y, snappedPos.x, snappedPos.y],
            stroke: lineColor, strokeWidth: parseInt(brushSize.value), dash: [8, 4], name: 'connector_preview'
        });
        mainLayer.add(previewLine);
    } else {
        endElement = findElementAtPosition(pos);
        const finalLineColor = startElement ? startElement.connectionPoint.point.color : selectedCanvasColor;

        // ===================================================================
        // === CAMBIO CLAVE: Creamos la lÃ­nea con 3 puntos ===================
        // ===================================================================
        const startX = lineStartPoint.x;
        const startY = lineStartPoint.y;
        const endX = snappedPos.x;
        const endY = snappedPos.y;

        // Calculamos el punto medio exacto
        const midX = startX + (endX - startX) / 2;
        const midY = startY + (endY - startY) / 2;

        const finalLine = new Konva.Line({
            // El array de puntos ahora tiene 6 valores
            points: [startX, startY, midX, midY, endX, endY],
            stroke: finalLineColor,
            strokeWidth: parseInt(brushSize.value),
            name: 'connector',
            hitStrokeWidth: 20,
            cableAId: startElement ? startElement.element.id() : null,
            cableAConnIdx: startElement ? startElement.connectionPoint.index : null,
            cableBId: endElement ? endElement.element.id() : null,
            cableBConnIdx: endElement ? endElement.connectionPoint.index : null
        });

        mainLayer.add(finalLine);
        window.connectors.push(finalLine);

        // Seleccionamos la nueva lÃ­nea y mostramos su manejador
        transformer.nodes([finalLine]);
        updateLineHandles();

        abortLineDrawing();
    }
} *@

function handleLineDrawing(e) {
    let pos = stage.getPointerPosition();
    let snappedPos = getSnapPoint(pos) || pos;

    // Si NO estamos dibujando, este es el PRIMER clic para INICIAR una lÃ­nea.
    if (!isDrawingLine) {
        isDrawingLine = true;
        lineStartPoint = snappedPos;
        startElement = findElementAtPosition(pos);
        
        const lineColor = startElement ? startElement.connectionPoint.point.color : selectedCanvasColor;
        
        if (!previewLine) {
            previewLine = new Konva.Line({
                stroke: lineColor,
                strokeWidth: parseInt(brushSize.value),
                dash: [8, 4],
                name: 'connector_preview',
                visible: false
            });
            mainLayer.add(previewLine);
        }
        
        previewLine.stroke(lineColor);
        previewLine.points([lineStartPoint.x, lineStartPoint.y, snappedPos.x, snappedPos.y]);
        previewLine.visible(true);
        mainLayer.draw();
    }
    // Si YA estamos dibujando, este es el SEGUNDO clic para FINALIZAR la lÃ­nea.
    else {
        endElement = findElementAtPosition(pos);
        
        if (lineStartPoint.x === snappedPos.x && lineStartPoint.y === snappedPos.y) {
            abortLineDrawing();
            return;
        }

        const finalLineColor = previewLine.stroke();

        const finalLine = new Konva.Line({
            // La lÃ­nea se crea inicialmente con solo 2 puntos (4 valores).
            points: [lineStartPoint.x, lineStartPoint.y, snappedPos.x, snappedPos.y],
            stroke: finalLineColor,
            strokeWidth: parseInt(brushSize.value),
            name: 'connector',
            hitStrokeWidth: 20, // Aumentamos el Ã¡rea de clic para facilitar la adiciÃ³n de puntos
            cableAId: startElement ? startElement.element.id() : null,
            cableAConnIdx: startElement ? startElement.connectionPoint.index : null,
            cableBId: endElement ? endElement.element.id() : null,
            cableBConnIdx: endElement ? endElement.connectionPoint.index : null
        });

        // Le damos a la nueva lÃ­nea el "superpoder" de aÃ±adir puntos.
        attachPointAddingListener(finalLine);

        mainLayer.add(finalLine);
        window.connectors.push(finalLine);
        
        abortLineDrawing();
        
        // Seleccionamos la nueva lÃ­nea para que el usuario pueda empezar a editarla.
        transformer.nodes([finalLine]);
        updateLineHandles(finalLine);
    }
}


            function calculateAdaptiveLine(startPos, endPos) {
                const dx = endPos.x - startPos.x;
                const dy = endPos.y - startPos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 80) {
                    return [startPos.x, startPos.y, endPos.x, endPos.y];
                }

                const controlDistance = Math.min(distance * 0.4, 100);

                if (Math.abs(dx) > Math.abs(dy)) {
                    const midX1 = startPos.x + (dx > 0 ? controlDistance : -controlDistance);
                    const midX2 = endPos.x - (dx > 0 ? controlDistance : -controlDistance);
                    return [startPos.x, startPos.y, midX1, startPos.y, midX2, endPos.y, endPos.x, endPos.y];
                } else {
                    const midY1 = startPos.y + (dy > 0 ? controlDistance : -controlDistance);
                    const midY2 = endPos.y - (dy > 0 ? controlDistance : -controlDistance);
                    return [startPos.x, startPos.y, startPos.x, midY1, endPos.x, midY2, endPos.x, endPos.y];
                }
            }




           @* function updateConnectedLines(movedElement) {
    window.connectors = window.connectors || [];
    const movedId = movedElement.id();

    window.connectors.forEach(connector => {
        if (connector.attrs.cableAId === movedId || connector.attrs.cableBId === movedId) {
            const cableA = mainLayer.findOne('#' + connector.attrs.cableAId);
            const cableB = mainLayer.findOne('#' + connector.attrs.cableBId);

            if (cableA && cableB) {
                const posA = cableA.getAbsoluteTransform().point(cableA.attrs.connectionPoints[connector.attrs.cableAConnIdx]);
                const posB = cableB.getAbsoluteTransform().point(cableB.attrs.connectionPoints[connector.attrs.cableBConnIdx]);

                // ===================================================================
                // === LÃ“GICA DE DECISIÃ“N: Â¿La lÃ­nea fue curvada por el usuario? ===
                // ===================================================================

                let midX, midY;

                // Si la lÃ­nea tiene la bandera 'isManuallyBent', MANTENEMOS su punto medio.
                if (connector.attrs.isManuallyBent) {
                    const oldPoints = connector.points();
                    midX = oldPoints[2];
                    midY = oldPoints[3];
                } 
                // Si NO, la lÃ­nea se mantiene recta. RECALCULAMOS su punto medio.
                else {
                    midX = posA.x + (posB.x - posA.x) / 2;
                    midY = posA.y + (posB.y - posA.y) / 2;
                }
                
                // Actualizamos los puntos de la lÃ­nea con el punto medio decidido
                connector.points([posA.x, posA.y, midX, midY, posB.x, posB.y]);
                
                // Sincronizamos el manejador si existe
                if (connector.attrs.handle) {
                    connector.attrs.handle.position({ x: midX, y: midY });
                }
                // ===================================================================
            }
        }
    });

    mainLayer.batchDraw();
} *@

function updateConnectedLines(movedElement) {
    window.connectors.forEach(connector => {
        if (connector.attrs.cableAId === movedElement.id() || connector.attrs.cableBId === movedElement.id()) {
            const cableA = mainLayer.findOne('#' + connector.attrs.cableAId);
            const cableB = mainLayer.findOne('#' + connector.attrs.cableBId);
            if (cableA && cableB) {
                const posA = cableA.getAbsoluteTransform().point(cableA.attrs.connectionPoints[connector.attrs.cableAConnIdx]);
                const posB = cableB.getAbsoluteTransform().point(cableB.attrs.connectionPoints[connector.attrs.cableBConnIdx]);
                
                const points = connector.points();
                // Solo actualizamos el PRIMER y el ÃšLTIMO punto.
                points[0] = posA.x;
                points[1] = posA.y;
                points[points.length - 2] = posB.x;
                points[points.length - 1] = posB.y;
                connector.points(points);
                
                // Actualizamos la posiciÃ³n de los manejadores.
                updateLineHandles(connector);
            }
        }
    });
    mainLayer.batchDraw();
}

function distanceToSegment(p, v, w) {
    const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
    if (l2 === 0) return Math.sqrt((p.x - v.x)**2 + (p.y - v.y)**2);
    let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    t = Math.max(0, Math.min(1, t));
    const closestX = v.x + t * (w.x - v.x);
    const closestY = v.y + t * (w.y - v.y);
    return Math.sqrt((p.x - closestX)**2 + (p.y - closestY)**2);
}

function attachPointAddingListener(line) {
    line.on('click tap', (evt) => {
        // Solo permitimos aÃ±adir puntos si estamos en modo selecciÃ³n y no estamos haciendo clic
        // sobre un manejador existente (para evitar conflictos).
        if (currentMode !== 'select' || evt.target.getParent().hasName('line_handle')) {
            return;
        }

        const clickPos = stage.getPointerPosition();
        const points = line.points();
        
        // LÃ³gica para encontrar el segmento de lÃ­nea mÃ¡s cercano a nuestro clic
        let bestSegmentIndex = 0;
        let minDistance = Infinity;

        for (let i = 0; i < points.length - 2; i += 2) {
            const p1 = { x: points[i], y: points[i + 1] };
            const p2 = { x: points[i + 2], y: points[i + 3] };
            const dist = distanceToSegment(clickPos, p1, p2);
            if (dist < minDistance) {
                minDistance = dist;
                bestSegmentIndex = i + 2; // Este es el Ã­ndice donde insertaremos el nuevo punto
            }
        }
        
        // Insertamos el nuevo punto (x, y) en el array de puntos de la lÃ­nea.
        points.splice(bestSegmentIndex, 0, clickPos.x, clickPos.y);
        line.points(points);
        
        // Actualizamos los manejadores para que aparezca el nuevo.
        updateLineHandles(line);
    });
}


            function restoreOriginalShape() {
                mainLayer.find('.connector').forEach(line => {
                    if (line.attrs.startConnection && line.attrs.endConnection) {
                        const startTransform = line.attrs.startConnection.element.getAbsoluteTransform();
                        const endTransform = line.attrs.endConnection.element.getAbsoluteTransform();
                        const startPos = startTransform.point(line.attrs.startConnection.connectionPoint.point);
                        const endPos = endTransform.point(line.attrs.endConnection.connectionPoint.point);
                        line.points(calculateOrthogonalPoints(startPos, endPos));
                        line.tension(0);
                    }
                });
                mainLayer.draw();
            }

             function abortLineDrawing() {
                isDrawingLine = false;
                if (previewLine) previewLine.destroy();
                previewLine = null;
                startElement = null;
                endElement = null;
                snapIndicator.hide();
                mainLayer.draw();
            } 
 


            stage.on('mousemove', () => {
                if (currentMode !== 'draw' || !isDrawingLine) return;
                let pos = stage.getPointerPosition();
                let endPos = getSnapPoint(pos) || pos;
                if (getSnapPoint(pos)) {
                    snapIndicator.position(endPos).show();
                } else {
                    snapIndicator.hide();
                }
                previewLine.points(calculateOrthogonalPoints(lineStartPoint, endPos));
                mainLayer.draw();
            });

            function getSnapPoint(pos) {
                let closestPoint = null;
                let minDistance = 15;
                mainLayer.find('.cable, .splitter').forEach(group => {
                    (group.attrs.connectionPoints || []).forEach(point => {
                        const transform = group.getAbsoluteTransform();
                        const worldPoint = transform.point(point);
                        const distance = Math.sqrt(Math.pow(worldPoint.x - pos.x, 2) + Math.pow(worldPoint.y - pos.y, 2));
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestPoint = worldPoint;
                        }
                    });
                });
                return closestPoint;
            }

            componentControls.addEventListener('click', (e) => {
                const target = e.target;
                if (target.tagName !== 'BUTTON') return;

                if (target.dataset.strands) {
                    // --- INICIO DE LA NUEVA LÃ“GICA ---

                    // 1. Decide la direcciÃ³n: si el contador es par, 'right'; si es impar, 'left'.
                    const direction = (cableCreationCounter % 2 === 0) ? 'right' : 'left';

                    // 2. Llama a la funciÃ³n de dibujo pasÃ¡ndole la direcciÃ³n.
                    const newCable = createCableGroup(parseInt(target.dataset.strands), direction);

                    // 3. Coloca el cable en una posiciÃ³n inicial.
                    // El de la derecha empieza a la izquierda, el de la izquierda empieza a la derecha.
                    const initialX = (direction === 'right') ? 100 : stage.width() - 100;
                    newCable.position({ x: initialX, y: 250 });

                    // 4. Incrementa el contador para la prÃ³xima vez.
                    cableCreationCounter++;

                    // --- FIN DE LA NUEVA LÃ“GICA ---

                    mainLayer.add(newCable);
                    templateCableGroup = newCable;

                } else if (target.dataset.splitterOut) {
                    const splitterGroup = createSplitterGroup(1, parseInt(target.dataset.splitterOut));
                    splitterGroup.position({ x: 750 - 150, y: 250 }); // O stage.width() - 150
                    mainLayer.add(splitterGroup);
                }
                mainLayer.draw();
            });


            // REEMPLAZA TU FUNCIÃ“N CON ESTA VERSIÃ“N MEJORADA
            function createCableGroup(numStrands, direction = 'right') {
                const groupId = 'cable_' + nodeIdCounter++;
                const group = new Konva.Group({ id: groupId, draggable: true, name: 'cable', connectionPoints: [] });

                const directionMultiplier = (direction === 'left') ? -1 : 1;
                const lineThickness = 3, verticalSpacing = 15, cableWidth = 30;
                const circleRadius = 8;
                const fontSize = 10;
                const finalX = cableWidth * directionMultiplier;
                const totalHeight = (numStrands - 1) * verticalSpacing;
                const startY = -totalHeight / 2;
                let firstLineY, lastLineY;

                const colorsToUse = CABLE_COLOR_PALETTES[numStrands] || CABLE_COLOR_PALETTES.default;
                group.attrs.strandColors = [];

                for (let i = 0; i < numStrands; i++) {
                    const currentY = startY + (i * verticalSpacing);
                    const strandColor = colorsToUse[i % colorsToUse.length];
                    group.attrs.strandColors.push(strandColor);

                    if (i === 0) firstLineY = currentY;
                    if (i === numStrands - 1) lastLineY = currentY;

                    const linePoints = [0, currentY, finalX, currentY];
                    // ... (cÃ³digo para dibujar las lÃ­neas, no cambia)
                    if (strandColor === '#ffffff') {
                        group.add(new Konva.Line({ points: linePoints, stroke: 'black', strokeWidth: lineThickness, lineCap: 'round', listening: false }));
                        group.add(new Konva.Line({ points: linePoints, stroke: strandColor, strokeWidth: lineThickness - 1.5, lineCap: 'round', listening: false }));
                    } else {
                        group.add(new Konva.Line({ points: linePoints, stroke: strandColor, strokeWidth: lineThickness, lineCap: 'round', listening: false }));
                    }

                    const circleX = finalX + (circleRadius * directionMultiplier);

                    // ===================================================================
                    // === CAMBIO CLAVE: El punto de conexiÃ³n ahora estÃ¡ en el cÃ­rculo y guarda el color ===
                    // ===================================================================
                    group.attrs.connectionPoints.push({
                        x: circleX,         // PosiciÃ³n X en el centro del cÃ­rculo
                        y: currentY,        // PosiciÃ³n Y
                        color: strandColor, // Â¡Guardamos el color del hilo!
                        index: i            // Guardamos el Ã­ndice por si lo necesitamos
                    });
                    // ===================================================================

                    // ... (cÃ³digo para dibujar cÃ­rculos y nÃºmeros, no cambia)
                    const circle = new Konva.Circle({ x: circleX, y: currentY, radius: circleRadius, fill: 'white', stroke: strandColor, strokeWidth: 2, listening: false });
                    group.add(circle);
                    const numberText = new Konva.Text({ x: circleX - circleRadius, y: currentY - circleRadius, width: circleRadius * 2, height: circleRadius * 2, align: 'center', verticalAlign: 'middle', text: (i + 1).toString(), fontSize: fontSize, fill: 'black', listening: false });
                    group.add(numberText);
                }

                // --- RESTO DE LA FUNCIÃ“N (sin cambios) ---
                group.add(new Konva.Line({ points: [0, firstLineY, 0, lastLineY], stroke: 'black', strokeWidth: lineThickness, lineCap: 'round', listening: false }));
                const hitbox = new Konva.Rect({ ...group.getClientRect({ relativeTo: group }), fill: 'transparent' });
                group.add(hitbox);
                hitbox.moveToBottom();
                group.on('dragmove', () => updateConnectedLines(group));
                group.on('transform', () => updateConnectedLines(group));
                //group.on('dragend', () => restoreOriginalShape());

                return group;
            }



            function createSplitterGroup(numInputs, numOutputs) {
    const groupId = 'splitter_' + nodeIdCounter++;
    const group = new Konva.Group({ id: groupId, draggable: true, name: 'splitter', connectionPoints: [] });

    // --- 1. NUEVAS CONSTANTES PARA LOS CUADRADOS NUMERADOS ---
    const spacing = 20, width = 60, height = (numOutputs - 1) * spacing;
    const boxSize = 15;  // TamaÃ±o del cuadrado
    const fontSize = 10; // TamaÃ±o del nÃºmero

    // Punto de conexiÃ³n de entrada (sin cambios)
    group.attrs.connectionPoints.push({ x: 0, y: 0 });

    // Hitbox y forma del splitter (sin cambios)
    const hitbox = new Konva.Rect({ x: 0, y: -height / 2, width: width, height: height, fill: 'transparent' });
    group.add(hitbox);
    group.add(new Konva.Line({
        points: [0, 0, width, -height / 2, width, height / 2],
        closed: true,
        fill: 'white',
        stroke: 'black',
        strokeWidth: 2,
        listening: false
    }));

    // CÃ­rculo de entrada (sin cambios)
    group.add(new Konva.Circle({ x: 0, y: 0, radius: 5, fill: 'black', listening: false }));

    // ===================================================================
    // === INICIO DE LA MODIFICACIÃ“N: Bucle para Salidas Numeradas =======
    // ===================================================================
    for (let i = 0; i < numOutputs; i++) {
        const y = -height / 2 + i * spacing;

        // El punto de conexiÃ³n sigue estando en el centro, esto es correcto.
        group.attrs.connectionPoints.push({ x: width, y: y });

        // --- CÃ“DIGO ANTIGUO (Lo eliminamos) ---
        // group.add(new Konva.Circle({ x: width, y: y, radius: 5, fill: 'black', listening: false }));

        // --- CÃ“DIGO NUEVO (AÃ±adimos el cuadrado y el nÃºmero) ---

        // 2. Creamos el Cuadrado (Konva.Rect)
        // La posiciÃ³n (x, y) de un rectÃ¡ngulo es su esquina superior izquierda,
        // asÃ­ que restamos la mitad del tamaÃ±o para centrarlo.
        const rect = new Konva.Rect({
            x: width - boxSize / 2,
            y: y - boxSize / 2,
            width: boxSize,
            height: boxSize,
            fill: 'white',
            stroke: 'black',
            strokeWidth: 2,
            listening: false
        });
        group.add(rect);

        // 3. Creamos el Texto con el nÃºmero
        // Usamos la misma posiciÃ³n y tamaÃ±o para centrar el texto dentro del cuadrado.
        const numberText = new Konva.Text({
            x: width - boxSize / 2,
            y: y - boxSize / 2,
            width: boxSize,
            height: boxSize,
            text: (i + 1).toString(), // El nÃºmero es el Ã­ndice + 1
            fontSize: fontSize,
            fill: 'black',
            align: 'center',       // Centrado horizontal
            verticalAlign: 'middle', // Centrado vertical
            listening: false
        });
        group.add(numberText);
    }
    // ===================================================================
    // === FIN DE LA MODIFICACIÃ“N ========================================
    // ===================================================================

    // Eventos (sin cambios)
    group.on('dragmove', () => updateConnectedLines(group));
    group.on('transform', () => updateConnectedLines(group));
    // Eliminamos 'dragend' si ya no usas restoreOriginalShape
    // group.on('dragend', () => restoreOriginalShape());

    return group;
}
          
            //creado para polilinea
           @* function updateLineHandles() {
    // ... (cÃ³digo existente para obtener selectedNodes, recorrer las lÃ­neas, etc.)
    const selectedNodes = transformer.nodes();

    mainLayer.find('.connector').forEach(line => {
        const isSelected = selectedNodes.includes(line);
        let handle = line.attrs.handle;

        if (isSelected) {
            if (!handle) {
                // ... (cÃ³digo existente para crear el handle)
                const midPointIndex = 2;
                const midX = line.points()[midPointIndex];
                const midY = line.points()[midPointIndex + 1];

                handle = new Konva.Group({ x: midX, y: midY, draggable: true, name: 'line_handle' });
                handle.add(new Konva.Circle({ radius: 8, fill: '#dc3545', stroke: 'black', strokeWidth: 1 }));
                handle.add(new Konva.Text({ text: 'X', fontSize: 12, fill: 'white', fontStyle: 'bold', width: 16, height: 16, x: -8, y: -8, align: 'center', verticalAlign: 'middle' }));
                
                handle.attrs.line = line;
                mainLayer.add(handle);
                line.attrs.handle = handle;

                // EVENTO DE ARRASTRE
                handle.on('dragmove', () => {
                    const lineToUpdate = handle.attrs.line;
                    const points = lineToUpdate.points();
                    points[midPointIndex] = handle.x();
                    points[midPointIndex + 1] = handle.y();
                    lineToUpdate.points(points);
                    
                    // ===================================================================
                    // === CAMBIO CLAVE 1: Marcamos la lÃ­nea como modificada manualmente ===
                    lineToUpdate.attrs.isManuallyBent = true;
                    // ===================================================================

                    mainLayer.batchDraw();
                });

                // EVENTO DE CLIC (RESETEO)
                handle.on('click tap', () => {
                    const lineToReset = handle.attrs.line;
                    const cableA = mainLayer.findOne('#' + lineToReset.attrs.cableAId);
                    const cableB = mainLayer.findOne('#' + lineToReset.attrs.cableBId);

                    if (cableA && cableB) {
                        const posA = cableA.getAbsoluteTransform().point(cableA.attrs.connectionPoints[lineToReset.attrs.cableAConnIdx]);
                        const posB = cableB.getAbsoluteTransform().point(cableB.attrs.connectionPoints[lineToReset.attrs.cableBConnIdx]);
                        
                        const newMidX = posA.x + (posB.x - posA.x) / 2;
                        const newMidY = posA.y + (posB.y - posA.y) / 2;
                        
                        lineToReset.points([posA.x, posA.y, newMidX, newMidY, posB.x, posB.y]);
                        handle.position({ x: newMidX, y: newMidY });
                        
                        // ===================================================================
                        // === CAMBIO CLAVE 2: Desmarcamos la lÃ­nea al resetearla ===========
                        lineToReset.attrs.isManuallyBent = false;
                        // ===================================================================
                        
                        mainLayer.batchDraw();
                    }
                });
            }
            handle.show();
        } else {
            if (handle) {
                handle.hide();
            }
        }
    });

    mainLayer.find('.line_handle').forEach(h => h.moveToTop());
    mainLayer.batchDraw();
} *@

function updateLineHandles(line) {
    // Primero, eliminamos todos los manejadores antiguos asociados con esta lÃ­nea para evitar duplicados.
    mainLayer.find('.line_handle').forEach(handle => {
        if (handle.attrs.line === line) {
            handle.destroy();
        }
    });

    // Si la lÃ­nea no estÃ¡ seleccionada, no hacemos nada mÃ¡s.
    if (!transformer.nodes().includes(line)) {
        mainLayer.draw();
        return;
    }

    const points = line.points();
    // Creamos un manejador para cada PUNTO INTERMEDIO de la lÃ­nea.
    // (Ignoramos el primer y Ãºltimo punto, que estÃ¡n anclados a los cables).
    for (let i = 2; i < points.length - 2; i += 2) {
        const x = points[i];
        const y = points[i + 1];
        const pointIndex = i; // Guardamos el Ã­ndice de este punto

        const handle = new Konva.Group({
            x: x,
            y: y,
            draggable: true,
            name: 'line_handle'
        });

        // Guardamos la referencia a la lÃ­nea y al Ã­ndice del punto en el manejador.
        handle.attrs.line = line;
        handle.attrs.pointIndex = pointIndex;

        handle.add(new Konva.Circle({ radius: 8, fill: '#dc3545', stroke: 'black', strokeWidth: 1 }));
        handle.add(new Konva.Text({ text: 'X', fontSize: 12, fill: 'white', fontStyle: 'bold', width: 16, height: 16, x: -8, y: -8, align: 'center', verticalAlign: 'middle' }));
        
        mainLayer.add(handle);

        // EVENTO DE ARRASTRE: Mueve el punto en el array de la lÃ­nea.
        handle.on('dragmove', () => {
            const lineToUpdate = handle.attrs.line;
            const index = handle.attrs.pointIndex;
            const points = lineToUpdate.points();
            
            points[index] = handle.x();
            points[index + 1] = handle.y();
            lineToUpdate.points(points);
        });

        // EVENTO DE CLIC: Elimina el punto del array de la lÃ­nea.
        handle.on('click tap', () => {
            const lineToUpdate = handle.attrs.line;
            const index = handle.attrs.pointIndex;
            const points = lineToUpdate.points();

            // Eliminamos el par de coordenadas (x, y) del array de puntos.
            points.splice(index, 2);
            lineToUpdate.points(points);

            // Volvemos a dibujar los manejadores, que ahora serÃ¡n menos.
            updateLineHandles(lineToUpdate);
        });
    }
    mainLayer.find('.line_handle').forEach(h => h.moveToTop());
}




            // =========================================================================
            // === NUEVO SISTEMA DE GUARDADO SVG + JSON ================================
            // =========================================================================

            /**
             * ðŸŽ¯ NUEVA FUNCIÃ“N: Genera tanto JSON como SVG del dibujo actual
             */
            function generarDatosCompletos() {
                // 1. JSON (para ediciÃ³n)
                const jsonData = stage.toJSON();

                // 2. Preparar para exportar SVG
                transformer.nodes([]);  // quita selecciÃ³n
                snapIndicator.hide();
                mainLayer.draw();

                // 3. Exportar a SVG de manera segura
                let svgData = null;
                if (stage.toSVG) {
                    try {
                        svgData = stage.toSVG();
                    } catch (err) {
                        console.error("âŒ Error al exportar SVG:", err);
                        svgData = "<!-- Error en exportaciÃ³n -->";
                    }
                } else if (Konva && Konva.exportToSVG) {
                    svgData = Konva.exportToSVG(stage);
                } else {
                    console.warn("âš ï¸ ExportaciÃ³n SVG no disponible.");
                    svgData = "<!-- ExportaciÃ³n SVG no disponible -->";
                }

                return {
                    jsonContent: jsonData,
                    svgContent: svgData
                };
            }



              window.cargarDesdeJSON = function (dataFromAjax) {
                try {
                    let jsonData;
                    // Se asegura de que jsonData sea un string para poder parsearlo despuÃ©s
                    if (typeof dataFromAjax === 'object' && dataFromAjax !== null) {
                        jsonData = JSON.stringify(dataFromAjax);
                    } else if (typeof dataFromAjax === 'string' && dataFromAjax.trim() !== '') {
                        jsonData = dataFromAjax;
                    } else {
                        throw new Error("Los datos recibidos no son un JSON vÃ¡lido.");
                    }

                    if (stage) {
                        stage.destroy();
                    }

                    // ===================================================================
                    // =========== ESTE ES EL CAMBIO FUNDAMENTAL Y CORRECTO ==============
                    // ===================================================================

                    // 1. CREAMOS UN NUEVO LIENZO VACÃO CON LAS DIMENSIONES ACTUALES Y CORRECTAS
                    const container = document.getElementById('konva-container');
                    stage = new Konva.Stage({
                        container: 'konva-container',
                        width: container.clientWidth,
                        height: container.clientHeight
                    });

                    // 2. AHORA, CREAMOS LA CAPA A PARTIR DE LOS "HIJOS" DEL JSON
                    const data = JSON.parse(jsonData);
                    // data.children[0] es el objeto de la capa principal guardado en el JSON
                    mainLayer = Konva.Node.create(data.children[0]);
                    stage.add(mainLayer); // La aÃ±adimos a nuestro nuevo lienzo grande

                    // ===================================================================

                    // 3. (Opcional pero recomendado) Aplicamos el "clip fix" por si acaso
                    if (mainLayer) {
                        mainLayer.clipFunc(null);
                        mainLayer.clipX(undefined);
                        mainLayer.clipY(undefined);
                        mainLayer.clipWidth(undefined);
                        mainLayer.clipHeight(undefined);
                    }

                    // 4. Re-aÃ±adimos las herramientas a la nueva capa
                    transformer = new Konva.Transformer({ /* ... tus propiedades ... */ });
                    snapIndicator = new Konva.Circle({ /* ... tus propiedades ... */ });
                    mainLayer.add(transformer, snapIndicator);

                    // 5. Reconectamos los eventos
                    reconectarEventos();

                    // 6. Â¡AHORA SÃ! Dibujamos todo en el lienzo ya grande.
                    stage.draw();

                    console.log("âœ… Dibujo cargado en un nuevo lienzo con las dimensiones correctas.");

                } catch (error) {
                    console.error("âŒ Error CRÃTICO dentro de cargarDesdeJSON:", error);
                    alert("Error final al procesar los datos del dibujo: " + error.message);
                }
            }; 


           





                @* function reconectarEventos() {
                    if (!stage || !mainLayer) return;

                    // 1. Recargar el array global de conectores (esto ya estaba bien)
                    window.connectors = [];
                    mainLayer.find('.connector').forEach(connector => {
                        window.connectors.push(connector);
                    });

                    // 2. Reconectar eventos de arrastre para cables y splitters
                    mainLayer.find('.cable, .splitter').forEach(group => {
                        // ===================================================================
                        // === INICIO DE LA CORRECCIÃ“N: Reconstruir Puntos de ConexiÃ³n ======
                        // ===================================================================
                        if (group.hasName('cable')) {
                            // Limpiamos por si acaso
                            group.attrs.connectionPoints = [];

                            // Obtenemos los datos que sÃ­ se guardaron para reconstruir lo que falta
                            const numStrands = group.attrs.strandColors.length;
                            const firstLine = group.findOne('Line'); // Tomamos la primera lÃ­nea para deducir la direcciÃ³n
                            const direction = (firstLine && firstLine.points()[2] > 0) ? 'right' : 'left';
                            const directionMultiplier = (direction === 'left') ? -1 : 1;

                            // Constantes que necesitamos (las mismas que en createCableGroup)
                            const verticalSpacing = 15, cableWidth = 30, circleRadius = 8;
                            const finalX = cableWidth * directionMultiplier;
                            const circleX = finalX + (circleRadius * directionMultiplier);
                            const totalHeight = (numStrands - 1) * verticalSpacing;
                            const startY = -totalHeight / 2;

                            // Re-ejecutamos la misma lÃ³gica que en createCableGroup para rellenar el array
                            for (let i = 0; i < numStrands; i++) {
                                const currentY = startY + (i * verticalSpacing);
                                const strandColor = group.attrs.strandColors[i];

                                group.attrs.connectionPoints.push({
                                    x: circleX,
                                    y: currentY,
                                    color: strandColor,
                                    index: i
                                });
                            }
                        }
                        // (PodrÃ­as aÃ±adir una lÃ³gica similar para los splitters si tambiÃ©n lo necesitas)
                        // ===================================================================
                        // === FIN DE LA CORRECCIÃ“N ==========================================
                        // ===================================================================

                        group.draggable(true);
                        // Limpia listeners viejos por si acaso y aÃ±ade los nuevos
                        group.off('dragmove transform'); // Quitamos dragend porque ya no lo usamos
                        group.on('dragmove', () => updateConnectedLines(group));
                        group.on('transform', () => updateConnectedLines(group));
                    });

                    // 3. Reconectar el listener de SELECCIÃ“N en el STAGE (esto ya estaba bien)
                    stage.off('click tap');
                    stage.on('click tap', (e) => {
                        if (currentMode === 'select') {
                            handleSelection(e);
                        } else {
                            handleLineDrawing(e);
                        }
                    });

                    // 4. Reconectar los eventos de MOUSEMOVE (esto ya estaba bien)
                    stage.off('mousemove');
                    stage.on('mousemove', () => {
                        if (currentMode !== 'draw' || !isDrawingLine) return;
                        let pos = stage.getPointerPosition();
                        let endPos = getSnapPoint(pos) || pos;
                        if (getSnapPoint(pos)) {
                            snapIndicator.position(endPos).show();
                        } else {
                            snapIndicator.hide();
                        }
                        previewLine.points([lineStartPoint.x, lineStartPoint.y, endPos.x, endPos.y]); // AsegÃºrate de que aquÃ­ usas la lÃ­nea recta
                        mainLayer.draw();
                    });

                    console.log("ðŸ”— Eventos y datos de conexiÃ³n reconectados. Total de conectores:", window.connectors.length);
                } *@

                function reconectarEventos() {
    if (!stage || !mainLayer) return;

    // Limpiamos manejadores "fantasma" que pudieran haber sido cargados de un JSON antiguo.
    mainLayer.find('.line_handle').forEach(handle => handle.destroy());

    // Recargamos el array de conectores y les devolvemos su "superpoder".
    window.connectors = [];
    mainLayer.find('.connector').forEach(connector => {
        window.connectors.push(connector);
        
        // Â¡LA CORRECCIÃ“N CLAVE! Le devolvemos el "superpoder" a las lÃ­neas cargadas.
        attachPointAddingListener(connector);
    });

    // Reconstruimos los datos de conexiÃ³n perdidos para los cables y splitters.
    mainLayer.find('.cable, .splitter').forEach(group => {
        if (group.hasName('cable')) {
            group.attrs.connectionPoints = [];
            const numStrands = group.attrs.strandColors.length;
            const firstLine = group.findOne('Line');
            const direction = (firstLine && firstLine.points()[2] > 0) ? 'right' : 'left';
            const directionMultiplier = (direction === 'left') ? -1 : 1;
            const verticalSpacing = 15, cableWidth = 30, circleRadius = 8;
            const finalX = cableWidth * directionMultiplier;
            const circleX = finalX + (circleRadius * directionMultiplier);
            const totalHeight = (numStrands - 1) * verticalSpacing;
            const startY = -totalHeight / 2;
            for (let i = 0; i < numStrands; i++) {
                const currentY = startY + (i * verticalSpacing);
                const strandColor = group.attrs.strandColors[i];
                group.attrs.connectionPoints.push({
                    x: circleX,
                    y: currentY,
                    color: strandColor,
                    index: i
                });
            }
        }
        // (AquÃ­ podrÃ­as aÃ±adir la lÃ³gica para reconstruir los puntos de conexiÃ³n de los splitters si fuera necesario)

        group.draggable(true);
        group.off('dragmove transform');
        group.on('dragmove', () => updateConnectedLines(group));
        group.on('transform', () => updateConnectedLines(group));
    });

    // Reconectamos los eventos generales del stage.
    stage.off('click tap');
    stage.on('click tap', (e) => {
        if (currentMode === 'select') {
            handleSelection(e);
        } else {
            handleLineDrawing(e);
        }
    });

    // Reconectamos los eventos del ratÃ³n para la lÃ­nea de previsualizaciÃ³n.
    stage.off('mousemove');
    stage.on('mousemove', () => {
        if (currentMode !== 'draw' || !isDrawingLine) return;
        let pos = stage.getPointerPosition();
        let endPos = getSnapPoint(pos) || pos;
        if (getSnapPoint(pos)) {
            snapIndicator.position(endPos).show();
        } else {
            snapIndicator.hide();
        }
        if (previewLine) {
            previewLine.points([lineStartPoint.x, lineStartPoint.y, endPos.x, endPos.y]);
        }
        mainLayer.draw();
    });

    console.log("ðŸ”— Eventos, datos y listeners de lÃ­nea reconectados. Total de conectores:", window.connectors.length);
}




            // =========================================================================
            // === BOTÃ“N GUARDAR MEJORADO ==============================================
            // =========================================================================
            saveCanvasBtn.addEventListener('click', () => {
                // Ocultar herramientas antes de guardar
                transformer.nodes([]);
                snapIndicator.hide();
                mainLayer.draw();

                // Verificar que hay contenido
                const elementos = mainLayer.find('.cable, .splitter, .connector');
                if (elementos.length === 0) {
                    alert("No hay nada en el lienzo para guardar.");
                    return;
                }

                // Verificar datos del mapa
                if (!selectedMapElementData) {
                    alert("Error: No se ha seleccionado ningÃºn elemento del mapa. Cierra esta ventana y haz clic en una caja en el mapa primero.");
                    return;
                }

                // Generar datos completos
                const datosCompletos = generarDatosCompletos();

                // Preparar payload para el servidor
                const payload = {
                    DrawingId: selectedMapElementData.DrawingId,
                    ElementProjectId: selectedMapElementData.databaseId,
                    ProjectId: currentProjectId,
                    JsonContent: datosCompletos.jsonContent,
                    SvgContent: datosCompletos.svgContent
                };

                console.log("ðŸ“¤ Enviando datos al servidor...", payload);

                // Enviar al servidor
                $.ajax({
                    url: '/Project/Save',
                    type: 'POST',
                    contentType: 'application/json; charset=utf-8',
                    dataType: 'json',
                    data: JSON.stringify(payload),

                    success: function (response) {
                        console.log('âœ… Guardado exitoso:', response.message);
                        alert(`Â¡Dibujo guardado con Ã©xito! ID: ${response.message}`);
                        //window.location.reload(); // Recarga la pÃ¡gina para reflejar cambios
                        window.location = '/Project';

                    },

                    error: function (xhr, status, error) {
                        console.error('âŒ Error al guardar:', { status, error, response: xhr.responseText });
                        alert(`Error al guardar: ${xhr.responseText || error}`);
                    }
                });
            });

            // --- 5. LÃ“GICA DE TECLAS Y BOTONES ---
            clearCanvasBtn.addEventListener('click', () => {
                limpiarLienzoKonva();
            });

        

             function limpiarLienzoKonva() {
             // 1. Desvinculamos el transformer actual para evitar errores
                transformer.nodes([]);

             // 2. Destruimos todos los hijos de la capa de forma segura
                mainLayer.destroyChildren();

              // ===================================================================
              // === ESTA ES LA CORRECCIÃ“N CLAVE ===================================
              // ===================================================================
              // 3. Â¡VOLVEMOS A CREAR EL TRANSFORMER DESDE CERO!
              //    Esto nos da una instancia nueva y "sana" en lugar de usar
              //    la referencia al objeto que fue destruido.
              transformer = new Konva.Transformer({
              borderStroke: 'blue',
              borderDash: [6, 2],
              rotateEnabled: true,
              anchorSize: 8,
              name: 'tool_transformer' // Es importante mantener el nombre
             });
        // ===================================================================

             // 4. AÃ±adimos las herramientas (el nuevo transformer y el snapIndicator) a la capa vacÃ­a
                mainLayer.add(transformer, snapIndicator);

             // 5. Limpiamos nuestras variables de JavaScript
               templateCableGroup = null;
               window.connectors = [];

             // 6. Redibujamos la capa
               mainLayer.draw();

              console.log("ðŸ§¹ Lienzo completamente limpiado y reinicializado con un nuevo transformer.");
          }

          

          

                  
                  //codigo comentado pero el que se usa por si sale algo mal con el codiog actual
                @* window.addEventListener('keydown', (e) => {
                    if (e.key === 'Delete' || e.key === 'Backspace') {
                        const selectedNodes = transformer.nodes();
                        if (selectedNodes.length > 0) {

                            selectedNodes.forEach(nodeToDelete => {
                                // ===================================================================
                                // === INICIO DE LA LÃ“GICA DE BORRADO CORRECTA =======================
                                // ===================================================================

                                // Si el nodo a borrar es un cable o splitter (tiene un ID)
                                if (nodeToDelete.id()) {
                                    const idToDelete = nodeToDelete.id();

                                    // Creamos una lista de lÃ­neas para borrar
                                    const linesToDelete = [];
                                    mainLayer.find('.connector').forEach(line => {
                                        // Comprobamos si la lÃ­nea estÃ¡ conectada al ID del nodo que vamos a borrar
                                        if (line.attrs.cableAId === idToDelete || line.attrs.cableBId === idToDelete) {
                                            linesToDelete.push(line);
                                        }
                                    });

                                    // Borramos las lÃ­neas huÃ©rfanas
                                    linesToDelete.forEach(line => line.destroy());
                                }

                                // Ahora sÃ­, borramos el nodo principal (cable, splitter, o incluso una lÃ­nea seleccionada directamente)
                                nodeToDelete.destroy();

                                // ===================================================================
                                // === FIN DE LA LÃ“GICA DE BORRADO CORRECTA ==========================
                                // ===================================================================
                            });

                            // Limpiamos el transformer y redibujamos
                            transformer.nodes([]);
                            mainLayer.draw();
                        }
                    }
                    // ... (la lÃ³gica para duplicar con la tecla 'd' no cambia)
                }); *@



window.addEventListener('keydown', (e) => {
    if (e.key === 'Delete' || e.key === 'Backspace') {
        const selectedNodes = transformer.nodes();
        if (selectedNodes.length === 0) return;

        // 1. Desvinculamos el transformer INMEDIATAMENTE.
        //    Esto es crucial para prevenir que Konva intente operar sobre nodos que vamos a destruir.
        transformer.nodes([]);

        // 2. Destruimos los objetos que el usuario seleccionÃ³.
        selectedNodes.forEach(node => {
            // Si el nodo es un cable o splitter, tambiÃ©n debemos destruir las lÃ­neas conectadas a Ã©l.
            if (node.hasName('cable') || node.hasName('splitter')) {
                const idToDelete = node.id();
                // Usamos un bucle inverso para borrar de forma segura mientras iteramos.
                const connectors = mainLayer.find('.connector');
                for (let i = connectors.length - 1; i >= 0; i--) {
                    const line = connectors[i];
                    if (line.attrs.cableAId === idToDelete || line.attrs.cableBId === idToDelete) {
                        if (line.attrs.handle) {
                            line.attrs.handle.destroy();
                        }
                        line.destroy();
                    }
                }
            }
            
            // Si el propio nodo seleccionado era una lÃ­nea, destruimos su manejador.
            if (node.hasName('connector') && node.attrs.handle) {
                node.attrs.handle.destroy();
            }

            // Finalmente, destruimos el propio nodo seleccionado.
            node.destroy();
        });

        // ===================================================================
        // === LA CLAVE DE LA ESTABILIDAD: RECONSTRUIR, NO FILTRAR ===========
        // ===================================================================
        // 3. DespuÃ©s de que toda la destrucciÃ³n visual ha terminado, reconstruimos nuestro
        //    array de datos desde la Ãºnica "fuente de verdad": lo que queda en el lienzo.
        //    Esto es mucho mÃ¡s seguro que intentar filtrar un array potencialmente corrupto.
        //window.connectors = mainLayer.find('.connector').toArray();
        window.connectors = [...mainLayer.find('.connector')];
        // ===================================================================

        // 4. Redibujamos el lienzo para mostrar el estado final.
        mainLayer.draw();

        console.log("ðŸ—‘ï¸ Borrado seguro completado. Conectores restantes:", window.connectors.length);
    }

    // ... tu lÃ³gica para duplicar con la tecla 'd' no cambia
});



    


            // Cambio de color de lÃ­neas seleccionadas
            colorPicker.addEventListener('input', () => {
                const selectedNodes = transformer.nodes();
                if (selectedNodes.length > 0) {
                    selectedNodes.forEach(node => {
                        if (node.getClassName() === 'Line' && node.name() === 'connector') {
                            node.stroke(colorPicker.value);
                        }
                    });
                    mainLayer.draw();
                }
            });

            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('canvas-color-btn')) {
                    const newColor = e.target.dataset.color;
                    const selectedNodes = transformer.nodes();
                    if (selectedNodes.length > 0) {
                        selectedNodes.forEach(node => {
                            if (node.getClassName() === 'Line' && node.name() === 'connector') {
                                node.stroke(newColor);
                            }
                        });
                        mainLayer.draw();
                    }
                }
            });

            window.limpiarLienzoKonvaGlobal = limpiarLienzoKonva;

            console.log("ðŸš€ Sistema Konva con guardado SVG inicializado correctamente");
        });


    </script>

    @* Carga la API de Google Maps. Â¡AsegÃºrate de que 'libraries=drawing' estÃ© presente! *
   Reemplaza 'AIzaSyDp_qGGShO7CvdR5zFiH7KT4Mk3eGZO6VY' con tu CLAVE DE API real. *@
    <script async defer
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDp_qGGShO7CvdR5zFiH7KT4Mk3eGZO6VY&callback=initMap&v=weekly&solution_channel=GMP_CCS_simplepolygon_v2&libraries=drawing">
        </script>
}